<html id="html">
    <head>
        <title>Google Docs</title>
        <link rel="shortcut icon" href="https://ssl.gstatic.com/docs/documents/images/kix-favicon7.ico">
        <style>
            html, input {
                color: white;
                background: #222;
                font-family: monospace;
            }
            button {
                border: 2px solid lime;
                margin: 1px;
                cursor: pointer;
                color: lime;
                background: black;
                font-family: monospace;
                transition: 0.3s ease;
                border-radius: 3px;
            }
            .nonbutton {border: 2px solid green; color: green;}
            .Attack {border: 2px solid red; color: red;}
            .Skill {border: 2px solid skyblue; color: skyblue;}
            .Power {border: 2px solid yellow; color: yellow;}
            .Status {border: 2px solid lightgreen; color: lightgreen;}
            .Curse {border: 2px solid #666; color: #666;}
            .unplayable {border: 2px solid #555; color: #555;}
            button:hover:not(.unplayable) {background-color: #444;}
            button:hover > span {font-size: 13px;}
            table {width: 100%;}
            .tt {user-select: none;}
            .txt {
                position: absolute;
                background: #666;
                color: black;
                display: none;
                text-align: left;
                border-radius: 5px;
                margin-left: 10px;
                padding: 5px;
                z-index: 2;
            }
            .tt:hover > .txt {display: inline;}
            #energy, #player {display: inline;}
            #energy {
                border: 2px solid black;
                border-radius: 20px;
                padding: 3px;
                color: black;
                background: yellow;
            }
            #playerTd {width: 750px;}
            #rewardsScreen {text-align: center; width: 100%;}
            #rewardsScreen > button {text-align: center; width: 100%; border: none;}
            #mapScreen {margin-left: 42%; width: 58%;}
            .attacking::before { content: url(StS/intent-attack.png); }
            .bigattack::before { content: url(StS/intent-bigattack.png); }
            .blocking::before { content: url(StS/intent-block.png); }
            .buffing::before { content: url(StS/intent-buff.png); }
            .nerfing::before { content: url(StS/intent-nerf.png); }
            .meganerf::before { content: url(StS/intent-meganerf.png); }
            .unknown::before { content: url(StS/intent-unknown.png); }
            .attack-block::before { content: url(StS/intent-attackblock.png); }
            .block-buff::before { content: url(StS/intent-blockbuff.png); }
            .attack-nerf::before { content: url(StS/intent-attacknerf.png); }
            .attack-buff::before { content: url(StS/intent-attackbuff.png); }
            .block-nerf::before { content: url(StS/intent-blocknerf.png); }
            #cardModal, #bossModal, #selectionModal {
                position: fixed;
                z-index: 1;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0,0,0,0.7);
            }
            #cardModalContent, #bossModalContent, #selectionModalContent {
                background-color: #555;
                margin: 15% auto;
                padding: 20px;
                width: 80%;
            }
            #h1 {
                text-align: center;
                font-size: 30px;
                width: 80%;
                animation: grow 0.8s infinite;
                margin: 0px 0px 30px 140px;
            }
            #startButton, #rulesButton, #keyButton {
                text-align: center;
                width: 100%;
                border: none;
                font-size: 16px;
                transition: 0.2s ease-in-out;
            }
            #startButton:hover, #rulesButton:hover, #keyButton:hover {
                font-size: 21px;
                color: black;
                background: lime;
                font-weight: bold;
            }
            @keyframes grow {
                0%    { transform: scale(1);    }
                12.5% { transform: scale(1.08); }
                25%   { transform: scale(1.14); }
                37.5% { transform: scale(1.18); }
                50%   { transform: scale(1.20); }
                62.5% { transform: scale(1.18); }
                75%   { transform: scale(1.14); }
                87.5% { transform: scale(1.08); }
                100%  { transform: scale(1);    }
            }
            @keyframes boing {
                0%    { transform: translate(0px, 0px);   }
                12.5% { transform: translate(0px,-8px);   }
                25%   { transform: translate(0px, -14px); }
                37.5% { transform: translate(0px, -18px); }
                50%   { transform: translate(0px, -20px); }
                62.5% { transform: translate(0px, -18px); }
                75%   { transform: translate(0px, -14px); }
                87.5% { transform: translate(0px, -8px);  }
                100%  { transform: translate(0px, 0px);   }
            }
            @keyframes wiggle {
                0%  { transform: rotate(10deg);  }
                10% { transform: rotate(2deg);   }
                20% { transform: rotate(-4deg);  }
                30% { transform: rotate(-8deg);  }
                40% { transform: rotate(-10deg); }
                50% { transform: rotate(-10deg); }
                60% { transform: rotate(-2deg);  }
                70% { transform: rotate(4deg);   }
                80% { transform: rotate(8deg);   }
                90% { transform: rotate(10deg);  }
                100%{ transform: rotate(10deg);  }
            }
        </style>
    </head>
    <body>
        <b id="musicSayer" style="top:50px;opacity:0;position:absolute;width:100%;text-align:center;font-size:35px;color:yellow;"></b>
        
        <div id="selectionModal" style="display: none;">
            <div id="selectionModalContent"></div>
        </div>
        <div id="cardModal" style="display: none;">
            <div id="cardModalContent">
                <p>Choose a card to add to your deck:</p>
                <button id="modalCard1" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(0);"></button>
                <button id="modalCard2" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(1);"></button>
                <button id="modalCard3" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(2);"></button>
                <button id="modalSkipCard" class="Skill" onclick="getId('cardModal').style.display = 'none'; finishAddCard(-1);">Skip</button>
            </div>
        </div>
        <div id="bossModal" style="display: none;">
            <div id="bossModalContent">
                <p>Choose a Rare Relic to obtain:</p>
                <button id="modalRelic1" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(0);"></button>
                <button id="modalRelic2" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(1);"></button>
                <button id="modalRelic3" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(2);"></button>
            </div>
        </div>
        
        <span id="damageNumber0" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber1" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber2" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber3" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber4" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber5" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber6" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber7" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber8" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber9" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="playerDamageNumber" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        
        <span id="buffSayer0" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer1" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer2" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer3" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer4" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer5" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer6" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer7" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer8" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayer9" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="buffSayerForPlayer" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        
        <span id="statusContainer" style="display: none;">
            <span id="statusLineB4"></span>
            <button onclick='let d=deck.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);'>View <span style="text-decoration:underline">D</span>eck | <span style="color:white" id="deckSize">10</span></button>
            <span id="statusLine"></span>
        </span>
        <br /><br />
        <div id="introScreen" style="width: 100%;">
            <h1 id="h1">Slay The Spire <span class="Power" style="font-size:24px;border:none;">For Web</span></h1>
            <button id="startButton" onclick="getId('introScreen').style.display = 'none'; getId('statusContainer').style.display = 'block'; mapGen(); showMap(); beforeTime = Date.now(); currentTimer = 0;">Play <span style="font-size: 13px;color:red;">(sound)</span></button>
            <button id="rulesButton" onclick="getId('rulesScreen').style.display = 'block'; getId('ascensionScreen').style.display = 'none'; getId('keyScreen').style.display = 'none';">Instructions</button>
            <button id="keyButton" onclick="getId('keyScreen').style.display = 'block'; getId('ascensionScreen').style.display = 'none'; getId('rulesScreen').style.display = 'none';">Keybinds</button>
            <button id="keyButton" onclick="getId('ascensionScreen').style.display = 'block'; getId('keyScreen').style.display = 'none'; getId('rulesScreen').style.display = 'none';">Ascension</button>
            <pre id="rulesScreen" style="display: none;">
When you begin you will be on the Map. Click a highlighted node to travel there.
In combat, your cards will be shown on the left and the enemies will be on the right.
Click a card to play it. Depending on the card, it might target the selected enemy, all enemies, or yourself.
You should watch the enemies' intents and play cards accordingly.

A rest node is extremely useful, allowing you to heal or upgrade a card.
A shop sells cards and relics, gather gold from enemies to buy them.
Elites are stronger enemies that drop rare cards and a helpful Relic on defeat.

One last tip: Many things can be hovered to see their description.
            </pre>
            <pre id="keyScreen" style="display: none;">
Number          select from dialog / buy cards / play cards / travel
D               view and copy deck
T               pause/resume timer
E               end turn
O               change target
P               draw pile
I               discard pile
X               exhaust pile
, . /           use potion
Space           claim reward
C               continue (from shop, combat, rest)
R/S             rest/smith at rest sites
            </pre>
            <pre id="ascensionScreen" style="display: none;">
Your Ascension Level adds various modifiers to the game. The current max is level 20.
Note that the modifiers from lower levels stack.
Modifiers:
* 1 - Elites spawn more often.
* 2 - Normal enemies are stronger.
* 3 - Elites are stronger.
* 4 - Bosses are stronger.
* 5 - Heal less after bosses.
* 6 - Start the run damaged.
* 7 - Normal enemies are tougher.
* 8 - Elites are tougher.
* 9 - Bosses are tougher.
* 10- Start the run cursed.
* 11- One less potion slot.
* 12- No rares from elites.
* 13- Less money.
* 14- Lower Max HP.
* 15- Fewer rests and shops.
* 16- Higher prices.
* 17- Bigger starting deck.
* 18- Normal enemies have stronger abilities.
* 19- Elites have stronger abilities.
* 20- Bosses have stronger abilities.

Selected level: <input id="ascensionLevel" value="0" type="number" style="width: 70px">
            </pre>
        </div>
        <table id="gameScreen" style="display: none;">
            <tr>
                <td id="playerTd">
                    <div id="player"></div>
                    <br />
                    <span id="energy" class="tt"></span>&nbsp;&nbsp;&nbsp;<span id="hand"></span>
                    <br /><br />
                    <button id="discardPile" onclick='let d=discardPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);'>View D<span style="text-decoration:underline">i</span>scard Pile</button>
                    <button id="drawPile" onclick='let d=drawPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);'>View Draw <span style="text-decoration:underline">P</span>ile</button>
                    <button id="exhaustPile" onclick='let d=exhaustPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);'>View E<span style="text-decoration:underline">x</span>haust Pile</button>
                    | <button id="turnEnder"><span style="text-decoration:underline">E</span>nd Turn</button>
                </td>
                <td id="enemiesTd">
                    <div id="enemies"></div>
                </td>
            </tr>
        </table>
        <div id="rewardsScreen" style="display: none;">
            You won! Rewards:<br />
            <button id="goldReward"></button>
            <button id="cardReward" onclick="getId('cardReward').style.display = 'none'; addCard('random');">Add a card to your deck</button>
            <button id="potionReward"></button>
            <button id="relicReward" class="tt"></button>
            <button id="bossRelicReward" class="tt"></button>
            <button id="closeRewards" onclick="showMap();"><span style='text-decoration:underline'>C</span>ontinue</button>
        </div>
        <table id="mapScreen" style="display: none;"></table>
        <div id="restScreen" style="display: none;">
            <span>You are at a Rest Site. Choose an option below.</span>
            <br />
            <button onclick="hp = Math.min(maxHp, Math.round(hp+0.3*maxHp)); stats.rested = true; showMap();" class="tt"><span style='text-decoration:underline'>R</span>est<span class="txt" id="rest_txt">Heal 30% of your max HP. (currently 21 HP)</span></button>
            <button onclick="upgradeDialog();" class="tt"><span style='text-decoration:underline'>S</span>mith<span class="txt">Upgrade a card in your deck.</span></button>
            <div id="upgradeDialog" style="display: none;">
                <p id="cardDesc"></p>
                <button onclick="upgradeCard(cardToUpgrade); getId('upgradeDialog').style.display = 'none'; showMap();"><span style='text-decoration:underline'>C</span>onfirm</button>
            </div>
        </div>
        <table id="merchantScreen" style="display: none;">
        </table>
        <script>
            function shuffle(array) {
                let currentIndex = array.length, randomIndex;
                while(currentIndex != 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            }
            let getId = x => document.getElementById(x); getId("turnEnder").onclick = async () => endTurn();
            let choice = x => x[Math.floor(Math.random()*x.length)];
            let resolvePromise;
            let modalNames = [];
            function showPopup(displayText) {
                getId("selectionModal").style.display = "block";
                getId("selectionModalContent").innerHTML = "";
                let text = document.createElement("pre");
                text.setAttribute("onclick", "getId('selectionModal').style.display = 'none';");
                if(!displayText) {displayText="Nothing here..."}
                text.innerHTML = displayText+"\n(Click to close)";
                getId("selectionModalContent").appendChild(text);
            }
            async function showCardChoiceModal(displayCards, prompt) {
                getId("selectionModal").style.display = "block";
                getId("selectionModalContent").innerHTML = prompt + "<br/>";
                modalNames = [];
                for(let c of displayCards) {
                    modalNames.push(c.name);
                    let cardButton = document.createElement("button");
                    cardButton.setAttribute("onclick", "resolvePromise('"+c.name+"');");
                    cardButton.setAttribute("class", c.type+" tt");
                    cardButton.innerHTML = c.name+"<span class='txt'>"+addCircle(c.cost.toString())+" "+c.type+"<br/>"+unformat(c.desc)+"</span>";
                    getId("selectionModalContent").appendChild(cardButton);
                    let helpNumber = document.createElement("span");
                    helpNumber.style.position = "absolute";
                    let coords = cardButton.getBoundingClientRect();
                    helpNumber.style.top = coords.bottom;
                    helpNumber.style.left = coords.left + 0.5 * (coords.right - coords.left) - 5;
                    let ind = displayCards.indexOf(c) + 1;
                    helpNumber.innerHTML = (ind > 10 ? "" : (ind == 10 ? "0" : ind));
                    getId("selectionModalContent").appendChild(helpNumber);
                }
                let promise = new Promise((resolve, reject) => {
                    resolvePromise = resolve;
                });
                let chosenCard;
                await promise.then((result) => {
                    getId("selectionModal").style.display = "none";
                    chosenCard = displayCards[displayCards.map(x=>x.name).indexOf(result)];
                });
                return chosenCard;
            }
            async function choose(c, p) {
                if(c.length >= 1) {
                    let wooga = await showCardChoiceModal(c, p);
                    return wooga;
                } else {
                    return null;
                }
            }
            let mousex = 0;
            let mousey = 0;
            document.onmousemove = function(e) {
                let x = document.getElementsByClassName("txt");
                mousex = e.clientX;
                mousey = e.clientY;
                for (t of x) {
                    t.style.left = (mousex+10) + "px";
                    t.style.top = (mousey+10+window.pageYOffset) + "px";
                }
            }
            async function numberKey(num) {
                let n = num - 1;
                if(getId("cardModal").style.display != "none" && n<=2) {getId('cardModal').style.display='none'; finishAddCard(n);}
                else if(getId("cardModal").style.display != "none" && n==3) {getId('cardModal').style.display='none';finishAddCard(-1);}
                else if(getId("bossModal").style.display != "none" && n<=2) {getId('bossModal').style.display='none';finishAddRelic(n);}
                else if(getId("selectionModal").style.display != "none" && n<modalNames.length) { resolvePromise(modalNames[n]); }
                else if(getId("merchantScreen").style.display != "none" && n<offers.length) {
                    let offer = offers[n].offer;
                    let cost = offers[n].price;
                    if(gold >= cost) {
                        gold -= cost;
                        if(offers[n].index >= 100 && getId("relicElem_"+(n-6))) {
                            let r = new Relic(offer.name, offer.desc, offer.trigger, offer.use);
                            relics.push(r);
                            if(r.trigger=='on_pickup') {r.effect();}
                            getId("relicElem_"+(n-6)).style.display = "none";
                            updateStatLine();
                            updateShopScreen();
                        } else if(getId("cardElem_"+n)) {
                            deck.push(new Card(offer.name, offer.cost, offer.type, offer.desc, offer.use, offer.flags));
                            getId("cardElem_"+n).style.display = "none";
                            updateStatLine();
                            updateShopScreen();
                        }
                    }
                } else if(getId("gameScreen").style.display != "none") { await hand[n].play(); }
                else if(getId("mapScreen").style.display != "none" && n <= 2) {
                    if(map[mapY+1][mapX+n-1] != "") {gotoMap(mapY + 1, mapX + n - 1);}
                }
            }
            document.onkeypress = async function(e) {
                e = e || window.event;
                if(e.keyCode == 100) { // d
                    let d=deck.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);
                } else if(e.keyCode == 116) { // t
                    if(timerRunning){timerRunning=false;getId('timer').setAttribute('class','Attack');updateStatLine();}else{timerRunning=true;getId('timer').setAttribute('class','Skill');updateStatLine();}
                } else if(e.keyCode == 112 && getId("gameScreen").style.display != "none") { // p
                    let d=drawPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);
                } else if(e.keyCode == 105 && getId("gameScreen").style.display != "none") { // i
                    let d=discardPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);
                } else if(e.keyCode == 120 && getId("gameScreen").style.display != "none") { // x
                    let d=exhaustPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);
                } else if(e.keyCode == 101 && getId("gameScreen").style.display != "none") { // e
                    await endTurn();
                // numbers
                } else if(e.keyCode == 49) {await numberKey(1);}
                else if(e.keyCode == 50) {await numberKey(2);}
                else if(e.keyCode == 51) {await numberKey(3);}
                else if(e.keyCode == 52) {await numberKey(4);}
                else if(e.keyCode == 53) {await numberKey(5);}
                else if(e.keyCode == 54) {await numberKey(6);}
                else if(e.keyCode == 55) {await numberKey(7);}
                else if(e.keyCode == 56) {await numberKey(8);}
                else if(e.keyCode == 57) {await numberKey(9);}
                else if(e.keyCode == 48) {await numberKey(10);}
                else if(e.keyCode == 32) { // space
                    if(getId("rewardsScreen").style.display != "none") {
                        if(getId("goldReward").style.display != "none") {
                            let func = getId("goldReward").getAttribute("onclick"); eval(func);
                        } else if(getId("cardReward").style.display != "none") {
                            let func = getId("cardReward").getAttribute("onclick"); eval(func);
                        } else if(getId("potionReward").style.display != "none") {
                            let func = getId("potionReward").getAttribute("onclick"); eval(func);
                        } else if(getId("relicReward").style.display != "none") {
                            let func = getId("relicReward").getAttribute("onclick"); eval(func);
                        } else if(getId("bossRelicReward").style.display != "none") {
                            let func = getId("bossRelicReward").getAttribute("onclick"); eval(func);
                        } else { showMap(); }
                    }
                } else if(e.keyCode == 99) { // c
                    if(getId("merchantScreen").style.display != "none" || getId("rewardsScreen").style.display != "none") {
                        showMap();
                    } else if(getId("upgradeDialog").style.display != "none") {
                        upgradeCard(cardToUpgrade); getId('upgradeDialog').style.display = 'none'; showMap();
                    }
                } else if(e.keyCode == 114) { // r
                    if(getId("restScreen").style.display != "none") {
                        hp = Math.min(maxHp, Math.round(hp+0.3*maxHp)); stats.rested = true; showMap();
                    }
                } else if(e.keyCode == 115) { // s
                    if(getId("restScreen").style.display != "none") {upgradeDialog();}
                } else if(e.keyCode == 44) { // ,
                    if(potions.length >= 1) {let x = eval("let tgt=target; "+potions[0].effect); potions.splice(0, 1); updateHtml();}
                } else if(e.keyCode == 46) { // .
                    if(potions.length >= 2) {let x = eval("let tgt=target; "+potions[1].effect); potions.splice(1, 1); updateHtml();}
                } else if(e.keyCode == 47) { // /
                    if(potions.length >= 3) {let x = eval("let tgt=target; "+potions[2].effect); potions.splice(2, 1); updateHtml();}
                } else if(e.keyCode == 111 && getId("gameScreen").style.display != "none") { // o
                    let t = enemies.indexOf(target)+1; if(t >= enemies.length) {target = enemies[0];} else {target = enemies[t];}
                    updateHtml();
                }
            };
            function unformat(desc) {
                return desc.replace(" (Costs [BLOOD4BLOOD] energy)", "").replace("[HEAVYBLADE]", 14).replace("[HEAVYBLADE+]", 14).replace("[RAMPAGE]", 8).replace(" ([BLOCK] damage)", "").replace("[DAM", "").replace("[BLK", "").replace("[DAM", "").replace("[BLK", "").replace(" (Deals [FINISHER] damage)", "").replace(" (Deals [FINISHER+] damage)", "").replace("[SHIV]", 4).replace("[SHIV+]", 6).replace("]", "").replace("]", "");
            }
            function addCircle(char) {
                let circles = {"X": "ⓧ", "0": "⓪", "1": "①", "2": "②", "3": "③", "4": "④", "5": "⑤"};
                return "<b>"+circles[char]+"</b>";
                //return circles[char];
            }
            
            let timeouts = [];
            let playerTimeouts = [];
            let buffTimeouts = [];
            let playerBuffTimeouts = [];
            
            let music = {
                boss1: new Audio("ShovelKnight/therival.mp3"),
                boss2: new Audio("ShovelKnight/therival.mp3"),
                boss3: new Audio("ShovelKnight/therival.mp3"),
                enemy: new Audio("ShovelKnight/fightingwithallofourmight.mp3"),
                elite: new Audio("ShovelKnight/thedecadentdandy.mp3"),
                rest: new Audio("ShovelKnight/noweaponshere.mp3"),
                shop: new Audio("ShovelKnight/onefatefulknight.mp3"),
                menu: new Audio("ShovelKnight/maintheme.mp3"), // Doesn't seem to work, unused right now
                map: new Audio("ShovelKnight/steelthyshovel.mp3"),
                death: new Audio("ShovelKnight/thedonorsdespair.mp3"),
                win: new Audio("ShovelKnight/returntoorder.mp3"),
                bossDead: new Audio("ShovelKnight/forshovelry.mp3")
            };
            music.boss1.loop = true;
            music.boss2.loop = true;
            music.boss3.loop = true;
            music.enemy.loop = true;
            music.elite.loop = true;
            music.rest.loop = true;
            music.shop.loop = true;
            music.menu.loop = true;
            music.map.loop = true;
            music.death.loop = true;
            music.win.loop = true;
            music.boss1.volume = 0.5;
            music.boss2.volume = 0.5;
            music.boss3.volume = 0.5;
            music.enemy.volume = 0.5;
            music.elite.volume = 0.5;
            music.rest.volume = 0.4;
            music.shop.volume = 0.4;
            music.menu.volume = 0.4;
            music.map.volume = 0.25;
            music.death.volume = 0.5;
            music.win.volume = 0.5;
            music.bossDead.volume = 0.5;
            
            let announceMusic = function(name) {
                /*let sayer = getId("musicSayer");
                sayer.style.opacity = 1;
                sayer.innerHTML = "♫ "+name+" — Shovel Knight OST";
                for(let i=0; i<30; i++) {
                    setTimeout(function(){sayer.style.opacity = (29-i)/30}, 1500+i*8);
                }*/
            };
            
            class Card {
                /*
                'effect' is a function that takes the current target, whether it is used or not.
                */
                constructor(name, cost, type, desc, use, flags=[]) {
                    this.name = name;
                    this.cost = cost;
                    this.type = type;
                    this.desc = desc;
                    this.use = use;
                    this.flags = flags;
                    this.number = Math.random();
                }
                async play() {
                    let played = false;
                    if(this.cost == "X") {
                        for(let x=0; x<energy; x++) {
                            this.use(target);
                        }
                        energy = 0;
                        played = true;
                    } else {
                        let newCost = this.cost;
                        if(this.flags.includes("blood4blood")) {
                            newCost = Math.max(0, 4-stats.timesLostHp);
                        }
                        if(energy >= newCost && !(this.flags.includes("unplayable"))) {
                            energy -= newCost;
                            Promise.resolve(this.use(target));
                            played = true;
                        }
                    }
                    if(played) {
                        hand.splice(hand.indexOf(this), 1);
                        if(this.flags.includes("exhausted")) {
                            exhaustPile.push(this);
                            drawCard(hasBuff("Dark Embrace"));
                            if(hasBuff("Feel No Pain") > 0) {await gainBuff("Block", hasBuff("Feel No Pain"));}
                            for(let r of relics) {if(r.trigger == "on_exhaust") {r.effect();}}
                        } else {
                            discardPile.push(this);
                        }
                        await this.play_success();
                    }
                    updateHtml();
                }
                async play_success() {
                    if(hasBuff("Thousand Cuts") > 0) {for(let i of enemies) {dealDamage(i, hasBuff("Thousand Cuts"));}}
                    if(hasBuff("After Image") > 0) {await gainBuff("Block", hasBuff("After Image"));}
                    if(this.type == "Skill") {
                        stats.skillsThisTurn += 1;
                        for(let e of enemies) {
                            if(e.hasBuff("Enrage") > 0) {await e.gainBuff("Strength", e.hasBuff("Enrage"));}
                        }
                        for(let r of relics) {
                            if(r.trigger == "on_skill") {r.effect();}
                            if(r.trigger == "3_skills" && stats.skillsThisTurn % 3 == 0) {r.effect();}
                        }
                        if(hasBuff("Burst") > 0 && this.name != "Burst") {
                            await loseBuff("Burst", 1);
                            hand.push(this);
                            discardPile.splice(discardPile.indexOf(this), 1);
                            if(this.cost != "X") {energy += this.cost;}
                            await this.play();
                        }
                    }
                    if(this.type == "Power") {
                        for(let r of relics) {if(r.trigger == "on_power") {r.effect();}}
                    }
                    if(this.type == "Attack") {
                        stats.attacksThisTurn += 1;
                        if(hasBuff("Rage") > 0) {await gainBuff("Block", hasBuff("Rage"));}
                        if(hasBuff("Double Tap") > 0) {
                            await loseBuff("Double Tap", 1);
                            hand.push(this);
                            discardPile.splice(discardPile.indexOf(this), 1);
                            if(this.cost != "X") {energy += this.cost;}
                            await this.play();
                        }
                        for(let r of relics) {
                            if(r.trigger == "on_attack") {r.effect();}
                            if(r.trigger == "3_attacks" && stats.attacksThisTurn % 3 == 0) {r.effect();}
                        }
                    }
                    if(this.name.toLowerCase().includes("strike")) {
                        for(let r of relics) {if(r.trigger == "strike") {r.effect();}}
                    }
                    if(this.type != "Attack") {
                        if(hasBuff("Hex") > 0) {
                            for(let i=0; i<hasBuff("Hex"); i++) {discardPile.push(statusCards["Dazed"]());}
                        }
                    }
                }
            }
            
            class Enemy {
                /*
                'attacks' is a list of objects. Each one has a 'desc' and an 'effect'.
                The effect is a function that takes this object as a parameter (because it cannot use 'this').
                */
                constructor(name, hp, attacks, flags=[]) {
                    this.name = name;
                    this.number = Math.random();
                    this.hp = hp;
                    this.maxHp = hp;
                    this.attacks = attacks;
                    this.flags = flags;
                    this.buffs = [];
                    this.intent = (this.flags.includes("randomize") ? choice(attacks) : attacks[0]);
                }
                async attack() {
                    await this.intent.effect(this);
                    if(this.flags.includes("randomize")) {
                        // We need to change attacks each time.
                        let newIntent = choice(this.attacks);
                        while(newIntent == this.intent) {
                            newIntent = choice(this.attacks);
                        }
                        this.intent = newIntent;
                    } else if(this.attacks.indexOf(this.intent) + 1 == this.attacks.length && !(this.flags.includes("no-repeat"))) {
                        // Repeat is allowed and we are at the end: restart.
                        this.intent = this.attacks[0];
                    } else if(this.attacks.indexOf(this.intent) + 1 != this.attacks.length) {
                        // Else if we have something to go to: go to it.
                        this.intent = this.attacks[this.attacks.indexOf(this.intent) + 1];
                    }
                    updateHtml();
                }
                hasBuff(name) {
                    for(let b of this.buffs) {if(b.name == name) {return b.amt;}}
                    return 0;
                }
                async gainBuff(name, amt) {
                    if(debuffs.includes(name) && this.hasBuff("Artifact") > 0) {await this.loseBuff("Artifact", 1); updateHtml(); return;}
                    let newAmt = amt;
                    if(this.hasBuff("Frail") > 0 && name == "Block") {newAmt = Math.round(newAmt * 0.75);}
                    if(this.hasBuff("Dexterity") > 0 && name == "Block") {newAmt -= this.hasBuff("Dexterity");}
                    if(this.hasBuff("Minus Dexterity") > 0 && name == "Block") {newAmt -= this.hasBuff("Minus Dexterity");}
                    let foundBuff = false;
                    for(let b of this.buffs) {if(b.name == name) {b.amt += newAmt; foundBuff = true;}}
                    if(!foundBuff) {this.buffs.push({name: name, amt: newAmt});}
                    if(name=="Vulnerable" && newAmt > 0) {for(let r of relics) {if(r.trigger == "apply_vulnerable") {r.effect();}}}
                    
                    let idx = enemies.indexOf(this);
                    let dn = getId("buffSayer"+idx);
                    if(newAmt > 0) {
                        let str = "+"+newAmt+" "+name;
                        dn.innerHTML = str;
                        dn.style.top = getId("enemy_"+idx).getBoundingClientRect().top;
                        dn.style.left = getId("enemy_"+idx).getBoundingClientRect().left - (10 + str.length * 18);
                        dn.style.fontSize = "30px";
                        if(debuffs.includes(name)) {dn.style.color = "#f00";} else {dn.style.color = "lime";}
                        for(let i of buffTimeouts[idx]) {clearTimeout(i);}
                        buffTimeouts[idx] = [];
                        dn.style.opacity = "1";
                        for(let i=0; i<50; i++) {
                            buffTimeouts[idx].push(setTimeout(function(){dn.style.opacity = (49-i)/50}, i*5 + 750));
                        }
                        buffTimeouts[idx].push(setTimeout(function(){buffTimeouts[idx] = [];}, 1000));
                        return new Promise(resolve => setTimeout(function() {resolve(0);}, 300));
                    } else {
                        return new Promise(resolve => setTimeout(function(){resolve(0);}));
                    }
                }
                async loseBuff(name, amt=9999) {
                    let prevAmt;
                    for(let b of this.buffs) {
                        if(b.name == name) {
                            prevAmt = b.amt;
                            if(amt >= b.amt) {this.buffs.splice(this.buffs.indexOf(b), 1);} else {b.amt -= amt;}
                            break;
                        }
                    }
                    
                    let idx = enemies.indexOf(this);
                    let dn = getId("buffSayer"+idx);
                    if(amt > 0 && prevAmt > 0) {
                        let str = (prevAmt > amt ? "-"+amt+" "+name : name+" Wears Off");
                        dn.innerHTML = str;
                        dn.style.top = getId("enemy_"+idx).getBoundingClientRect().top;
                        dn.style.left = getId("enemy_"+idx).getBoundingClientRect().left - (10 + str.length * 18);
                        dn.style.fontSize = "30px";
                        if(debuffs.includes(name)) {dn.style.color = "#f00";} else {dn.style.color = "lime";}
                        for(let i of buffTimeouts[idx]) {clearTimeout(i);}
                        buffTimeouts[idx] = [];
                        dn.style.opacity = "1";
                        for(let i=0; i<50; i++) {
                            buffTimeouts[idx].push(setTimeout(function(){dn.style.opacity = (49-i)/50}, i*5 + 750));
                        }
                        buffTimeouts[idx].push(setTimeout(function(){buffTimeouts[idx] = [];}, 1000));
                        return new Promise((resolve, reject) => setTimeout(function() {resolve(0);}, 300));
                    } else {
                        return new Promise(resolve => setTimeout(function(){resolve(0);}));
                    }
                }
                async dealDamage(amt) {
                    let finalAmt = amt;
                    if(hasBuff("Vulnerable") > 0) {finalAmt = Math.round(finalAmt * 1.5);}
                    if(this.hasBuff("Weak") > 0) {finalAmt = Math.round(finalAmt * 0.75);}
                    finalAmt += this.hasBuff("Strength");
                    if(hasBuff("Buffer") > 0 && finalAmt > hasBuff("Block")) {finalAmt = 0; Promise.resolve(loseBuff("Buffer", 1));}
                    
                    hp -= Math.max(0, finalAmt - hasBuff("Block"));
                    if(finalAmt - hasBuff("Block") > 0) {
                        stats.timesLostHp++;
                        if(hasBuff("Thorns") > 0) {dealDamage(this, hasBuff("Thorns")); updateHtml();}
                        for(let r of relics) {if(r.trigger == "lose_hp") {r.effect();}}
                        getId("html").style.background = "#600";
                        let normalColor1 = function(){getId("html").style.background = "#511";}
                        let normalColor2 = function(){getId("html").style.background = "#411";}
                        let normalColor3 = function(){getId("html").style.background = "#322";}
                        let normalColor4 = function(){getId("html").style.background = "#222";}
                        setTimeout(normalColor1, 40);
                        setTimeout(normalColor2, 80);
                        setTimeout(normalColor3, 120);
                        setTimeout(normalColor4, 160);
                        let dn = getId("playerDamageNumber");
                        let dealt = finalAmt - hasBuff("Block");
                        if(dealt > 0) {
                            let GBCR = getId("statusLine").getBoundingClientRect();
                            dn.innerHTML = "-"+dealt;
                            dn.style.top = GBCR.top - 10;
                            dn.style.left = GBCR.left;
                            dn.style.fontSize = "50px";
                            dn.style.color = "yellow";
                            for(let i of playerTimeouts) {clearTimeout(i);}
                            playerTimeouts = [];
                            dn.style.opacity = "1";
                            for(let i=0; i<100; i++) {
                                playerTimeouts.push(setTimeout(function(){
                                    let i2 = 100-i; dn.style.transform = "translate(0px, "+(i2*i2*-0.5+i2*-1.5+5049)*(30/5050)+"px)";
                                }, i*5));
                            }
                            for(let i=0; i<50; i++) {
                                playerTimeouts.push(setTimeout(function(){dn.style.opacity = (49-i)/50;}, i*5 + 750));
                            }
                            playerTimeouts.push(setTimeout(function(){playerTimeouts = [];}, 1000));
                        }
                    }
                    Promise.resolve(loseBuff("Block", finalAmt));
                    return new Promise((resolve, reject) => setTimeout(function() {resolve(0);}, 300));
                }
            }
            
            class Relic {
                constructor(name, desc, trigger, effect) {
                    this.name = name;
                    this.desc = desc;
                    this.trigger = trigger;
                    this.use = effect;
                }
                effect(n=undefined) {
                    if(n) {this.use(n);} else {this.use();}
                }
            }
            
            function hasBuff(name) {
                for(let b of buffs) {if(b.name == name) {return b.amt;}}
                return 0;
            }
            async function gainBuff(name, amt) {
                if(debuffs.includes(name) && hasBuff("Artifact") > 0) {await loseBuff("Artifact", 1); updateHtml(); return;}
                let newAmt = amt;
                if(hasBuff("Frail") > 0           && name == "Block") {newAmt = Math.round(newAmt * 0.75);}
                if(hasBuff("Dexterity") > 0       && name == "Block") {newAmt += hasBuff("Dexterity");}
                if(hasBuff("Minus Dexterity") > 0 && name == "Block") {newAmt -= hasBuff("Minus Dexterity");}
                if(hasBuff("Juggernaut") > 0      && name == "Block") {dealDamage(choice(enemies), hasBuff("Juggernaut"));}
                if(name == "Vulnerable") {Promise.resolve(gainBuff(".", 1));}
                let foundIt = false; for(let b of buffs) {if(b.name == name) {b.amt += newAmt; foundIt = true;}}
                if(!foundIt) {buffs.push({name: name, amt: newAmt});}
                
                let dn = getId("buffSayerForPlayer");
                if(newAmt > 0) {
                    let str = "+"+newAmt+" "+name;
                    dn.innerHTML = str;
                    dn.style.top = getId("statusLine").getBoundingClientRect().bottom;
                    dn.style.left = getId("statusLine").getBoundingClientRect().left;
                    dn.style.fontSize = "30px";
                    if(debuffs.includes(name)) {dn.style.color = "#f00";} else {dn.style.color = "lime";}
                    for(let i of playerBuffTimeouts) {clearTimeout(i);}
                    playerBuffTimeouts = [];
                    dn.style.opacity = "1";
                    for(let i=0; i<50; i++) {
                        playerBuffTimeouts.push(setTimeout(function(){dn.style.opacity = (49-i)/50}, i*5 + 750));
                    }
                    playerBuffTimeouts.push(setTimeout(function(){playerBuffTimeouts = [];}, 1000));
                    return new Promise(resolve => setTimeout(function() {resolve(0);}, 300));
                }
                return new Promise(resolve => setTimeout(function() {resolve(0);}, 0));
            }
            async function loseBuff(name, amt=9999) {
                let prevAmt;
                for(let b of buffs) {
                    if(b.name == name) {
                        prevAmt = b.amt;
                        if(amt >= b.amt) {buffs.splice(buffs.indexOf(b), 1);} else {b.amt -= amt;}
                    }
                }
                
                let newAmt = Math.min(amt, prevAmt);
                let dn = getId("buffSayerForPlayer");
                if(newAmt > 0) {
                    let str = (prevAmt > amt ? "-"+amt+" "+name : name+" Wears Off");
                    dn.innerHTML = str;
                    dn.style.top = getId("statusLine").getBoundingClientRect().bottom;
                    dn.style.left = getId("statusLine").getBoundingClientRect().left;
                    dn.style.fontSize = "30px";
                    if(debuffs.includes(name)) {dn.style.color = "#f00";} else {dn.style.color = "lime";}
                    for(let i of playerBuffTimeouts) {clearTimeout(i);}
                    playerBuffTimeouts = [];
                    dn.style.opacity = "1";
                    for(let i=0; i<50; i++) {
                        playerBuffTimeouts.push(setTimeout(function(){dn.style.opacity = (49-i)/50}, i*5 + 750));
                    }
                    playerBuffTimeouts.push(setTimeout(function(){playerBuffTimeouts = [];}, 1000));
                    return new Promise(resolve => setTimeout(function() {resolve(0);}, 300));
                }
                return new Promise(resolve => setTimeout(function() {resolve(0);}, 0));
            }
            
            function dealDamage(actor, amt, shiv=false) {
                let finalAmt = amt;
                if(shiv) {finalAmt += hasBuff("Accuracy");}
                if(actor.hasBuff("Vulnerable")) { finalAmt = Math.round(finalAmt * 1.5); }
                if(hasBuff("Weak")) { finalAmt = Math.round(finalAmt * 0.75); }
                if(finalAmt > 0) {
                    finalAmt += hasBuff("Strength");
                    finalAmt -= hasBuff("Minus Strength");
                }
                let dealt = Math.max(0, finalAmt - actor.hasBuff("Block"));
                actor.hp -= dealt;
                if(dealt > 0) {
                    if(stats.hasAttacked == false) {
                        stats.hasAttacked = true;
                        for(let r of relics) {if(r.trigger == "first_attack") {r.effect();}}
                        if(hasBuff("Vigor") > 0) {
                            Promise.resolve(loseBuff("Strength", hasBuff("Vigor")));
                            Promise.resolve(loseBuff("Vigor"));
                        }
                    }
                    if(hasBuff("Envenom") > 0) {Promise.resolve(actor.gainBuff("Poison"), hasBuff("Envenom"));}
                }
                
                let num = enemies.indexOf(actor);
                let dn = getId("damageNumber"+num);
                if(dealt > 0) {
                    let GBCR = getId("enemy_"+num).getBoundingClientRect();
                    dn.innerHTML = "-"+dealt;
                    dn.style.top = GBCR.top - 10;
                    dn.style.left = GBCR.left + 0.5*(GBCR.right - GBCR.left) - (dealt.toString().length * 25);
                    dn.style.fontSize = "50px";
                    dn.style.color = "yellow";
                    for(let i of timeouts[num]) {clearTimeout(i);}
                    timeouts[num] = [];
                    dn.style.opacity = "1";
                    for(let i=0; i<100; i++) {
                        timeouts[num].push(setTimeout(function(){
                            let i2 = 100-i; dn.style.transform = "translate(0px, "+(i2*i2*0.5 + i2*1.5 - 5049)*(30/5050)+"px)";
                        }, i*5));
                    }
                    for(let i=0; i<50; i++) {
                        timeouts[num].push(setTimeout(function(){dn.style.opacity = (49-i)/50;}, i*5 + 750));
                    }
                    timeouts[num].push(setTimeout(function(){timeouts[num] = [];}, 1000));
                } else if(finalAmt > 0) {
                    let GBCR = getId("enemy_"+num).getBoundingClientRect();
                    dn.innerHTML = "Blocked";
                    dn.style.top = GBCR.top - 10;
                    dn.style.left = GBCR.left + 0.5*(GBCR.right - GBCR.left) - (dealt.toString().length * 15);
                    dn.style.fontSize = "30px";
                    dn.style.color = "skyblue";
                    for(let i of timeouts[num]) {clearTimeout(i);}
                    timeouts[num] = [];
                    dn.style.opacity = "1";
                    for(let i=0; i<100; i++) {
                        timeouts[num].push(setTimeout(function(){
                            let i2 = 100-i; dn.style.transform = "translate(0px, "+(i2*i2*0.5 + i2*1.5 - 5049)*(30/5050)+"px)";
                        }, i*5));
                    }
                    for(let i=0; i<50; i++) {
                        timeouts[num].push(setTimeout(function(){dn.style.opacity = (49-i)/50;}, i*5 + 750));
                    }
                    timeouts[num].push(setTimeout(function(){timeouts[num] = [];}, 1000));
                }
                
                for(let b of actor.buffs) {
                    if(b.name == "Block") {
                        if(finalAmt >= b.amt) {actor.buffs.splice(actor.buffs.indexOf(b), 1);} else {b.amt -= finalAmt;}
                        break;
                    }
                }
                if(finalAmt > 0 && actor.hasBuff("Thorns") > 0) {Promise.resolve(actor.dealDamage(actor.hasBuff("Thorns"))); updateHtml();}
            }
            let buffDesc = {
                "Block": "Until next turn, prevents [AMT] damage.",
                "Vulnerable": "Take 50% more damage for [AMT] turn[s].",
                "Weak": "Deal 25% less damage for [AMT] turn[s].",
                "Strength": "Attacks deal [AMT] more damage.",
                "Dexterity": "Cards gain you [AMT] more Block.",
                "Strength Down": "At the end of this turn, lose [AMT] Strength.",
                "No Draw": "Cannot draw cards for [AMT] turn[s].",
                "Combust": "At the end of your turn, lose 1 HP and deal [DAMT] damage to ALL enemies.",
                "Dark Embrace": "When a card is Exhausted, draw [AMT] card[s].",
                "Thorns": "When recieving unblocked damage, deal [DAMT] damage back.",
                "Ritual": "At end of turn, gain [AMT] Strength.",
                "Frail": "Gain 25% less Block for [AMT] turn[s].",
                "Enrage": "When you play a Skill, gains [AMT] Strength.",
                "Minus Strength": "Attacks deal [AMT] less damage.",
                "Minus Dexterity": "Gain [AMT] less block from cards.",
                "Evolve": "Whenever you draw a Status card, draw [AMT] card[s].",
                "Pen Nib": "When you get 10 Pen Nib, deal 10 damage.",
                "Feel No Pain": "When a card is Exausted, gain [BAMT] Block.",
                "Fire Breathing": "Whenever you draw a Status card, deal [DAMT] damage to ALL enemies.",
                "Metallicize": "Start each turn with [BAMT] Block.",
                "Rage": "For each Attack you play this turn, gain [BAMT] Block.",
                "Rampage": "Increase Rampage's damage by [AMT].",
                "Barricade": "Block is not removed at the start of your turn.",
                "Berserk": "Gain [AMT] more energy each turn.",
                "Brutality": "At the start of your turn, lose 1 HP and draw [AMT] card[s].",
                "Double Tap": "The next Attack you play is played [AMT] more time[s]",
                "Juggernaut": "Whenever you gain Block, deal [DAMT] damage to a random enemy.",
                "Regen": "At end of turn, heal [AMT] HP and reduce Regen by 1.",
                "Dexterity Down": "At end of turn, lose [AMT] Dexterity.",
                "Artifact": "Negates the next [AMT] debuff[s].",
                "Hex": "When you play a non-Attack card, add [AMT] Dazed to your discard pile.",
                "Draw Reduction": "Draw 1 fewer card for [AMT] turn[s].",
                "Buffer": "Prevent the first [AMT] unblocked hit[s].",
                "Next Turn Block": "Gain [BAMT] Block next turn.",
                "Vigor": "[AMT] of your Strength only applies to 1st attack.",
                "Next Turn Energy": "Gain [AMT] more energy next turn.",
                "Poison": "Lose [AMT] HP at start of turn. Poison goes down each turn.",
                "Accuracy": "Shivs deal [AMT] more damage.",
                "Blur": "Keep your Block for [AMT] turn[s].",
                "Infinite Blades": "Get [AMT] Shiv[s] each turn.",
                "Noxious Fumes": "At the start of your turn, apply [AMT] Poison to ALL enemies.",
                "Next Turn Cards": "Draw [AMT] more card[s] next turn.",
                "Thousand Cuts": "Whenever you play a card, deal [DAMT] damage to ALL enemies.",
                "After Image": "Whenever you play a card, gain [BAMT] Block.",
                "Burst": "Your next [AMT] Skill[s] are played twice.",
                "Envenom": "When you deal unblocked damage, apply [AMT] Poison.",
                "Tools of the Trade": "At the start of your turn, draw [AMT] card[s] and a discard 1 card.",
                ".": "You weren't supposed to see this. Just ignore it."
            };
            let debuffs = ["Vulnerable", "Weak", "Strength Down", "No Draw", "Frail", "Minus Strength", "Minus Dexterity", "Dexterity Down", "Hex", "Draw Reduction", "Poison"];
            let statusCards = {
                "Wound": () => new Card("Wound", 0, "Status", "Unplayable.", function(enemy){}, ["unplayable"]),
                "Dazed": () => new Card("Dazed", 0, "Status", "Unplayable. Ethereal.", function(enemy){}, ["unplayable", "ethereal"]),
                "Slimed": () => new Card("Slimed", 1, "Status", "Exhaust.", function(enemy){}, ["exhausted"]),
                "Burn": () => new Card("Burn", 0, "Status", "Unplayable. Lose 1 HP at end of turn.", function(enemy){}, ["unplayable", "burning"])
            };
            
            function showMap() {
                music.shop.pause(); music.rest.pause();
                music.shop.currentTime = 0; music.rest.currentTime = 0;
                if(mapY >= 15) {
                    mapY = 0;
                    hp = (getId("ascensionLevel").value >= 5 ? hp+0.75*(maxHp-hp) : maxHp);
                    mapGen();
                    maxEnergy += 1;
                    if(actNum == 1) {
                        actNum = 2;
                    } else if(actNum == 2) {
                        actNum = 3;
                    } else if(actNum == 3) {
                        actNum = 10;
                        timerRunning = false; updateStatusLine(); music.win.play(); announceMusic("A Return To Order"); return;
                    }
                }
                updateStatLine();
                getId("rewardsScreen").style.display = "none";
                getId("restScreen").style.display = "none";
                getId("merchantScreen").style.display = "none";
                if(actNum > 3) {return;} // I don't really need this, right?
                getId("mapScreen").style.display = "block";
                music.map.play();
                announceMusic("Steel Thy Shovel");
                getId("mapScreen").innerHTML = "Select your next room...";
                for(let floor in map) {
                    let floorElem = document.createElement("tr");
                    for(let node in map[floor]) {
                        let nodeElem = document.createElement("td");
                        if(map[floor][node] != "") {
                            let nodeButton = document.createElement("button");
                            nodeButton.innerHTML = map[floor][node]+"<span class='txt'>"+
                                (map[floor][node]=="enemy" ? "Fight some monsters. Get gold, a card and maybe a potion if you win." : 
                                  (map[floor][node]=="elite" ? "Fight a strong monster. Get gold, a rare card, a relic, and maybe a potion if you win." : 
                                    (map[floor][node]=="rest&nbsp;" ? "Rest and heal some HP or upgrade a card." : 
                                     (map[floor][node]=="shop&nbsp;" ? "Buy cards and relics at the shop." : "Fight a Boss. Cool stuff if you win.")))
                                )+"</span>";
                            nodeButton.setAttribute("class", "tt notbig");
                            if(floor-1 == mapY && Math.abs(node-mapX) <= 1) {
                                nodeButton.setAttribute("onclick", `gotoMap(${floor}, ${node});`);
                            } else if(floor == mapY && node == mapX) {
                                nodeButton.innerHTML = "(You)";
                            } else {
                                nodeButton.setAttribute("class", "nonbutton notbig");
                            }
                            nodeElem.appendChild(nodeButton);
                        }
                        floorElem.appendChild(nodeElem);
                    }
                    getId("mapScreen").appendChild(floorElem);
                }
            }
            function gotoMap(y, x) {
                mapY = y;
                mapX = x;
                timerRunning = true; updateStatLine();
                music.map.pause();
                music.map.currentTime = 0;
                let readyBattle = function() {
                    getId("mapScreen").style.display = "none";
                    getId("gameScreen").style.display = "block";
                    if(eliteBattle == true) {music.elite.play(); announceMusic("Strike The Earth!");}
                    else if(bossBattle && actNum == 1) {music.boss1.play(); announceMusic("The Decadent Dandy");}
                    else if(bossBattle && actNum == 2) {music.boss2.play(); announceMusic("The Schemer");}
                    else if(bossBattle && actNum == 3) {music.boss3.play(); announceMusic("The Rival");}
                    else {music.enemy.play(); announceMusic("Fighting With All Of Our Might");}
                    drawPile = [];
                    discardPile = [];
                    exhaustPile = [];
                    hand = [];
                    buffs = [];
                    energy = 0; // no ice cream hax
                    stats = {timesLostHp: 0, hasAttacked: false, attacksThisTurn: 999, skillsThisTurn: 999, rested: stats.rested};
                    target = enemies[0];
                    
                    let shuffledDeck = shuffle(deck);
                    for(let card of shuffledDeck) {
                        if(card.flags.includes("innate")) {
                            hand.push(card);
                        } else {
                            drawPile.push(card);
                        }
                    }
                    
                    for(let r of relics) {if(r.trigger == "combat_start") {r.effect();}}
                    timeouts = enemies.map(x=>[]);
                    buffTimeouts = enemies.map(x=>[]);
                    playerBuffTimeouts = [];
                    startTurn();
                }
                if(map[y][x] == "enemy") {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleEnemies)();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleEnemies_act2)();
                    } else {
                        nme = () => choice(possibleEnemies_act3)();
                    }
                    if(mapY >= 2) {enemies = [nme(), nme()]}
                    else {enemies = [nme()]}
                    eliteBattle = false;
                    bossBattle = false;
                    readyBattle();
                } else if(map[y][x] == "elite") {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleElites)();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleElites_act2)();
                    } else {
                        nme = () => choice(possibleElites_act3)();
                    }
                    enemies = [nme()];
                    eliteBattle = true;
                    bossBattle = false;
                    readyBattle();
                } else if(map[y][x].includes("BOSS")) {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleBosses)();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleBosses_act2)();
                    } else {
                        nme = () => choice(possibleBosses_act3)();
                    }
                    enemies = [nme()];
                    eliteBattle = false;
                    bossBattle = true;
                    readyBattle();
                } else if(map[y][x] == "rest&nbsp;") {
                    getId("mapScreen").style.display = "none";
                    getId("restScreen").style.display = "block";
                    getId("rest_txt").innerHTML = "Heal 30% of your max HP. (currently "+Math.round(0.3 * maxHp)+" HP)";
                    music.rest.play();
                    announceMusic("No Weapons Here");
                } else if(map[y][x] == "shop&nbsp;") {
                    getId("mapScreen").style.display = "none";
                    getId("merchantScreen").style.display = "block";
                    music.shop.play();
                    announceMusic("One Fateful Knight");
                    getId("merchantScreen").innerHTML = "";
                    offers = [];
                    for(let i=0; i<6; i++) {
                        let offer = randCard()();
                        let cardCost = Math.round(Math.random()*37 + 45); // cost: 45g to 81g
                        if(getId("ascensionLevel").value >= 16) {cardCost = Math.round(Math.random()*43 + 51);} // cost: 51g to 93g
                        offers.push({index: i, price: cardCost, offer: offer});
                        if(i==0) {cardCost = Math.round(cardCost * 0.45);}
                        if(i==5) {cardCost = Math.round(Math.random()*30 + 135); offer = randRareCard()();} // 6th card is rare
                        let cardElem = document.createElement("tr");
                        let nameWrapper = document.createElement("td");
                        let nameElem = document.createElement("button");
                        let costElem = document.createElement("td");
                        cardElem.setAttribute("id", `cardElem_${i}`);
                        nameElem.setAttribute("id", `cardName_${i}`);
                        nameElem.innerHTML = offer.name+"<span class='txt'>"+addCircle(offer.cost.toString())+" "+offer.type+"<br/>"+unformat(offer.desc)+"</span>";
                        if(gold >= cardCost) {
                            if(i==0) {
                                nameElem.setAttribute("class", "Skill tt");
                            } else {
                                nameElem.setAttribute("class", "tt");
                            }
                        } else {
                            nameElem.setAttribute("class", "tt unplayable");
                        }
                        nameElem.setAttribute("onclick", `if(gold >= ${cardCost}) {
gold -= ${cardCost};
deck.push(new Card("${offer.name}", ${offer.cost}, "${offer.type}", "${offer.desc}", ${offer.use}, ${JSON.stringify(offer.flags)}));
getId("cardElem_${i}").style.display = "none";
updateStatLine();
updateShopScreen();
}
                        `);
                        costElem.innerHTML = "Cost: $"+cardCost;
                        
                        nameWrapper.appendChild(nameElem);
                        cardElem.appendChild(nameWrapper);
                        cardElem.appendChild(costElem);
                        getId("merchantScreen").appendChild(cardElem);
                        let helpNumber = document.createElement("span");
                        helpNumber.style.position = "absolute";
                        helpNumber.setAttribute("class", "helpNumber");
                        let coords = cardElem.getBoundingClientRect();
                        helpNumber.style.top = coords.top;
                        helpNumber.style.left = coords.left - 10;
                        let ind = i + 1;
                        helpNumber.innerHTML = (ind > 10 ? "" : (ind == 10 ? "0" : ind));
                        getId("merchantScreen").appendChild(helpNumber);
                    }
                    for(let i=0; i<3; i++) {
                        let offer = choice(relicPool)();
                        let relicCost = Math.round(Math.random()*119 + 143);
                        offers.push({index: i+100, price: relicCost, offer: offer});
                        let relicElem = document.createElement("tr");
                        let nameWrapper = document.createElement("td");
                        let nameElem = document.createElement("button");
                        let costElem = document.createElement("td");
                        relicElem.setAttribute("id", `relicElem_${i}`);
                        nameElem.setAttribute("id", `relicName_${i}`);
                        nameElem.innerHTML = offer.name+"<span class='txt'>"+offer.desc+"</span>";
                        if(gold >= relicCost) {
                            nameElem.setAttribute("class", "Status tt");
                        } else {
                            nameElem.setAttribute("class", "Status tt unplayable");
                        }
                        nameElem.setAttribute("onclick", `if(gold >= ${relicCost}) {
gold -= ${relicCost};
let r = new Relic("${offer.name}", "${offer.desc}", "${offer.trigger}", ${offer.use});
relics.push(r);
if(r.trigger=='on_pickup') {r.effect();}
getId("relicElem_${i}").style.display = "none";
updateStatLine();
updateShopScreen();
}
                        `);
                        costElem.innerHTML = "Cost: $"+relicCost;
                        
                        nameWrapper.appendChild(nameElem);
                        relicElem.appendChild(nameWrapper);
                        relicElem.appendChild(costElem);
                        getId("merchantScreen").appendChild(relicElem);
                        let helpNumber = document.createElement("span");
                        helpNumber.style.position = "absolute";
                        helpNumber.setAttribute("class", "helpNumber");
                        let coords = relicElem.getBoundingClientRect();
                        helpNumber.style.top = coords.top;
                        helpNumber.style.left = coords.left - 10;
                        let ind = i + 7;
                        helpNumber.innerHTML = (ind > 10 ? "" : (ind == 10 ? "0" : ind));
                        getId("merchantScreen").appendChild(helpNumber);
                    }
                    let continueElem = document.createElement("tr");
                    let continueWrapper = document.createElement("td");
                    let continueBtn = document.createElement("button");
                    continueBtn.innerHTML = "<span style='text-decoration:underline'>C</span>ontinue";
                    continueBtn.setAttribute("onclick", "showMap();");
                    continueWrapper.appendChild(continueBtn);
                    continueElem.appendChild(continueWrapper);
                    getId("merchantScreen").appendChild(continueElem);
                }
            }
            let offers = [];
            function updateShopScreen() {
                let helpers = document.getElementsByClassName("helpNumber");
                while(helpers.length > 0) {
                    helpers[0].parentNode.removeChild(helpers[0]);
                }
                for(let i of offers) {
                    if(i.index >= 100) {
                        let relicElem = getId("relicName_"+(i.index-100));
                        if(gold >= i.price) {
                            relicElem.setAttribute("class", "Status tt");
                        } else {
                            relicElem.setAttribute("class", "unplayable tt");
                        }
                        let helpNumber = document.createElement("span");
                        helpNumber.style.position = "absolute";
                        helpNumber.setAttribute("class", "helpNumber");
                        let coords = relicElem.getBoundingClientRect();
                        helpNumber.style.top = coords.top;
                        helpNumber.style.left = coords.left - 10;
                        let ind = offers.indexOf(i) + 1;
                        helpNumber.innerHTML = (ind > 10 ? "" : (ind == 10 ? "0" : ind));
                        getId("merchantScreen").appendChild(helpNumber);
                    } else {
                        let cardElem = getId("cardName_"+i.index);
                        if(gold >= i.price) {
                            if(i.index==0) {
                                cardElem.setAttribute("class", "Skill tt");
                            } else {
                                cardElem.setAttribute("class", "tt");
                            }
                        } else {
                            cardElem.setAttribute("class", "tt unplayable");
                        }
                        let helpNumber = document.createElement("span");
                        helpNumber.style.position = "absolute";
                        helpNumber.setAttribute("class", "helpNumber");
                        let coords = cardElem.getBoundingClientRect();
                        helpNumber.style.top = coords.top;
                        helpNumber.style.left = coords.left - 10;
                        let ind = offers.indexOf(i) + 1;
                        helpNumber.innerHTML = (ind > 10 ? "" : (ind == 10 ? "0" : ind));
                        getId("merchantScreen").appendChild(helpNumber);
                    }
                }
            }
            
            //
            // Basics
            //
            let strike = () => new Card("Strike", 1, "Attack", "Deal [DAM6] damage.", function(enemy){
                dealDamage(enemy, 6);
            });
            let defend = () => new Card("Defend", 1, "Skill", "Gain [BLK5] Block.", async function(enemy){
                await gainBuff("Block", 5);
            });
            let bash = () => new Card("Bash", 2, "Attack", "Deal [DAM8] damage, apply 2 Vulnerable.", async function(enemy){
                dealDamage(enemy, 8); await enemy.gainBuff("Vulnerable", 2);
            });
            
            //
            // Commons
            //
            let bodySlam = () => new Card("Body Slam", 1, "Attack", "Deal damage equal to your Block. ([BLOCK] damage)", function(enemy){
                dealDamage(enemy, hasBuff("Block"));
            });
            let clash = () => new Card("Clash", 0, "Attack","Deal [DAM14] damage if all cards in your hand are Attacks.", function(enemy){
                if(!hand.map(x=>x.type=="Attack").includes(false)) {dealDamage(enemy, 14);} else {alert("Failed to play Clash: There are non-Attack cards in your hand.");}
            });
            let cleave = () => new Card("Cleave", 1, "Attack", "Deal [DAM8] damage to ALL enemies.", function(enemy){
                for(let e of enemies){dealDamage(e, 8);}
            });
            let clothesline = () => new Card("Clothesline", 2, "Attack", "Deal [DAM12] damage, apply 2 Weak.", async function(enemy){
                dealDamage(enemy, 12); await enemy.gainBuff("Weak", 2);
            });
            let flex = () => new Card("Flex", 0, "Skill", "Gain 2 Strength. At the end of your turn, lose 2 Strength.", async function(enemy){
                await gainBuff("Strength", 2); await gainBuff("Strength Down", 2);
            });
            let headbutt = () => new Card("Headbutt", 1, "Attack", "Deal [DAM9] damage. Put a card from your discard pile on top of your draw pile.", async function(enemy){
                dealDamage(enemy, 9);
                let chosen = await choose(discardPile, "Choose a card to put on top of your Draw Pile.");
                if(chosen) {
                    drawPile.push(chosen);
                    discardPile.splice(discardPile.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let heavyBlade = () => new Card("Heavy Blade", 2, "Attack", "Deal [HEAVYBLADE] damage. Strength affects the damage 3 times.", function(enemy){
                dealDamage(enemy, 14 + 2 * hasBuff("Strength"));
            });
            let ironWave = () => new Card("Iron Wave", 1, "Attack", "Gain [BLK5] Block. Deal [DAM5] damage.", async function(enemy){
                dealDamage(enemy, 5); await gainBuff("Block", 5);
            });
            let pommelStrike = () => new Card("Pommel Strike", 1, "Attack", "Deal [DAM9] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 9); drawCard();
            });
            let shrugItOff = () => new Card("Shrug it Off", 1, "Skill", "Gain [BLK8] Block. Draw a card.", async function(enemy){
                drawCard(); await gainBuff("Block", 8);
            });
            let swordBoomerang = () => new Card("Sword Boomerang", 1, "Attack", "Deal [DAM3] damage to a random enemy 3 times.", function(enemy){
                let boom = () => dealDamage(choice(enemies), 3);
                boom(); boom(); boom();
            });
            let thunderclap = () => new Card("Thunderclap", 1, "Attack", "Deal [DAM4] damage and apply 1 Vulnerable to ALL enemies.", async function(enemy){
                for(let e of enemies){dealDamage(e, 4); await e.gainBuff("Vulnerable", 1);}
            });
            let trueGrit = () => new Card("True Grit", 1, "Skill", "Gain [BLK7] Block. Exhaust a random card in your hand.", async function(enemy){
               await gainBuff("Block", 7); let c=choice(hand); hand.splice(hand.indexOf(c), 1); exhaustPile.push(c);
            });
            let twinStrike = () => new Card("Twin Strike", 1, "Attack", "Deal [DAM5] damage twice.", function(enemy){
                dealDamage(enemy, 5); dealDamage(enemy, 5);
            });
            let wildStrike = () => new Card("Wild Strike", 1, "Attack", "Deal [DAM12] damage. Shuffle a Wound into your discard pile.", function(enemy){
                dealDamage(enemy, 12); discardPile.push(statusCards["Wound"]());
            });
            
            //
            // Uncommons
            //
            let battleTrance = () => new Card("Battle Trance", 0, "Skill", "Draw 3 cards. You cannot draw additional cards this turn.", async function(enemy){
                drawCard(3); await gainBuff("No Draw", 1);
            });
            let bloodForBlood = () => new Card("Blood for Blood", 4, "Attack", "Deal [DAM18] damage. -1 cost each time you lose HP. (Costs [BLOOD4BLOOD] energy)", function(enemy){
                dealDamage(enemy, 18);
            }, ["blood4blood"]);
            let bloodletting = () => new Card("Bloodletting", 0, "Skill", "Lose 3 HP. Gain 2 energy.", function(enemy){
                hp -= 3; energy += 2;
            });
            let burningPact = () => new Card("Burning Pact", 1, "Skill", "Exhaust 1 card. Draw 2 cards.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name != "Burning Pact"), "Choose a card to Exhaust.");
                if(chosen) {
                    hand.splice(hand.indexOf(chosen), 1);
                    exhaustPile.push(chosen);
                    drawCard(2);
                } else {
                    alert("Failed to play Burning Pact: No remaining cards in hand.");
                }
                updateHtml();
            });
            let carnage = () => new Card("Carnage", 2, "Attack", "Ethereal. Deal [DAM20] damage.", function(enemy){
                dealDamage(enemy, 20);
            }, ["ethereal"]);
            let combust = () => new Card("Combust", 1, "Power", "At the end of your turn, lose 1 HP and deal [DAM5] damage to ALL enemies.", async function(enemy){
                await gainBuff("Combust", 5);
            }, ["exhausted"]);
            let darkEmbrace = () => new Card("Dark Embrace", 2, "Power", "Whenever a card is Exhausted, draw a card.", async function(enemy){
                await gainBuff("Dark Embrace", 1);
            }, ["exhausted"]);
            let disarm = () => new Card("Disarm", 1, "Skill", "Enemy gets -2 Strength. Exhaust.", async function(enemy){
                await enemy.gainBuff("Minus Strength", 2);
            }, ["exhausted"]);
            let dropkick = () => new Card("Dropkick", 1, "Attack", "Deal [DAM5] damage. If the enemy has Vulnerable, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 5);
                if(enemy.hasBuff("Vulnerable") > 0) {
                    energy++;
                    drawCard();
                }
            });
            let dualWield = () => new Card("Dual Wield", 1, "Skill", "Copy an Attack or Power card in your hand.", async function(enemy){
                let chosen = await choose(hand.filter(x=>["Attack","Power"].includes(x.type)), "Choose a card to copy.");
                if(chosen) {
                    hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                    updateHtml();
                } else {
                    alert("Failed to play Dual Wield: No Attack or Power cards in hand.");
                }
            });
            let entrench = () => new Card("Entrench", 2, "Skill", "Double your Block.", async function(enemy){
                if(hasBuff("Block")>0) {await gainBuff("Block", hasBuff("Block"));}
            });
            let evolve = () => new Card("Evolve", 1, "Power", "Whenever you draw a Status card, draw another card.", async function(enemy){
                await gainBuff("Evolve", 1);
            }, ["exhausted"]);
            let feelNoPain = () => new Card("Feel No Pain", 1, "Power", "When a card is Exhausted, gain [BLK3] Block.",async  function(enemy){
                await gainBuff("Feel No Pain", 3);
            }, ["exhausted"]);
            let fireBreathing = () => new Card("Fire Breathing", 1, "Power", "Whenever you draw a Status card, deal 6 damage to ALL enemies", async function(enemy){
                await gainBuff("Fire Breathing", 6);
            }, ["exhausted"]);
            let flameBarrier = () => new Card("Flame Barrier", 2, "Skill", "Gain [BLK12] Block and 2 Thorns.", async function(enemy){
                await gainBuff("Block", 12); await gainBuff("Thorns", 2);
            });
            let ghostlyArmor = () => new Card("Ghostly Armor", 1, "Skill", "Ethereal. Gain [BLK10] Block.", async function(enemy){
                await gainBuff("Block", 10);
            }, ["ethereal"]);
            let hemokinesis = () => new Card("Hemokinesis", 1, "Attack", "Lose 2 HP. Deal [DAM15] damage.", function(enemy){
                hp -= 2; dealDamage(enemy, 15);
            });
            let infernalBlade = () => new Card("Infernal Blade", 0, "Skill", "Add a random Attack to your hand. Exhaust.", function(enemy){
                let extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Attack") {extraCard = randCard()();}
                hand.push(extraCard);
            }, ["exhausted"]);
            let inflame = () => new Card("Enflame", 1, "Power", "Gain 2 Strength.", async function(enemy){
                await gainBuff("Strength", 2);
            }, ["exhausted"]);
            let intimidate = () => new Card("Intimidate", 0, "Skill", "Apply 1 Weak to ALL enemies. Exhaust.", async function(enemy){
                for(let e of enemies) {await e.gainBuff("Weak", 1);}
            }, ["exhausted"]);
            let metallicize = () => new Card("Metallicize", 1, "Power", "Start each turn with [BLK3] Block.", async function(enemy){
                await gainBuff("Metallicize", 3);
            }, ["exhausted"]);
            let powerThrough = () => new Card("Power Through", 1, "Skill","Add 2 Wounds to your hand. Gain [BLK15] Block.", async function(enemy){
                hand.push(statusCards["Wound"]()); hand.push(statusCards["Wound"]()); await gainBuff("Block", 15);
            });
            let pummel = () => new Card("Pummel", 2, "Attack", "Deal [DAM2] damage 6 times.", function(enemy){
                dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);
            });
            let rage = () => new Card("Rage", 0, "Skill", "For each Attack you play this turn, gain [BLK3] Block.", async function(enemy){
                await gainBuff("Rage", 3);
            });
            let rampage = () => new Card("Rampage", 1, "Attack", "Deal [RAMPAGE] damage. This card deals 5 more damage this combat.", async function(enemy){
                dealDamage(enemy, 8 + hasBuff("Rampage")); await gainBuff("Rampage", 5);
            });
            let recklessCharge = () => new Card("Reckless Charge",0,"Attack","Deal [DAM7] damage. Get a Dazed card.",function(enemy){
                dealDamage(enemy, 7); discardPile.push(statusCards["Dazed"]());
            });
            let secondWind = () => new Card("Second Wind", 1, "Skill", "Exhaust all non-Attack cards in your hand. Gain [BLK5] Block for each card Exhausted.", async function(enemy){
                for(let card of hand) {
                    if(card.type != "Attack") {
                        exhaustPile.push(card);
                        hand.splice(hand.indexOf(card), 1);
                        await gainBuff("Block", 5);
                    }
                }
            });
            let seeingRed = () => new Card("Seeing Red", 0, "Skill", "Gain 1 energy. Exhaust.", function(enemy){
                energy += 1;
            }, ["exhausted"]);
            let severSoul = () => new Card("Sever Soul", 2, "Attack", "Exhaust all non-Attack cards in your hand. Deal [DAM16] damage.", function(enemy){
                for(let card of hand) {
                    if(card.type != "Attack") {
                        exhaustPile.push(card);
                        hand.splice(hand.indexOf(card), 1);
                    }
                }
                dealDamage(enemy, 16);
            });
            let spotWeakness = () => new Card("Spot Weakness", 1, "Skill", "If the enemy intends to attack, gain 3 Strength.", async function(enemy){
                if(enemy.intent.intent.includes("attack")) {
                    await gainBuff("Strength", 3);
                } else {
                    alert("Failed to play Spot Weakness: That enemy does not intend to attack.");
                }
            });
            let uppercut = () => new Card("Uppercut", 2, "Attack", "Deal [DAM13] damage. Apply 1 Weak and Vulnerable.", async function(enemy){
                dealDamage(enemy, 13); await enemy.gainBuff("Weak", 1); await enemy.gainBuff("Vulnerable", 1);
            });
            let whirlwind = () => new Card("Whirlwind", "X", "Attack", "Deal [DAM5] damage to ALL enemies X times.", function(enemy){
                for(let e of enemies){dealDamage(e, 5);}
            });
            
            //
            // Rares
            //
            let barricade = () => new Card("Barricade", 3, "Power", "Block is not removed at the start of your turn.", async function(enemy){
                await gainBuff("Barricade", 1);
            }, ["exhausted"]);
            let berserk = () => new Card("Berserk", 0, "Power", "Gain 2 Vulnerable, but gain 1 more energy each turn.", async function(enemy){
                await gainBuff("Vulnerable", 2); await gainBuff("Berserk", 1);
            }, ["exhausted"]);
            let bludgeon = () => new Card("Bludgeon", 3, "Attack", "Deal [DAM32] damage.", function(enemy){
                dealDamage(enemy, 32);
            });
            let brutality = () => new Card("Brutality", 0, "Power", "At the start of your turn, lose 1 HP and draw 1 more card.", async function(enemy){
                await gainBuff("Brutality", 1);
            }, ["exhausted"]);
            let demonForm = () => new Card("Demonic Ritual", 3, "Power", "At the end of your turn, gain 2 Strength.", async function(enemy){
                await gainBuff("Ritual", 2);
            }, ["exhausted"]);
            let doubleTap = () => new Card("Double Tap", 1, "Skill", "Your next Attack is played twice.", async function(enemy){
                await gainBuff("Double Tap", 1);
            }, ["exhausted"]);
            let exhume = () => new Card("Exhume", 1, "Skill", "Put a card from your exhaust pile in your hand. Exhaust.", async function(enemy){
                let chosen = await choose(exhaustPile, "Choose a card to put into your hand.");
                if(chosen) {
                    hand.push(chosen);
                    exhaustPile.splice(exhaustPile.indexOf(chosen), 1);
                    updateHtml();
                } else {
                    alert("Failed to play Exhume: Exhaust pile is empty.");
                }
            }, ["exhausted"]);
            let feed = () => new Card("Feed", 1, "Attack", "Enemy loses 10 HP. If they die from it, gain 3 Max HP. Exhaust.", function(enemy){
                if(enemy.hp <= 10) {maxHp += 3; hp += 3;}
                enemy.hp -= 10;
            }, ["exhausted"]);
            let impervious = () => new Card("Impervious", 2, "Skill", "Gain [BLK30] block. Exhaust.", async function(enemy){
                await gainBuff("Block", 30);
            }, ["exhausted"]);
            let juggernaut = () => new Card("Juggernaut", 2, "Power", "Whenever you gain Block, deal [DAM5] damage to a random enemy.", async function(enemy){
                await gainBuff("Juggernaut", 5);
            }, ["exhausted"]);
            let limitBreak = () => new Card("Limit Break", 1, "Skill", "Double your Strength. Exhaust.", async function(enemy){
                if(hasBuff("Strength")>0) {await gainBuff("Strength", hasBuff("Strength"));}
            }, ["exhausted"]);
            let offering = () => new Card("Offering", 0, "Skill", "Lose 6 HP. Gain 2 energy. Draw 3 cards. Exhaust.", function(enemy){
                hp -= 6; energy += 2; drawCard(3);
            }, ["exhausted"]);
            let reaper = () => new Card("Reaper", 2, "Attack", "Deal [DAM8] damage. Heal 8 HP. Exhaust.", function(enemy){
                dealDamage(enemy, 8); hp = Math.min(maxHp, hp + 8);
            }, ["exhausted"]);
            
            //
            // Silent Commons
            //
            let acrobatics = () => new Card("Acrobatics", 1, "Skill", "Draw 3 cards. Discard 1 card.", async function(enemy){
                drawCard(3);
                let chosen = await choose(hand.filter(x=>x.name!="Acrobatics"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let backflip = () => new Card("Backflip", 1, "Skill", "Gain [BLK5] Block. Draw 2 cards.", async function(enemy){
                drawCard(2); await gainBuff("Block", 5);
            });
            let bane = () => new Card("Bane", 1, "Attack", "Deal [DAM7] damage, twice if enemy has Poison.", function(enemy){
                dealDamage(enemy, 7); if(enemy.hasBuff("Poison")) {dealDamage(enemy, 7);}
            });
            let bladeDance = () => new Card("Blade Dance", 1, "Skill", "Add 3 Shivs to your hand.", function(enemy){
                addShivs(3);
            });
            let cloakAndDagger = () => new Card("Cloak and Dagger", 1, "Skill", "Gain [BLK6] Block. Add a Shiv to your hand.", async function(enemy){
                addShivs(1); await gainBuff("Block", 6);
            });
            let daggerSpray = () => new Card("Dagger Spray", 1, "Attack", "Deal [DAM4] damage to ALL enemies twice.", function(enemy){
                for(let e of enemies){dealDamage(e, 4);dealDamage(e, 4);}
            });
            let daggerThrow = () => new Card("Dagger Throw", 1, "Attack", "Deal [DAM9] damage. Draw a card. Discard a card.", async function(enemy){
                dealDamage(enemy, 9); drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Dagger Throw"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let deadlyPoison = () => new Card("Deadly Poison", 1, "Skill", "Apply 5 Poison.", async function(enemy){
                await enemy.gainBuff("Poison", 5);
            });
            let deflect = () => new Card("Deflect", 0, "Skill", "Gain [BLK4] Block.", async function(enemy){
                await gainBuff("Block", 4);
            });
            let dodgeAndRoll = () => new Card("Dodge and Roll", 1, "Skill", "Gain [BLK3] Block. Next turn, gain [BLK6] Block.", async function(enemy){
                await gainBuff("Block", 3); await gainBuff("Next Turn Block", 6);
            });
            let flyingKnee = () => new Card("Flying Knee", 1, "Attack", "Deal [DAM8] damage. Gain 1 more energy next turn.", async function(enemy){
                dealDamage(enemy, 8); await gainBuff("Next Turn Energy", 1);
            });
            let outmaneuver = () => new Card("Outmaneuver", 1, "Skill", "Gain 2 more energy next turn.", async function(enemy){
                await gainBuff("Next Turn Energy", 2);
            });
            let poisonedStab = () => new Card("Poisoned Stab", 1, "Attack", "Deal [DAM6] damage. Apply 3 Poison.", async function(enemy){
                dealDamage(enemy, 6); await enemy.gainBuff("Poison", 3);
            });
            let prepared = () => new Card("Prepared", 0, "Skill", "Draw a card. Discard a card.", async function(enemy){
                drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let quickSlash = () => new Card("Quick Slash", 1, "Attack", "Deal [DAM8] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 8); drawCard();
            });
            let slice = () => new Card("Slice", 0, "Attack", "Deal [DAM6] damage.", function(enemy){
                dealDamage(enemy, 6);
            });
            let suckerPunch = () => new Card("Sucker Punch", 1, "Attack", "Deal [DAM7] damage. Apply 1 Weak.", async function(enemy){
                dealDamage(enemy, 7); await enemy.gainBuff("Weak", 1);
            });
            
            //
            // Silent Uncommons
            //
            let accuracy = () => new Card("Accuracy", 1, "Power", "Shivs deal 4 more damage.", async function(enemy){
                await gainBuff("Accuracy", 4);
            }, ["exhausted"]);
            let allOutAttack = () => new Card("All-Out Attack", 1, "Attack", "Deal [DAM10] damage to ALL enemies. Discard a random card.", function(enemy){
                for(let e of enemies) {dealDamage(e,10);}
                let chosen = choice(hand);
                discardPile.push(chosen);
                hand.splice(hand.indexOf(chosen), 1);
            });
            let backstab = () => new Card("Backstab", 0, "Attack", "Innate. Deal [DAM11] damage. Exhaust.", function(enemy){
                dealDamage(enemy, 11);
            }, ["exhausted", "innate"]);
            let blur = () => new Card("Blur", 1, "Skill", "Gain [BLK5] Block. Block is not removed next turn.", async function(enemy){
                await gainBuff("Blur", 1); await gainBuff("Block", 5);
            });
            let bouncingFlask = () => new Card("Bouncing Flask", 2, "Skill", "Apply 9 Poison to a random enemy.", async function(enemy){
                await choice(enemies).gainBuff("Poison", 9);
            });
            let caltrops = () => new Card("Caltrops", 1, "Skill", "Gain 3 Thorns. Exhaust.", async function(enemy){
                await gainBuff("Thorns", 3);
            }, ["exhausted"]);
            let catalyst = () => new Card("Catalyst", 1, "Skill", "Double the enemy's Poison. Exhaust.", async function(enemy){
                await enemy.gainBuff("Poison", enemy.hasBuff("Poison"));
            }, ["exhausted"]);
            let concentrate = () => new Card("Concentrate", 0, "Skill", "Discard 3 cards. Gain 2 energy.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
                let chosen3 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a third card to discard.");
                if(chosen3) {
                    discardPile.push(chosen3);
                    hand.splice(hand.indexOf(chosen3), 1);
                    updateHtml();
                }
                energy += 2;
            });
            let cripplingCloud = () => new Card("Crippling Cloud", 2, "Skill", "Apply 4 Poison and 2 Weak to ALL enemies. Exhaust.", async function(enemy){
                for(let e of enemies) {await e.gainBuff("Poison", 4); await e.gainBuff("Weak", 2);}
            }, ["exhausted"]);
            let dash = () => new Card("Dash", 2, "Attack", "Deal [DAM10] damage. Gain [BLK10] Block.", async function(enemy){
                dealDamage(enemy, 10); await gainBuff("Block", 10);
            });
            let distraction = () => new Card("Distraction", 0, "Skill", "Add a random Skill to your hand. Exhaust.", function(enemy){
                let extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Skill") {extraCard = randCard()();}
                hand.push(extraCard);
            }, ["exhausted"]);
            let escapePlan = () => new Card("Escape Plan", 0, "Skill", "Draw a card. If it's a Skill, gain [BLK3] Block.", async function(enemy){
                drawCard();
                if(hand[hand.length - 1].type == "Skill") {await gainBuff("Block", 3);}
            });
            let expertise = () => new Card("Expertise", 1, "Skill", "Draw cards until you have 6 in hand.", function(enemy){
                if(hand.length < 6) {drawCard(6 - hand.length);}
            });
            let finisher = () => new Card("Finisher", 1, "Attack", "Deal 6 damage for each Attack played this turn. (Deals [FINISHER] damage)", function(enemy){
                dealDamage(enemy, stats.attacksThisTurn * 6);
            });
            let footwork = () => new Card("Footwork", 1, "Power", "Gain 2 Dexterity.", async function(enemy){
                await gainBuff("Dexterity", 2);
            }, ["exhausted"]);
            let heelHook = () => new Card("Heel Hook", 1, "Attack", "Deal [DAM5] damage. If the enemy has Weak, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 5);
                if(enemy.hasBuff("Weak") > 0) {energy += 1; drawCard();}
            });
            let infiniteBlades = () => new Card("Infinite Blades", 1, "Power", "At the start of your turn, add a Shiv into your hand.", async function(enemy){
                await gainBuff("Infinite Blades", 1);
            }, ["exhausted"]);
            let legSweep = () => new Card("Leg Sweep", 2, "Skill", "Apply 2 Weak. Gain [BLK11] Block.", async function(enemy){
                await gainBuff("Block", 11); await enemy.gainBuff("Weak", 2);
            });
            let noxiousFumes = () => new Card("Noxious Fumes", 1, "Power", "At the start of your turn, apply 2 Poison to ALL enemies.", async function(enemy){
                await gainBuff("Noxious Fumes", 2);
            }, ["exhausted"]);
            let predator = () => new Card("Predator", 2, "Attack", "Deal [DAM15] damage. Next turn, draw 2 more cards.", async function(enemy){
                dealDamage(enemy, 15); await gainBuff("Next Turn Cards", 2);
            });
            let skewer = () => new Card("Skewer", "X", "Attack", "Deal [DAM7] damage X times.", function(enemy){
                dealDamage(enemy, 7);
            });
            let terror = () => new Card("Terror", 1, "Skill", "Apply 999 Vulnerable. Exhaust.", async function(enemy){
                await enemy.gainBuff("Vulnerable", 999);
            }, ["exhausted"]);
            
            //
            // Silent Rares
            //
            let thousandCuts = () => new Card("A Thousand Cuts", 2, "Power", "Whenever you play a card, deal [DAM1] damage to ALL enemies.", async function(enemy) {
                await gainBuff("Thousand Cuts", 1);
            }, ["exhausted"]);
            let adrenaline = () => new Card("Adrenaline", 0, "Skill", "Gain 1 energy. Draw 2 cards. Exhaust.", function(enemy){
                energy += 1; drawCard(2);
            }, ["exhausted"]);
            let afterImage = () => new Card("After Image", 1, "Power", "Whenever you play a card, gain [BLK1] Block.", async function(enemy){
                await gainBuff("After Image", 1);
            }, ["exhausted"]);
            let burst = () => new Card("Burst", 1, "Skill", "Your next Skill is played twice.", async function(enemy){
                await gainBuff("Burst", 1);
            });
            let dieDieDie = () => new Card("Die Die Die", 1, "Attack", "Deal [DAM13] damage to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {dealDamage(e, 13);}
            }, ["exhausted"]);
            let doppelganger = () => new Card("Doppelganger", "X", "Skill", "Next turn, draw X more cards and gain X more energy. Exhaust.", async function(enemy){
                await gainBuff("Next Turn Cards", 1); await gainBuff("Next Turn Energy", 1);
            }, ["exhausted"]);
            let envenom = () => new Card("Envenom", 2, "Power", "Whenever you deal unblocked damage, apply 1 Poison.", async function(enemy){
                await gainBuff("Envenom", 1);
            }, ["exhausted"]);
            let grandFinale = () => new Card("Grand Finale", 0, "Attack", "If there are no cards in your draw pile, deal [DAM50] damage to ALL enemies.", function(enemy) {
                if(drawPile.length == 0) {for(let e of enemies){dealDamage(e, 50);}} else {alert("Failed to play Grand Finale: There are cards in your draw pile.");}
            });
            let stormOfSteel = () => new Card("Storm of Steel", 1, "Skill", "Replace your hand with Shivs.", function(enemy){
                let handSize = hand.length;
                for(let i of hand) {discardPile.push(i);}
                addShivs(handSize);
            });
            let toolsOfTheTrade = () => new Card("Tools of the Trade", 1, "Power", "At the start of your turn, draw a card and discard a card.", async function(enemy){
                await gainBuff("Tools of the Trade", 1);
            }, ["exhausted"]);
            
            //
            // Upgraded Cards
            //
            let upgradedCards = {
                "Strike": () => new Card("Strike+", 1, "Attack", "Deal [DAM9] damage.", function(enemy){
                    dealDamage(enemy, 9);
                }), "Defend": () => new Card("Defend+", 1, "Skill", "Gain [BLK8] Block.", async function(enemy){
                    await gainBuff("Block", 8);
                }), "Bash": () => new Card("Bash+", 2, "Attack", "Deal [DAM10] damage, apply 3 Vulnerable.", async function(enemy){
                    dealDamage(enemy, 10); await enemy.gainBuff("Vulnerable", 3);
                }), "Body Slam": () => new Card("Body Slam+", 0, "Attack", "Deal damage equal to your Block. ([BLOCK] damage)", function(enemy){
                    dealDamage(enemy, hasBuff("Block"));
                }), "Clash": () => new Card("Clash+", 0, "Attack","Deal [DAM18] damage if all cards in your hand are Attacks.", function(enemy){
                    if(!hand.map(x=>x.type=="Attack").includes(false)) {dealDamage(enemy, 18);}
                }), "Cleave": () => new Card("Cleave+", 1, "Attack", "Deal [DAM11] damage to ALL enemies.", function(enemy){
                    for(let e of enemies){dealDamage(e, 11);}
                }), "Clothesline": () => new Card("Clothesline+", 2, "Attack", "Deal [DAM14] damage, apply 3 Weak.", async function(enemy){
                    dealDamage(enemy, 14); await enemy.gainBuff("Weak", 3);
                }), "Flex": () => new Card("Flex+", 0, "Skill", "Gain 4 Strength. At the end of your turn, lose 4 Strength.", async function(enemy){
                    await gainBuff("Strength", 4); await gainBuff("Strength Down", 4);
                }), "Headbutt": () => new Card("Headbutt", 1, "Attack", "Deal [DAM12] damage. Put a card from your discard pile on top of your draw pile.", async function(enemy){
                    dealDamage(enemy, 12);
                    let chosen = await choose(discardPile, "Choose a card to put on top of your Draw Pile.");
                    if(chosen) {
                        drawPile = [chosen, ...drawPile];
                        discardPile.splice(discardPile.indexOf(chosen), 1);
                        updateHtml();
                    }
                }), "Heavy Blade": () => new Card("Heavy Blade+", 2, "Attack", "Deal [HEAVYBLADE+] damage. Strength affects the damage 5 times.", function(enemy){
                    dealDamage(enemy, 14 + 4 * hasBuff("Strength"));
                }), "Iron Wave": () => new Card("Iron Wave+", 1, "Attack", "Gain [BLK7] Block. Deal [DAM7] damage.", async function(enemy){
                    dealDamage(enemy, 7); await gainBuff("Block", 7);
                }), "Pommel Strike": () => new Card("Pommel Strike+", 1, "Attack", "Deal [DAM10] damage. Draw 2 cards.", function(enemy){
                    dealDamage(enemy, 10); drawCard(2);
                }), "Shrug it Off": () => new Card("Shrug it Off+", 1, "Skill", "Gain [BLK11] Block. Draw a card.", async function(enemy){
                    drawCard(); await gainBuff("Block", 11);
                }), "Sword Boomerang": () => new Card("Sword Boomerang+", 1, "Attack", "Deal [DAM3] damage to a random enemy 4 times.", function(enemy){
                    dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3);
                }), "Thunderclap": () => new Card("Thunderclap+", 1, "Attack", "Deal [DAM7] damage and apply 1 Vulnerable to ALL enemies.", async function(enemy){
                    for(let e of enemies){dealDamage(e, 7); await e.gainBuff("Vulnerable", 1);}
                }), "True Grit": () => new Card("True Grit+", 1, "Skill", "Gain [BLK7] Block. Exhaust a card in your hand.", async function(enemy){
                    await gainBuff("Block", 7);
                    let chosen = await choose(hand, "Choose a card to Exhaust.");
                    if(chosen) {
                        hand.splice(hand.indexOf(chosen), 1);
                        exhaustPile.push(chosen);
                        updateHtml();
                    }
                }), "Twin Strike": () => new Card("Twin Strike+", 1, "Attack", "Deal [DAM7] damage twice.", function(enemy){
                    dealDamage(enemy, 7); dealDamage(enemy, 7);
                }), "Wild Strike": () => new Card("Wild Strike+", 1, "Attack", "Deal [DAM17] damage. Shuffle a Wound into your discard pile.", function(enemy){
                    dealDamage(enemy, 17); discardPile.push(statusCards["Wound"]());
                }), "Battle Trance": () => new Card("Battle Trance+", 0, "Skill", "Draw 4 cards. You cannot draw additional cards this turn.", async function(enemy){
                    drawCard(4); await gainBuff("No Draw", 1);
                }), "Blood for Blood": () => new Card("Blood for Blood+", 4, "Attack", "Deal [DAM26] damage. -1 cost each time you lose HP. (Costs [BLOOD4BLOOD] energy)", function(enemy){
                    dealDamage(enemy, 26);
                }, ["blood4blood"]), "Bloodletting": () => new Card("Bloodletting+", 0, "Skill", "Lose 3 HP. Gain 3 energy.", function(enemy){
                    hp -= 3; energy += 3;
                }), "Burning Pact": () => new Card("Burning Pact+", 1, "Skill", "Exhaust 1 card. Draw 3 cards.", async function(enemy){
                    let chosen = await choose(hand, "Choose a card to Exhaust.");
                    if(chosen) {
                        hand.splice(hand.indexOf(chosen), 1);
                        exhaustPile.push(chosen);
                        drawCard(3);
                        updateHtml();
                    } else {
                        alert("Failed to play Burning Pact: No remaining cards in hand.");
                    }
                }), "Carnage": () => new Card("Carnage+", 2, "Attack", "Ethereal. Deal [DAM28] damage.", function(enemy){
                    dealDamage(enemy, 28);
                }, ["ethereal"]), "Combust": () => new Card("Combust+", 1, "Power", "At the end of your turn, lose 1 HP and deal [DAM7] damage to ALL enemies.", async function(enemy){
                    await gainBuff("Combust", 7);
                }, ["exhausted"]), "Dark Embrace+": () => new Card("Dark Embrace+", 1, "Power", "Whenever a card is Exhausted, draw a card.", async function(enemy){
                    await gainBuff("Dark Embrace", 1);
                }, ["exhausted"]), "Disarm": () => new Card("Disarm+", 1, "Skill", "Enemy gets -3 Strength. Exhaust.", async function(enemy){
                    await enemy.gainBuff("Minus Strength", 3);
                }, ["exhausted"]), "Dropkick": () => new Card("Dropkick+", 1, "Attack", "Deal [DAM8] damage. If the enemy has Vulnerable, gain 1 energy and draw a card.", function(enemy){
                    dealDamage(enemy, 8);
                    if(enemy.hasBuff("Vulnerable") > 0) {
                        energy++;
                        drawCard();
                    }
                }), "Dual Wield": () => new Card("Dual Wield+", 1, "Skill", "Create 2 copies of an Attack or Power card in your hand.", async function(enemy){
                    let chosen = await choose(hand.filter(x=>["Attack","Power"].includes(x.type)), "Choose a card to copy.");
                    if(chosen) {
                        hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                        hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                        updateHtml();
                    } else {
                        alert("Failed to play Dual Wield: No Attack or Power cards in hand.");
                    }
                }), "Entrench": () => new Card("Entrench+", 1, "Skill", "Double your Block.", async function(enemy){
                    if(hasBuff("Block")>0) {await gainBuff("Block", hasBuff("Block"));}
                }), "Evolve": () => new Card("Evolve+", 1, "Power", "Whenever you draw a Status card, draw 2 more cards.", async function(enemy){
                    await gainBuff("Evolve", 2);
                }, ["exhausted"]), "Feel No Pain": () => new Card("Feel No Pain+", 1, "Power", "When a card is Exhausted, gain [BLK4] Block.", async function(enemy){
                    await gainBuff("Feel No Pain", 4);
                }, ["exhausted"]), "Fire Breathing": () => new Card("Fire Breathing+", 1, "Power", "Whenever you draw a Status card, deal 10 damage to ALL enemies", async function(enemy){
                    await gainBuff("Fire Breathing", 10);
                }, ["exhausted"]), "Flame Barrier": () => new Card("Flame Barrier+", 2, "Skill", "Gain [BLK16] Block and 3 Thorns.", async function(enemy){
                    await gainBuff("Block", 16); await gainBuff("Thorns", 3);
                }), "Ghostly Armor": () => new Card("Ghostly Armor+", 1, "Skill", "Ethereal. Gain [BLK13] Block.", async function(enemy){
                    await gainBuff("Block", 13);
                }, ["ethereal"]), "Hemokinesis": () => new Card("Hemokinesis+", 1, "Attack", "Lose 2 HP. Deal [DAM20] damage.", function(enemy){
                    hp -= 2; dealDamage(enemy, 20);
                }), "Infernal Blade": () => new Card("Infernal Blade+", 0, "Skill", "Add 2 random Attacks to your hand. Exhaust", function(enemy){
                    let extraCard = randCard()(); // looks weird ik
                    while(extraCard.type != "Attack") {extraCard = randCard()();}
                    hand.push(extraCard);
                    let extraCard2 = randCard()(); // looks weird ik
                    while(extraCard2.type != "Attack") {extraCard2 = randCard()();}
                    hand.push(extraCard2);
                }, ["exhausted"]), "Enflame": () => new Card("Enflame+", 1, "Power", "Gain 3 Strength.", async function(enemy){
                    await gainBuff("Strength", 3);
                }, ["exhausted"]), "Intimidate": () => new Card("Intimidate+", 0, "Skill", "Apply 2 Weak to ALL enemies. Exhaust.", async function(enemy){
                    for(let e of enemies) {await e.gainBuff("Weak", 2);}
                }, ["exhausted"]), "Metallicize": () => new Card("Metallicize+", 1, "Power", "Start each turn with [BLK4] Block.", async function(enemy){
                    await gainBuff("Metallicize", 4);
                }, ["exhausted"]), "Power Through": () => new Card("Power Through+", 1, "Skill", "Add 2 Wounds to your hand. Gain [BLK20] Block.", async function(enemy){
                    hand.push(statusCards["Wound"]()); hand.push(statusCards["Wound"]()); await gainBuff("Block", 20);
                }), "Pummel": () => new Card("Pummel+", 2, "Attack", "Deal [DAM2] damage 8 times.", function(enemy){
                    dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2);
                }), "Rage": () => new Card("Rage+", 0, "Skill", "For each Attack you play this turn, gain [BLK5] Block.", async function(enemy){
                    await gainBuff("Rage", 5);
                }), "Rampage": () => new Card("Rampage+", 1, "Attack", "Deal [RAMPAGE] damage. This card deals 8 more damage this combat.", async function(enemy){
                    dealDamage(enemy, 8 + hasBuff("Rampage")); await gainBuff("Rampage", 8);
                }), "Reckless Charge": () => new Card("Reckless Charge+", 0, "Attack","Deal [DAM10] damage. Get a Dazed card.", function(enemy){
                    dealDamage(enemy, 10); discardPile.push(statusCards["Dazed"]());
                }), "Second Wind": () => new Card("Second Wind+", 1, "Skill", "Exhaust all non-Attack cards in your hand. Gain [BLK7] Block for each card Exhausted.", async function(enemy){
                    for(let card of hand) {
                        if(card.type != "Attack") {
                            exhaustPile.push(card);
                            hand.splice(hand.indexOf(card), 1);
                            await gainBuff("Block", 7);
                        }
                    }
                }), "Seeing Red": () => new Card("Seeing Red+", 0, "Skill", "Gain 2 energy. Exhaust.", function(enemy){
                    energy += 2;
                }, ["exhausted"]), "Sever Soul": () => new Card("Sever Soul+", 2, "Attack", "Exhaust all non-Attack cards in your hand. Deal [DAM22] damage.", function(enemy){
                    for(let card of hand) {
                        if(card.type != "Attack") {
                            exhaustPile.push(card);
                            hand.splice(hand.indexOf(card), 1);
                        }
                    }
                    dealDamage(enemy, 22);
                }), "Spot Weakness": () => new Card("Spot Weakness+", 1, "Skill", "If the enemy intends to attack, gain 4 Strength.", async function(enemy){
                    if(enemy.intent.intent.includes("attack")) {
                        await gainBuff("Strength", 4);
                    } else {
                        alert("That enemy does not intend to attack.");
                    }
                }), "Uppercut": () => new Card("Uppercut+", 2, "Attack", "Deal [DAM13] damage. Apply 2 Weak and Vulnerable.", async function(enemy){
                    dealDamage(enemy, 13); await enemy.gainBuff("Weak", 2); await enemy.gainBuff("Vulnerable", 2);
                }), "Whirlwind": () => new Card("Whirlwind+", "X", "Attack", "Deal [DAM8] damage to ALL enemies X times.", function(enemy){
                    for(let e of enemies){dealDamage(e, 8);}
                }), "Barricade": () => new Card("Barricade+", 2, "Power", "Block is not removed at the start of your turn.", async function(enemy){
                    await gainBuff("Barricade", 1);
                }, ["exhausted"]), "Berserk": () => new Card("Berserk+", 0, "Power", "Gain 1 Vulnerable, but gain 1 more energy each turn.", async function(enemy){
                    await gainBuff("Vulnerable", 1); await gainBuff("Berserk", 1);
                }, ["exhausted"]), "Bludgeon": () => new Card("Bludgeon+", 3, "Attack", "Deal [DAM42] damage.", function(enemy){
                    dealDamage(enemy, 42);
                }), "Brutality": new Card("Brutality+", 0, "Power", "Innate. At the start of your turn, lose 1 HP and draw 1 more card.", async function(enemy){
                    await gainBuff("Brutality", 1);
                }, ["exhausted", "innate"]), "Demonic Ritual": () => new Card("Demonic Ritual+", 3, "Power", "At the end of your turn, gain 3 Strength.", async function(enemy){
                    await gainBuff("Ritual", 3);
                }, ["exhausted"]), "Double Tap": () => new Card("Double Tap+", 1, "Skill", "Your next Attack is played 3 times.", async function(enemy){
                    await gainBuff("Double Tap", 2);
                }, ["exhausted"]), "Exhume": () => new Card("Exhume+", 0, "Skill", "Put a card from your exhaust pile in your hand. Exhaust.", async function(enemy){
                    let chosen = await choose(exhaustPile, "Choose a card to put into your hand.");
                    if(chosen) {
                        hand.push(chosen);
                        exhaustPile.splice(exhaustPile.indexOf(chosen), 1);
                        updateHtml();
                    } else {
                        alert("Failed to play Exhume: Exhaust pile is empty.");
                    }
                }, ["exhausted"]), "Feed": () => new Card("Feed+", 1, "Attack", "Enemy loses 12 HP. If they die from it, gain 4 Max HP. Exhaust.", function(enemy){
                    if(enemy.hp <= 12) {maxHp += 4; hp += 4;}
                    enemy.hp -= 12;
                }, ["exhausted"]), "Impervious": () => new Card("Impervious+", 2, "Skill", "Gain [BLK40] block. Exhaust.", async function(enemy){
                    await gainBuff("Block", 40);
                }, ["exhausted"]), "Juggernaut": () => new Card("Juggernaut+", 2, "Power", "Whenever you gain Block, deal [DAM7] damage to a random enemy.", async function(enemy){
                    await gainBuff("Juggernaut", 7);
                }, ["exhausted"]), "Limit Break": () => new Card("Limit Break+", 1, "Skill", "Double your Strength.", async function(enemy){
                    if(hasBuff("Strength")>0) {await gainBuff("Strength", hasBuff("Strength"));}
                }), "Offering": () => new Card("Offering+", 0, "Skill", "Lose 6 HP. Gain 2 energy. Draw 5 cards. Exhaust.", function(enemy){
                    hp -= 6; energy += 2; drawCard(5);
                }, ["exhausted"]), "Reaper": () => new Card("Reaper+", 2, "Attack", "Deal [DAM10] damage. Heal 10 HP. Exhaust.", function(enemy){
                    dealDamage(enemy, 10); hp = Math.min(maxHp, hp + 10);
                }, ["exhausted"]), "Acrobatics": () => new Card("Acrobatics+", 1, "Skill", "Draw 4 cards. Discard 1 card.", async function(enemy){
                drawCard(4);
                let chosen = await choose(hand.filter(x=>x.name!="Acrobatics+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            }), "Backflip": () => new Card("Backflip+", 1, "Skill", "Gain [BLK8] Block. Draw 2 cards.", async function(enemy){
                drawCard(2); await gainBuff("Block", 8);
            }), "Bane": () => new Card("Bane+", 1, "Attack", "Deal [DAM10] damage, twice if enemy has Poison.", function(enemy){
                dealDamage(enemy, 10); if(enemy.hasBuff("Poison")) {dealDamage(enemy, 10);}
            }), "Blade Dance": () => new Card("Blade Dance+", 1, "Skill", "Add 4 Shivs to your hand.", function(enemy){
                addShivs(4);
            }), "Cloak and Dagger": () => new Card("Cloak and Dagger+", 1, "Skill", "Gain [BLK6] Block. Add 2 Shivs to your hand.", async function(enemy){
                addShivs(2); await gainBuff("Block", 6);
            }), "Dagger Spray": () => new Card("Dagger Spray+", 1, "Attack", "Deal [DAM6] damage to ALL enemies twice.", function(enemy){
                for(let e of enemies){dealDamage(e, 6);dealDamage(e, 6);}
            }), "Dagger Throw": () => new Card("Dagger Throw+", 1, "Attack", "Deal [DAM12] damage. Draw a card. Discard a card.", async function(enemy){
                dealDamage(enemy, 12); drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Dagger Throw+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            }), "Deadly Poison": () => new Card("Deadly Poison+", 1, "Skill", "Apply 7 Poison.", async function(enemy){
                await enemy.gainBuff("Poison", 7);
            }), "Deflect": () => new Card("Deflect+", 0, "Skill", "Gain [BLK7] Block.", async function(enemy){
                await gainBuff("Block", 7);
            }), "Dodge and Roll": () => new Card("Dodge and Roll+", 1, "Skill", "Gain [BLK5] Block. Next turn, gain [BLK8] Block.", async function(enemy){
                await gainBuff("Block", 5); await gainBuff("Next Turn Block", 8);
            }), "Flying Knee": () => new Card("Flying Knee+", 1, "Attack", "Deal [DAM11] damage. Gain 1 more energy next turn.", async function(enemy){
                dealDamage(enemy, 11); await gainBuff("Next Turn Energy", 1);
            }), "Outmaneuver": () => new Card("Outmaneuver+", 1, "Skill", "Gain 3 more energy next turn.", async function(enemy){
                await gainBuff("Next Turn Energy", 3);
            }), "Poisoned Stab": () => new Card("Poisoned Stab+", 1, "Attack", "Deal [DAM8] damage. Apply 4 Poison.", async function(enemy){
                dealDamage(enemy, 8); await enemy.gainBuff("Poison", 4);
            }), "Prepared": () => new Card("Prepared+", 0, "Skill", "Draw 2 cards. Discard 2 cards.", async function(enemy){
                drawCard(2);
                let chosen = await choose(hand.filter(x=>x.name!="Prepared+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared+"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
            }), "Quick Slash": () => new Card("Quick Slash+", 1, "Attack", "Deal [DAM12] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 12); drawCard();
            }), "Slice": () => new Card("Slice+", 0, "Deal [DAM9] damage.", function(enemy){
                dealDamage(enemy, 9);
            }), "Sucker Punch": () => new Card("Sucker Punch+", 1, "Attack", "Deal [DAM9] damage. Apply 2 Weak.", async function(enemy){
                dealDamage(enemy, 9); await enemy.gainBuff("Weak", 2);
            }), "Accuracy": () => new Card("Accuracy+", 1, "Power", "Shivs deal 6 more damage.", async function(enemy){
                await gainBuff("Accuracy", 6);
            }, ["exhausted"]), "All-Out Attack": () => new Card("All-Out Attack+", 1, "Attack", "Deal [DAM14] damage to ALL enemies. Discard a random card.", function(enemy){
                for(let e of enemies) {dealDamage(e, 14);}
                let chosen = choice(hand);
                discardPile.push(chosen);
                hand.splice(hand.indexOf(chosen), 1);
            }), "Backstab": () => new Card("Backstab+", 0, "Attack", "Innate. Deal [DAM15] damage. Exhaust.", function(enemy){
                dealDamage(enemy, 15);
            }, ["exhausted", "innate"]), "Blur": () => new Card("Blur+", 1, "Skill", "Gain [BLK8] Block. Block is not removed next turn.", async function(enemy){
                await gainBuff("Blur", 1); await gainBuff("Block", 8);
            }), "Bouncing Flask": () => new Card("Bouncing Flask+", 2, "Skill", "Apply 12 Poison to a random enemy.", async function(enemy){
                await choice(enemies).gainBuff("Poison", 12);
            }), "Caltrops": () => new Card("Caltrops+", 1, "Skill", "Gain 5 Thorns. Exhaust.", async function(enemy){
                await gainBuff("Thorns", 5);
            }, ["exhausted"]), "Catalyst": () => new Card("Catalyst+", 1, "Skill", "Triple the enemy's Poison. Exhaust.", async function(enemy){
                await enemy.gainBuff("Poison", enemy.hasBuff("Poison") * 2);
            }, ["exhausted"]), "Concentrate": () => new Card("Concentrate+", 0, "Skill", "Discard 2 cards. Gain 2 energy.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
                energy += 2;
            }), "Crippling Cloud": () => new Card("Crippling Cloud+", 2, "Skill", "Apply 7 Poison and 2 Weak to ALL enemies. Exhaust.", async function(enemy){
                for(let e of enemies) {await e.gainBuff("Poison", 7); await e.gainBuff("Weak", 2);}
            }, ["exhausted"]), "Dash": () => new Card("Dash+", 2, "Attack", "Deal [DAM13] damage. Gain [BLK13] Block.", async function(enemy){
                dealDamage(enemy, 13); await gainBuff("Block", 13);
            }), "Distraction": () => new Card("Distraction+", 0, "Skill", "Add 2 random Skills to your hand. Exhaust.", function(enemy){
                let extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Skill") {extraCard = randCard()();}
                hand.push(extraCard);
                extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Skill") {extraCard = randCard()();}
                hand.push(extraCard);
            }, ["exhausted"]), "Escape Plan": () => new Card("Escape Plan+", 0, "Skill", "Draw a card. If it's a Skill, gain [BLK5] Block.", async function(enemy){
                drawCard();
                if(hand[hand.length - 1].type == "Skill") {await gainBuff("Block", 5);}
            }), "Expertise": () => new Card("Expertise+", 1, "Skill", "Draw cards until you have 7 in hand.", function(enemy){
                if(hand.length < 7) {drawCard(7 - hand.length);}
            }), "Finisher": () => new Card("Finisher+", 1, "Attack", "Deal 8 damage for each Attack played this turn. (Deals [FINISHER+] damage)", function(enemy){
                dealDamage(enemy, stats.attacksThisTurn * 8);
            }), "Footwork": () => new Card("Footwork+", 1, "Power", "Gain 3 Dexterity.", async function(enemy){
                await gainBuff("Dexterity", 3);
            }, ["exhausted"]), "Heel Hook": () => new Card("Heel Hook+", 1, "Attack", "Deal [DAM8] damage. If the enemy has Weak, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 8);
                if(enemy.hasBuff("Weak") > 0) {energy += 1; drawCard();}
            }), "Infinite Blades": () => new Card("Infinite Blades+", 1, "Power", "Innate. At the start of your turn, add a Shiv into your hand.", async function(enemy){
                await gainBuff("Infinite Blades", 1);
            }, ["exhausted", "innate"]), "Leg Sweep": () => new Card("Leg Sweep+", 2, "Skill", "Apply 3 Weak. Gain [BLK14] Block.", async function(enemy){
                await gainBuff("Block", 14); await enemy.gainBuff("Weak", 3);
            }), "Noxious Fumes": () => new Card("Noxious Fumes+", 1, "Power", "At the start of your turn, apply 3 Poison to ALL enemies.", async function(enemy){
                await gainBuff("Noxious Fumes", 3);
            }, ["exhausted"]), "Predator": () => new Card("Predator+", 2, "Attack", "Deal [DAM20] damage. Next turn, draw 2 more cards.", async function(enemy){
                dealDamage(enemy, 20); await gainBuff("Next Turn Cards", 2);
            }), "Skewer": () => new Card("Skewer+", "X", "Attack", "Deal [DAM10] damage X times.", function(enemy){
                dealDamage(enemy, 10);
            }), "Terror": () => new Card("Terror+", 0, "Skill", "Apply 999 Vulnerable. Exhaust.", async function(enemy){
                await enemy.gainBuff("Vulnerable", 999);
            }, ["exhausted"]), "A Thousand Cuts": () => new Card("A Thousand Cuts+", 2, "Power", "Whenever you play a card, deal [DAM2] damage to ALL enemies.", async function(enemy) {
                await gainBuff("Thousand Cuts", 2);
            }, ["exhausted"]), "Adrenaline": () => new Card("Adrenaline+", 0, "Skill", "Gain 2 energy. Draw 2 cards. Exhaust.", function(enemy){
                energy += 2; drawCard(2);
            }, ["exhausted"]), "After Image": () => new Card("After Image+", 1, "Power", "Innate. Whenever you play a card, gain [BLK1] Block.", async function(enemy){
                await gainBuff("After Image", 1);
            }, ["exhausted", "innate"]), "Burst": () => new Card("Burst+", 1, "Skill", "Your next Skill is played 3 times.", async function(enemy){
                await gainBuff("Burst", 2);
            }), "Die Die Die": () => new Card("Die Die Die+", 1, "Attack", "Deal [DAM17] damage to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {dealDamage(e, 17);}
            }, ["exhausted"]), "Doppelganger": () => new Card("Doppelganger+", "X", "Skill", "Next turn, draw X more cards and gain X more energy.", async function(enemy){
                await gainBuff("Next Turn Cards", 1); await gainBuff("Next Turn Energy", 1);
            }), "Envenom": () => new Card("Envenom+", 1, "Power", "Whenever you deal unblocked damage, apply 1 Poison.", async function(enemy){
                await gainBuff("Envenom", 1);
            }, ["exhausted"]), "Grand Finale": () => new Card("Grand Finale+", 0, "Attack", "If there are no cards in your draw pile, deal [DAM60] damage to ALL enemies.", function(enemy) {
                if(drawPile.length == 0) {for(let e of enemies){dealDamage(e, 60);}} else {alert("Failed to play Grand Finale: There are cards in your draw pile.");}
            }), "Storm of Steel": () => new Card("Storm of Steel+", 1, "Skill", "Replace your hand with upgraded Shivs.", function(enemy){
                let handSize = hand.length;
                for(let i of hand) {discardPile.push(i);}
                addShivPluses(handSize);
            }), "Tools of the Trade": () => new Card("Tools of the Trade+", 0, "Power", "At the start of your turn, draw a card and discard a card.", async function(enemy){
                await gainBuff("Tools of the Trade", 1);
            }, ["exhausted"]), "Ascenders Bane": () => new Card("Ascenders Bane+", 0, "Curse", "Playable.", function(enemy){})
            };
            
            function upgradeCard(c) {
                let newCard = upgradedCards[c.name];
                let deckNames = deck.map(x=>x.name);
                deck.splice(deckNames.indexOf(c.name), 1);
                deck.push(newCard());
            }
            let cardToUpgrade;
            async function upgradeDialog() {
                let chosen = await choose(deck.filter(x=>(!x.name.includes("+"))), "Choose a card to upgrade.");
                cardToUpgrade = chosen;
                getId("upgradeDialog").style.display = "block";
                getId("cardDesc").innerHTML = "Upgrading <b>"+cardToUpgrade.name+"</b>:<br/><span style='color:#faa'>Old</span>: "+addCircle(cardToUpgrade.cost.toString())+" | "+unformat(cardToUpgrade.desc)+"<br/><span style='color:#afa'>New</span>: "+addCircle(upgradedCards[cardToUpgrade.name]().cost.toString())+" | "+unformat(upgradedCards[cardToUpgrade.name]().desc);
            }
            
            let randCard = () => choice([bodySlam, clash, cleave, clothesline, flex, headbutt, heavyBlade, ironWave, pommelStrike, shrugItOff, swordBoomerang, thunderclap, trueGrit, twinStrike, wildStrike, battleTrance, bloodForBlood, bloodletting, burningPact, carnage, combust, darkEmbrace, disarm, dropkick, dualWield, entrench, evolve, feelNoPain, fireBreathing, flameBarrier, ghostlyArmor, hemokinesis, infernalBlade, inflame, intimidate, metallicize, powerThrough, pummel, rage, rampage, secondWind, seeingRed, severSoul, spotWeakness, uppercut, whirlwind, acrobatics, backflip, bane, bladeDance, cloakAndDagger, daggerSpray, daggerThrow, deadlyPoison, deflect, dodgeAndRoll, flyingKnee, outmaneuver, poisonedStab, prepared, quickSlash, slice, suckerPunch, accuracy, allOutAttack, backstab, blur, bouncingFlask, caltrops, catalyst, concentrate, cripplingCloud, dash, distraction, expertise, finisher, footwork, heelHook, infiniteBlades, legSweep, noxiousFumes, predator, skewer, terror]);
            let randRareCard = () => choice([barricade, berserk, bludgeon, brutality, demonForm, doubleTap, exhume, feed, impervious, juggernaut, limitBreak, offering, reaper, thousandCuts, adrenaline, afterImage, burst, dieDieDie, doppelganger, envenom, grandFinale, stormOfSteel, toolsOfTheTrade]);
            
            function addCard(newCards="random") {
                if(newCards == "random") {
                    if((eliteBattle && getId("ascensionLevel").value < 12) || bossBattle) {
                        newCards = [randRareCard()(), randRareCard()(), randRareCard()()];
                    } else {
                        newCards = [randCard()(), randCard()(), randCard()()];
                    }
                }
                possibleCards = newCards;
                getId("cardModal").style.display = "block";
                for(let x=0; x<3; x++) {
                    let cardTooltip = document.createElement("span");
                    let modalCard = getId("modalCard"+(x+1));
                    modalCard.innerHTML = newCards[x].name;
                    cardTooltip.innerHTML = addCircle(newCards[x].cost.toString())+" "+newCards[x].type+" | "+unformat(newCards[x].desc);
                    cardTooltip.setAttribute("class", "txt");
                    modalCard.appendChild(cardTooltip);
                }
            };
            function finishAddCard(cardNumber) {
                if(cardNumber >= 0 && cardNumber < possibleCards.length) {
                    let c = possibleCards[cardNumber];
                    deck.push(c);
                    for(let r of relics) {if(r.trigger == "add_card") {r.effect(c);}}
                    updateStatLine();
                } else if(cardNumber == -1) {
                    for(let r of relics) {if(r.trigger == "no_card") {r.effect();}}
                    updateStatLine();
                }
            }
            
            function addBossRelic(newCards="random") {
                if(newCards == "random") {
                    newCards = [choice(rareRelicPool)(), choice(rareRelicPool)(), choice(rareRelicPool)()];
                }
                possibleCards = newCards;
                getId("bossModal").style.display = "block";
                for(let x=0; x<3; x++) {
                    let cardTooltip = document.createElement("span");
                    let modalCard = getId("modalRelic"+(x+1));
                    modalCard.innerHTML = newCards[x].name;
                    cardTooltip.innerHTML = newCards[x].desc;
                    cardTooltip.setAttribute("class", "txt");
                    modalCard.appendChild(cardTooltip);
                }
            };
            function finishAddRelic(cardNumber) {
                if(cardNumber >= 0 && cardNumber < possibleCards.length) {
                    let r = possibleCards[cardNumber];
                    relics.push(r);
                    if(r.trigger == "on_pickup") {r.effect();}
                    updateStatLine();
                }
            }
            let possibleCards = [];
            
            function r_snakeRing() {drawCard(2);}
            function r_akabeko() {Promise.resolve(gainBuff("Strength", 8)); Promise.resolve(gainBuff("Vigor", 8));}
            function r_anchor() {Promise.resolve(gainBuff("Next Turn Block", 10));}
            function r_tea() {energy += 2;}
            function r_artOfWar() {Promise.resolve(gainBuff("Next Turn Energy", 1));}
            function r_bagOfMarbles() {for(let x of enemies){Promise.resolve(x.gainBuff("Vulnerable",1));}}
            function r_bloodVial() {hp = Math.min(maxHp, hp+2);}
            function r_bronzeScales() {Promise.resolve(gainBuff("Thorns", 3));}
            function r_ceramicFish() {gold += 9;}
            function r_nunchaku() {if(Math.random()<0.1){energy += 1;}}
            function r_smoothStone() {Promise.resolve(gainBuff("Dexterity", 1));}
            function r_orichalcum() {if(hasBuff("Block")==0){Promise.resolve(gainBuff("Block", 6));}}
            function r_penNib() {Promise.resolve(gainBuff("Pen Nib", 1)); if(hasBuff("Pen Nib") >= 10) {Promise.resolve(loseBuff("Pen Nib")); dealDamage(target, 10);}}
            function r_preservedInsect() {if(eliteBattle==true){dealDamage(target,Math.round(0.25*target.hp));}}
            function r_regalPillow() {hp = Math.min(maxHp, hp+15);}
            function r_strawberry() {maxHp += 7; hp += 7;}
            function r_vajra() {Promise.resolve(gainBuff("Strength", 1));}
            function r_feather() {hp = Math.min(maxHp, hp+Math.round(0.5*deck.length));}
            function r_frozenEgg(c) {if(c.type=="Power"){upgradeCard(c);}}
            function r_letterOpener() {for(let x of enemies){dealDamage(x, 5);}}
            function r_meatBone() {if(hp/maxHp <= 0.5) {hp = Math.min(maxHp, hp+12);}}
            function r_mercuryHourglass() {for(let x of enemies){dealDamage(x, 3);}}
            function r_moltenEgg(c) {if(c.type=="Attack"){upgradeCard(c);}}
            function r_ornamentalFan() {Promise.resolve(gainBuff("Block", 4));}
            function r_pear() {maxHp += 10; hp += 10;}
            function r_selfFormingClay() {Promise.resolve(gainBuff("Next Turn Block", 3));}
            function r_singingBowl() {maxHp += 2; hp += 2;}
            function r_strikeDummy() {dealDamage(target, 3);}
            function r_toxicEgg(c) {if(c.type=="Skill"){upgradeCard(c);}}
            function r_birdFacedUrn() {hp = Math.min(maxHp, hp+2);}
            function r_championsBelt() {Promise.resolve(target.gainBuff("Weak", 1));}
            function r_deadBranch() {hand.push(randCard()());}
            function r_helixFossil() {Promise.resolve(gainBuff("Buffer", 1));}
            function r_mango() {maxHp += 14; hp += 14;}
            function r_oldCoin() {gold += 300;}
            function r_threadAndNeedle() {Promise.resolve(gainBuff("Metallicize", 3));}
            let relicPool = [
                () => new Relic("Akabeko","Your first attack each combat deals 8 more damage.","combat_start",r_akabeko),
                () => new Relic("Anchor","Start each combat with 10 Block","combat_start",r_anchor),
                () => new Relic("Ancient Tea Set","When you enter a Rest Site, start the next combat with 2 more energy.","rest",r_tea),
                () => new Relic("Art of War","If you play no attacks in a turn, gain 1 energy next turn.","no_attacks",r_artOfWar),
                () => new Relic("Bag of Marbles","ALL enemies start combat with 1 Vulnerable.","combat_start",r_bagOfMarbles),
                () => new Relic("Blood Vial","At start of combat, heal 2 HP.","combat_start",r_bloodVial),
                () => new Relic("Bronze Scales","When you take damage, deal 3 damage back.","combat_start",r_bronzeScales),
                () => new Relic("Ceramic Fish","When you add a card to your deck, gain 9 gold.","add_card",r_ceramicFish),
                () => new Relic("Lantern","Gain 1 energy at the start of each combat.","combat_start",r_artOfWar),
                () => new Relic("Nunchaku","When you play an Attack, 10% chance to gain 1 energy.","on_attack",r_nunchaku),
                () => new Relic("Oddly Smooth Stone","Start each combat with 1 Dexterity.","combat_start",r_smoothStone),
                () => new Relic("Orichalcum","When you end your turn without Block, gain 6 Block.","turn_end",r_orichalcum),
                () => new Relic("Pen Nib","Every 10th Attack you play deals 10 more damage.","on_attack",r_penNib),
                () => new Relic("Preserved Insect","Elites have 25% less HP.","combat_start",r_preservedInsect),
                () => new Relic("Regal Pillow","When you leave a Rest Site, heal 15 HP.","rest",r_regalPillow),
                () => new Relic("Strawberry","Raise your max HP by 7 and heal 7 HP.","on_pickup",r_strawberry),
                () => new Relic("Vajra","Start each combat with 1 Strength.","combat_start",r_vajra),
                () => new Relic("Eternal Feather","When you rest, heal 1 HP for each 2 cards in your deck.","rest",r_feather),
                () => new Relic("Frozen Egg","When you add a Power to your deck, it is upgraded.","add_card",r_frozenEgg),
                () => new Relic("Ice Cream","You can keep excess energy between turns.","special",function(){}),
                () => new Relic("Kunai","When you play 3 Attacks in a single turn, gain 1 Dexterity.","3_attacks",r_smoothStone),
                () => new Relic("Letter Opener","When you play 3 Skills in a single turn, deal 5 damage to ALL enemies.","3_skills",r_letterOpener),
                () => new Relic("Meat on the Bone","When you start combat with under 50% HP, heal 12 HP.","combat_start",r_meatBone),
                () => new Relic("Mercury Hourglass","At start of turn, deal 3 damage to ALL enemies.","turn_start",r_mercuryHourglass),
                () => new Relic("Molten Egg","When you add an Attack to your deck, it is upgraded.","add_card",r_moltenEgg),
                () => new Relic("Ornamental Fan","When you play 3 Attacks in a single turn, gain 4 Block.","3_attacks",r_ornamentalFan),
                () => new Relic("Pear","Raise your max HP by 10 and heal 10 HP.","on_pickup",r_pear),
                () => new Relic("Self-Forming Clay","When you lose HP in combat, gain 3 Block next turn.","lose_hp",r_selfFormingClay),
                () => new Relic("Shuriken","When you play 3 Attacks in a single turn, gain 1 Strength.","3_attacks",r_vajra),
                () => new Relic("Singing Bowl","When you view but decline the card reward, gain 2 Max HP.","no_card",r_singingBowl),
                () => new Relic("Strike Dummy","Cards containing Strike deal 3 more damage.","strike",r_strikeDummy),
                () => new Relic("Toxic Egg","When you add a Skill to your deck, it is upgraded.","add_card",r_toxicEgg)
            ];
            let rareRelicPool = [
                () => new Relic("Bird-Faced Urn","When you play a Power, heal 2 HP.","on_power",r_birdFacedUrn),
                () => new Relic("Champion's Belt","When you apply Vulnerable, also apply 1 Weak.","apply_vulnerable",r_championsBelt),
                () => new Relic("Charon's Ashes","When you Exhaust a card, deal 3 damage to ALL enemies.",r_mercuryHourglass),
                () => new Relic("Dead Branch","When you Exhaust a card, add a random card to your hand.","on_exhaust",r_deadBranch),
                () => new Relic("Fossilized Helix","Prevent the first HP loss each combat.","combat_start",r_helixFossil),
                () => new Relic("Mango","Raise your max HP by 14 and heal 14 HP.","on_pickup",r_mango),
                () => new Relic("Old Coin","Instantly gain 300 gold.","on_pickup",r_oldCoin),
                () => new Relic("Thread and Needle","Start each combat with 3 Metallicize.","combat_start",r_threadAndNeedle)
            ];
            
            let potionPool = [
                {name: "Block", desc: "Gain 12 Block.", effect: 'Promise.resolve(gainBuff("Block", 12))'},
                {name: "Blood", desc: "Heal for 20% of your Max HP.", effect: 'hp = Math.min(maxHp, hp + Math.round(0.2 * maxHp))'},
                {name: "Cultist", desc: "Gain 1 Ritual.", effect: 'Promise.resolve(gainBuff("Ritual", 1))'},
                {name: "Dexterity", desc: "Gain 2 Dexterity.", effect: 'Promise.resolve(gainBuff("Dexterity", 2))'},
                {name: "Energy", desc: "Gain 2 energy.", effect: 'energy += 2'},
                {name: "Iron", desc: "Gain 3 Metallicize.", effect: 'Promise.resolve(gainBuff("Metallicize", 3))'},
                {name: "Explosive", desc: "Deal 10 damage to ALL enemies.", effect: 'for(let e of enemies){dealDamage(e, 10);}'},
                {name: "Fear", desc: "Apply 3 Vulnerable to target.", effect: 'Promise.resolve(tgt.gainBuff("Vulnerable", 3))'},
                {name: "Fire", desc: "Deal 20 damage to target.", effect: 'dealDamage(tgt, 20)'},
                {name: "Flex", desc: "Gain 5 Strength. At end of turn, lose 5 Strength.", effect: 'Promise.resolve(gainBuff("Strength", 5)); Promise.resolve(gainBuff("Strength Down", 5))'},
                {name: "Fruit Juice", desc: "Gain 5 Max HP.", effect: 'maxHp += 5; hp += 5'},
                {name: "Steel", desc: "Gain 5 Metallicize.", effect: 'Promise.resolve(gainBuff("Metallicize", 5))'},
                {name: "Bronze", desc: "Gain 3 Thorns.", effect: 'Promise.resolve(gainBuff("Thorns", 3))'},
                {name: "Regen", desc: "Gain 5 Regen.", effect: 'Promise.resolve(gainBuff("Regen", 5))'},
                {name: "Speed", desc: "Gain 5 Dexterity. At end of turn, lose 5 Dexterity.", effect: 'Promise.resolve(gainBuff("Dexterity", 5)); Promise.resolve(gainBuff("Dexterity Down", 5))'}
            ];
            
            let deck = [strike(), strike(), strike(), strike(), bash(), defend(), defend(), defend(), defend(), defend()];
            let relics = [new Relic("Ring of the Snake","At the start of each combat, draw 2 additional cards.","combat_start",r_snakeRing)];
            let potions = [];
            let drawPile = shuffle(deck.slice(0)); // no shallow copy
            let discardPile = [];
            let exhaustPile = [];
            let hand = [];
            let energy = 0;
            let maxEnergy = 3;
            let hp = 70;
            let maxHp = 70;
            let buffs = [];
            let stats = {timesLostHp: 0, hasAttacked: false, attacksThisTurn: 999, skillsThisTurn: 999, rested: false};
            let gold = 0;
            let mapX = 2;
            let mapY = 0;
            let actNum = 1;
            let randomThing = () => choice(["enemy", "enemy", "enemy", "enemy", "shop&nbsp;", "elite", "rest&nbsp;"]);
            function maybeThing() {if(Math.random()<0.6){return randomThing();}else{return "";}}
            let map;
            function mapGen() {
                map = [
                    ["",            "",            "start",       "",            ""          ],
                    ["",            "enemy",       "enemy",       "enemy",       ""          ]
                ];
                let middleFloors = [];
                for(let i=0; i<12; i++) {
                    middleFloors.push([maybeThing(), randomThing(), randomThing(), randomThing(), maybeThing()]);
                }
                let numRests = middleFloors.flat().filter(x=>x=="rest&nbsp;").length;
                while(numRests > 8) {
                    let rowsWithRests = middleFloors.filter(x=>x.includes("rest&nbsp;"));
                    let rowWithRest = choice(rowsWithRests);
                    let restSites = rowWithRest.filter(x=>x=="rest&nbsp;");
                    let restSite = choice(restSites.map(x=>rowWithRest.indexOf(x)));
                    let newNode = randomThing();
                    let rowIndex = middleFloors.indexOf(rowWithRest);
                    middleFloors[rowIndex][restSite] = newNode;
                    numRests = middleFloors.flat().filter(x=>x=="rest&nbsp;").length;
                }
                while(numRests < (getId("ascensionLevel").value >= 15 ? 3 : 5)) {
                    let row = Math.round(Math.random()*12);
                    let col = Math.round(Math.random()*5);
                    while(middleFloors[row][col] == "" || !middleFloors[row][col]) {col = Math.round(Math.random()*5);}
                    middleFloors[row][col] = "rest&nbsp;";
                    numRests = middleFloors.flat().filter(x=>x=="rest&nbsp;").length;
                }
                let numElites = middleFloors.flat().filter(x=>x=="elite").length;
                while(numElites < 4) {
                    let row = Math.round(Math.random()*12);
                    let col = Math.round(Math.random()*5);
                    while(middleFloors[row][col] == "" || !middleFloors[row][col]) {col = Math.round(Math.random()*5);}
                    middleFloors[row][col] = "elite";
                    numElites = middleFloors.flat().filter(x=>x=="elite").length;
                }
                for(let i of middleFloors) {map.push(i);}
                map.push(["",            "rest&nbsp;",  "rest&nbsp;",  "rest&nbsp;",  ""          ]);
                map.push(["",            "","<b style='color:red'>BOSS&nbsp;</b>","", ""          ]);
            }
            
            // These make writing attacks *much* easier.
            async function addStatus(name, amt) {
                let dn = getId("buffSayerForPlayer");
                if(amt > 0) {
                    let str = "+"+amt+" "+name;
                    dn.innerHTML = str;
                    dn.style.top = getId("statusLine").getBoundingClientRect().bottom;
                    dn.style.left = getId("statusLine").getBoundingClientRect().left;
                    dn.style.fontSize = "30px";
                    dn.style.color = "#f00";
                    for(let i of playerBuffTimeouts) {clearTimeout(i);}
                    playerBuffTimeouts = [];
                    dn.style.opacity = "1";
                    for(let i=0; i<50; i++) {
                        playerBuffTimeouts.push(setTimeout(function(){dn.style.opacity = (49-i)/50}, i*5 + 750));
                    }
                    playerBuffTimeouts.push(setTimeout(function(){playerBuffTimeouts = [];}, 1000));
                    return new Promise(resolve => setTimeout(() => resolve(0), 300));
                }
                for(let x=0; x<amt; x++) {discardPile.push(statusCards[name]());}
            }
            let attack = amt => async function(me){ await me.dealDamage(amt); }
            let block = amt => async function(me){ await me.gainBuff("Block", amt); }
            let block_random = amt => async function(me){ await choice(enemies).gainBuff("Block", amt); }
            let buff = (what, amt) => async function(me){ await me.gainBuff(what, amt); }
            let all_buff = (what, amt) => async function(me){ for(let e of enemies){await e.gainBuff(what, amt);}}
            let apply = (what, amt) => async function(me){ await gainBuff(what, amt); }
            let status = (what, amt) => async function(me){ await addStatus(what, amt); }
            let multi_apply = (lst) => async function(me){ for(let x of lst){await gainBuff(x[0], x[1]);} }
            let multi_buff = (lst) => async function(me){ for(let x of lst){await me.gainBuff(x[0], x[1]);} }
            let attack_block = (atk, blk) => async function(me){ await me.dealDamage(atk); await me.gainBuff("Block", blk); }
            let attack_apply = (atk, what, amt) => async function(me){ await me.dealDamage(atk); await gainBuff(what, amt); }
            let attack_buff = (atk, what, amt) => async function(me){ await me.dealDamage(atk); await me.gainBuff(what, amt); }
            let block_buff = (blk, what, amt) => async function(me){ me.gainBuff("Block", blk); await me.gainBuff(what, amt); }
            let block_multinerf = (blk, lst) => async function(me){ await me.gainBuff("Block", blk); for(let x of lst){await gainBuff(x[0], x[1]);}}
            let attack_status = (atk, what, amt) => async function(me){ await addStatus(what, amt); await me.dealDamage(atk); }
            let buff_apply = (b, bamt, n, namt) => async function(me){ await me.gainBuff(b, bamt); await gainBuff(n, namt); }
            let passTurn = () => async function(me){ await me.dealDamage(0); }
            
            let possibleEnemies = [
                () => new Enemy("Cultist", 50, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                    {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                ], ["no-repeat"]),
                () => new Enemy("Jaw Worm", 40, [
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "attack-block 5", desc: "deal [DAM5] damage and block", effect: attack_block(5, 5)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 2)}
                ], ["randomize"]),
                () => new Enemy("Louse", 35, [
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 2)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
                ], ["randomize"]),
                () => new Enemy("Spike Slime", 45, [
                    {intent: "attack-nerf 9", desc: "deal [DAM9] damage and generate Status cards", effect: attack_status(9, "Slimed", 1)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 1)}
                ]),
                () => new Enemy("Gremlin", 25, [
                    {intent: "attack-nerf 9", desc: "deal [DAM9] damage and apply a negative effect", effect: attack_apply(9, "Weak", 1)}
                ])
            ];
            let possibleElites = [
                () => new Enemy("Gremlin Nob", 85, [
                    {intent: "buffing +", desc: "gain a <b>powerful buff</b>", effect: buff("Enrage", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and apply a negative effect", effect: attack_apply(6, "Vulnerable", 1)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)}
                ], ["no-repeat"]),
                () => new Enemy("Lagavulin", 110, [
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "blocking", desc: "block", effect: block(8)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: multi_apply([["Minus Strength", 1], ["Minus Dexterity", 1]])}
                ])
            ];
            let possibleBosses = [
                () => new Enemy("Slime Boss", 190, [
                    {intent: "meganerf", desc: "generate <b>many Status cards</b>", effect: status("Slimed", 3)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: function(me){}},
                    {intent: "attacking 35", desc: "deal [DAM35] damage", effect: attack(35)}
                ])
            ];
            let possibleEnemies_act2 = [
                () => new Enemy("Spheric Guardian", 60, [
                    {intent: "block-buff +", desc: "gain <b>multiple buffs</b>", effect: multi_buff([["Barricade", 1], ["Block", 25], ["Artifact", 3]])},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(7, "Frail", 5)},
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 7)}
                ], ["no-repeat"]),
                () => new Enemy("The Chosen", 95, [
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: apply("Hex", 1)},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(7, "Vulnerable", 1)},
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                    {intent: "attacking 12", desc: "deal [DAM18] damage", effect: attack(12)},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(10, "Vulnerable", 1)}
                ]),
                () => new Enemy("Shelled Parasite", 70, [
                    {intent: "attack-block 8", desc: "deal [DAM8] damage and block", effect: attack_block(8, 10)},
                    {intent: "attack-block 8", desc: "deal [DAM8] damage and block", effect: attack_block(8, 10)},
                    {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply a negative effect", effect: attack_apply(12, "Frail", 2)}
                ])
            ];
            let possibleElites_act2 = [
                () => new Enemy("Book of Stabbing", 160, [
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-buff 8", desc: "deal [DAM8] damage and gain a buff", effect: attack_buff(8, "Strength", 4)},
                    {intent: "attack-buff 8", desc: "deal [DAM8] damage and gain a buff", effect: attack_buff(8, "Strength", 4)}
                ]),
                () => new Enemy("Gremlin Leader", 150, [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 3)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        let gremlins = [
                            () => new Enemy("Fat Gremlin", 15, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attack-nerf 3", desc: "deal [DAM3] damage and apply a negative effect", effect: attack_apply(3, "Weak", 1)}
                            ]),
                            () => new Enemy("Mad Gremlin", 20, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                            ]),
                            () => new Enemy("Shield Gremlin", 15, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)},
                                {intent: "blocking", desc: "shield a random enemy", effect: block_random(7)}
                            ]),
                            () => new Enemy("Sneaky Gremlin", 10, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}
                            ]),
                            () => new Enemy("Wizard Gremlin", 25, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "unknown", desc: "charge a powerful attack", effect: passTurn()},
                                {intent: "unknown", desc: "charge a powerful attack", effect: passTurn()},
                                {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)}
                            ])
                        ];
                        if(enemies.length <= 8) {enemies.push(choice(gremlins)()); enemies.push(choice(gremlins)());}
                    }}
                ], ["randomize"])
            ];
            let possibleBosses_act2 = [
                () => new Enemy("The Champ", 530, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 3)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(15, "Metallicize", 3)},
                    {intent: "meganerf", desc: "apply <b>many negative effects</b>", effect: multi_apply([["Vulnerable", 2], ["Weak", 2], ["Frail", 2]])},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)}
                ], ["randomize"])
            ];
            let possibleEnemies_act3 = [
                () => new Enemy("Huge Jaw Worm", 70, [
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(8, "Strength", 2)},
                    {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(8, "Strength", 2)},
                    {intent: "attack-block 6", desc: "deal [DAM6] damage and block", effect: attack_block(6, 6)}
                ]),
                () => new Enemy("Spiker", 50, [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                        if(enemies.length <= 8) {
                            let exploder = () => new Enemy("Exploder", 30, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "unknown 6", desc: "deal [DAM6] damage and get ready to explode", effect: attack(6)},
                                {intent: "unknown 6", desc: "deal [DAM6] damage and get ready to explode", effect: attack(6)},
                                {intent: "unknown 20", desc: "deal [DAM20] damage and die", effect: async function(me){
                                    enemies.splice(enemies.indexOf(me), 1); await me.dealDamage(20);}
                                }
                            ], ["no-repeat"]);
                            let repulsor = () => new Enemy("Repulsor", 30, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
                            ], ["no-repeat"]);
                            enemies.push(repulsor());
                            enemies.push(exploder());
                        }
                    }},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 3)}
                ], ["no-repeat"]),
                () => new Enemy("Orb Walker", 90, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                    {intent: "attack-nerf 10", desc: "deal [DAM10] damage and generate Status cards", effect: attack_status(10, "Burn", 1)}
                ], ["no-repeat"])
            ];
            let possibleElites_act3 = [
                () => new Enemy("Nemesis", 185, [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 2)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
                ], ["randomize"]),
                () => new Enemy("Giant Head", 320, [
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attack-buff 21", desc: "deal [DAM21] damage and gain a buff", effect: attack_buff(21, "Strength", 3)}
                ], ["no-repeat"])
            ];
            let possibleBosses_act3 = [
                () => new Enemy("Time Eater", 666, [
                    {intent: "attack-buff 20", desc: "deal [DAM20] damage", effect: attack_buff(20, "Strength", 3)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(18, [["Vulnerable", 1], ["Weak", 1]])},
                    {intent: "attack-nerf 27", desc: "deal [DAM27] damage and apply a negative effect", effect: attack_apply(27, "Draw Reduction", 2)},
                    {intent: "attack-buff 20", desc: "deal [DAM20] damage", effect: attack_buff(20, "Strength", 3)},
                    {intent: "attack-nerf 27", desc: "deal [DAM27] damage and apply a negative effect", effect: attack_apply(27, "Draw Reduction", 2)}
                ], ["randomize"])
            ];
            
            let enemies = [choice(possibleEnemies.slice(0))()];
            let eliteBattle = false;
            let bossBattle = false;
            let target = enemies[0];
            
            let potionDrop;
            function getPotion() {potions.push(potionDrop);}
            
            function updateStatLine() {
                let statusElemB4 = getId("statusLineB4");
                let deckNumber = getId("deckSize");
                let statusElem = getId("statusLine");
                statusElemB4.innerHTML=(hp<=0.25*maxHp ? "<span style='color: red'>HP: "+hp+"/"+maxHp+"</span>" : "HP: "+hp+"/"+maxHp);
                statusElemB4.innerHTML+=" | "+gold+" gold | Act "+"I".repeat(actNum)+", Floor "+mapY+", A"+getId("ascensionLevel").value;
                deckNumber.innerHTML=deck.length;
                statusElem.innerHTML="<span id='relics'><b>Relics: </b></span>";
                for(let relic of relics) {
                    let relicElem = document.createElement("span");
                    relicElem.setAttribute("class", "tt");
                    relicElem.innerHTML = " | "+relic.name;
                    let relicTooltip = document.createElement("span");
                    relicTooltip.setAttribute("class", "txt");
                    relicTooltip.innerHTML = relic.desc;
                    relicElem.appendChild(relicTooltip);
                    getId("relics").appendChild(relicElem);
                }
                statusElem.innerHTML+= "<br/><br/><span id='potions'><b>Potions: </b></span>";
                for(let potion of potions) {
                    let potionElem = document.createElement("button");
                    potionElem.setAttribute("class", "tt");
                    potionElem.setAttribute("onclick", `let x = function(tgt){${potion.effect}}; if(getId("gameScreen").style.display != "none" || ${(["Fruit Juice", "Blood"].includes(potion.name) ? "true" : "false")}) {x(target);} potions.splice(${potions.indexOf(potion)}, 1); updateHtml();`);
                    potionElem.innerHTML = potion.name+" Potion";
                    let potionTooltip = document.createElement("span");
                    potionTooltip.setAttribute("class", "txt");
                    potionTooltip.innerHTML = potion.desc;
                    potionElem.appendChild(potionTooltip);
                    getId("potions").appendChild(potionElem);
                }
                for(let i=0; i<((getId("ascensionLevel").value >= 11 ? 2 : 3)-potions.length); i++) {
                    let potionElem = document.createElement("button");
                    potionElem.setAttribute("class", "nonbutton");
                    potionElem.innerHTML = "Empty Slot";
                    getId("potions").appendChild(potionElem);
                }
                if(timerRunning) { currentTimer += Date.now() - beforeTime; }
                beforeTime = Date.now();
                let min = Math.floor(currentTimer/60000).toString();
                let sec = Math.floor(currentTimer%60000/1000).toString();
                let sec_100ths = Math.floor(currentTimer%1000/10).toString();
                statusElem.innerHTML += "&nbsp;&nbsp;&nbsp;<button id=\"timer\" class=\""+(timerRunning?"Skill":"Attack")+"\" onclick=\"if(timerRunning){timerRunning=false;getId('timer').setAttribute('class','Attack');updateStatLine();}else{timerRunning=true;getId('timer').setAttribute('class','Skill');updateStatLine();}\"><span style='text-decoration:underline'>T</span>ime: "+min+":"+sec.padStart(2, "0")+"</button>";
                getId("drawPile").innerHTML = "View Draw <span style='text-decoration:underline'>P</span>ile | <span style='color:white'>"+drawPile.length+"</span>";
                getId("discardPile").innerHTML = "View D<span style='text-decoration:underline'>i</span>scard Pile | <span style='color:white'>"+discardPile.length+"</span>";
                getId("exhaustPile").innerHTML = "View <span style='text-decoration:underline'>E</span>xhaust Pile | <span style='color:white'>"+exhaustPile.length+"</span>";
            }
            let timerRunning = true;
            let currentTimer = 0;
            let beforeTime = Date.now();
            async function updateHtml() {
                timerRunning = true;
                updateStatLine();
                if(hasBuff("Strength") > 0 && hasBuff("Minus Strength") > 0) {
                    if(hasBuff("Strength") >= hasBuff("Minus Strength")) {
                        await loseBuff("Strength", hasBuff("Minus Strength"));
                        await loseBuff("Minus Strength");
                    } else {
                        await loseBuff("Minus Strength", hasBuff("Strength"));
                        await loseBuff("Strength");
                    }
                }
                if(hasBuff("Dexterity") > 0 && hasBuff("Minus Dexterity") > 0) {
                    if(hasBuff("Dexterity") >= hasBuff("Minus Dexterity")) {
                        await loseBuff("Dexterity", hasBuff("Minus Dexterity"));
                        await loseBuff("Minus Dexterity");
                    } else {
                        await loseBuff("Minus Dexterity", hasBuff("Dexterity"));
                        await loseBuff("Dexterity");
                    }
                }
                let energyElem = getId("energy");
                energyElem.innerHTML = energy+"/"+maxEnergy+"<span class='txt'>Energy is used to play cards from your hand.</span>";
                if(energy == 0) {energyElem.style.background = "#884";}
                else {energyElem.style.background = "yellow";}
                
                let playerElem = getId("player");
                playerElem.innerHTML = "<span style='font-size:28px;color:#222;'>0</span>Your Hand ("+hand.length+"/10 cards):";
                if(buffs.length > 0) {
                    playerElem.innerHTML += " |";
                    for(let x of buffs) {
                        let buffStuff = "";
                        if(["Block", "Vulnerable", "Weak", "Strength", "Dexterity", "Strength Down", "No Draw", "Combust", "Dark Embrace", "Thorns", "Ritual", "Frail", "Minus Strength", "Minus Dexterity", "Evolve", "Pen Nib", "Feel No Pain", "Fire Breathing", "Metallicize", "Rage", "Rampage", "Barricade", "Berserk", "Brutality", "Double Tap", "Juggernaut", "Regen", "Dexterity Down", "Artifact", "Hex", "Draw Reduction", "Buffer", "Next Turn Block", "Vigor", "Next Turn Energy", "Poison", "Accuracy", "Blur", "Infinite Blades", "Noxious Fumes", "Next Turn Cards", "Enrage", "Tools of the Trade", "After Image", "Envenom", "Burst", "Thousand Cuts"].includes(x.name)) {
                            buffStuff += "<img src='StS/"+x.name.toLowerCase().replace(" ","_").replace(" ","_").replace(" ","_").replace(" ","_")+".png'>";
                        } else {
                            buffStuff += x.name+" ";
                        }
                        let adjustedDamage = function(n) {
                            let newI = n;
                            if(target.hasBuff("Vulnerable")) {newI = Math.round(newI*1.5);}
                            if(hasBuff("Weak")) {newI = Math.round(newI*0.75);}
                            newI += hasBuff("Strength"); newI -= hasBuff("Minus Strength");
                            if(newI > n) {return "<span style='color:lime'>"+newI+"</span>";}
                            else if(newI < n) {return "<span style='color:#f00'>"+newI+"</span>";}
                            else {return newI;}
                        }
                        let adjustedBlock = function(n) {
                            let blockI = n;
                            if(hasBuff("Frail")) {blockI = Math.round(blockI*0.75);}
                            blockI += hasBuff("Dexterity"); blockI -= hasBuff("Minus Dexterity");
                            if(blockI > n) {return "<span style='color:lime'>"+blockI+"</span>";}
                            else if(blockI < n) {return "<span style='color:#f00'>"+blockI+"</span>";}
                            else {return blockI;}
                        }
                        playerElem.innerHTML += "<span class='tt'>"+buffStuff+(x.name.includes("Minus")?"-":"")+x.amt+"<span class='txt'>"+buffDesc[x.name].replace("[DAMT]", adjustedDamage(x.amt)).replace("[BAMT]", adjustedBlock(x.amt)).replace("[AMT]", x.amt).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es"))+"</span></span> ";
                    }
                }
                
                let handElem = getId("hand");
                handElem.innerHTML = "";
                for(let c of hand) {
                    let cardElem = document.createElement("button");
                    let playcard = async () => { await c.play(); }
                    cardElem.onclick = playcard;
                    if(c.flags.includes("unplayable") || energy < c.cost) {cardElem.setAttribute("class", "tt unplayable "+c.type);}
                    else {cardElem.setAttribute("class", "tt "+c.type);}
                    cardElem.innerHTML = c.name;
                    let cardTooltip = document.createElement("span");
                    cardTooltip.setAttribute("class", "txt");
                    
                    let newDesc = c.desc.replace("[BLOCK]", "[DAM"+hasBuff("Block")+"]")
                    .replace("[BLOOD4BLOOD]", 4 - stats.timesLostHp)
                    .replace("[HEAVYBLADE]", "[DAM"+(14+hasBuff("Strength")*2)+"]")
                    .replace("[HEAVYBLADE+]", "[DAM"+(14+hasBuff("Strength")*4)+"]")
                    .replace("[RAMPAGE]", "[DAM"+(8+hasBuff("Rampage"))+"]")
                    .replace("[SHIV]", "[DAM"+(4+hasBuff("Accuracy"))+"]")
                    .replace("[SHIV+]", "[DAM"+(6+hasBuff("Accuracy"))+"]")
                    .replace("[FINISHER]", "[DAM"+(6*stats.attacksThisTurn)+"]")
                    .replace("[FINISHER+]", "[DAM"+(8*stats.attacksThisTurn)+"]");
                    for(let i=1; i<300; i++) {
                        let newI = i;
                        if(target.hasBuff("Vulnerable")) {newI = Math.round(newI*1.5);}
                        if(hasBuff("Weak")) {newI = Math.round(newI*0.75);}
                        if(!hasBuff(c.name)) {newI += hasBuff("Strength"); newI -= hasBuff("Minus Strength");}
                        if(newI > i) {newI = "<span style='color:lime'>"+newI+"</span>";}
                        else if(newI < i) {newI = "<span style='color:#f00'>"+newI+"</span>";}
                        let blockI = i;
                        if(hasBuff("Frail")) {blockI = Math.round(blockI*0.75);}
                        if(!hasBuff(c.name)) {blockI += hasBuff("Dexterity"); blockI -= hasBuff("Minus Dexterity");}
                        if(blockI > i) {blockI = "<span style='color:lime'>"+blockI+"</span>";}
                        else if(blockI < i) {blockI = "<span style='color:#f66'>"+blockI+"</span>";}
                        
                        newDesc = newDesc.replace("[DAM"+i+"]", newI).replace("[BLK"+i+"]", blockI);
                        newDesc = newDesc.replace("[DAM"+i+"]", newI).replace("[BLK"+i+"]", blockI);
                    }
                    cardTooltip.innerHTML = addCircle(c.cost.toString())+" "+c.type+"<br/>"+newDesc;
                    
                    cardElem.appendChild(cardTooltip);
                    handElem.appendChild(cardElem);
                    
                    let helpNumber = document.createElement("span");
                    helpNumber.style.position = "absolute";
                    let coords = cardElem.getBoundingClientRect()
                    helpNumber.style.top = coords.bottom;
                    helpNumber.style.left = coords.left + 0.5 * (coords.right - coords.left) - 5;
                    let ind = hand.indexOf(c) + 1;
                    helpNumber.innerHTML = (ind > 10 ? "" : (ind == 10 ? "0" : ind));
                    handElem.appendChild(helpNumber);
                }
                
                let enemiesElem = getId("enemies");
                enemiesElem.innerHTML = "";
                for(let eIndex in enemies) {
                    let e = enemies[eIndex];
                    if(e.hasBuff("Strength") > 0 && e.hasBuff("Minus Strength") > 0) {
                        if(e.hasBuff("Strength") >= e.hasBuff("Minus Strength")) {
                            await e.loseBuff("Strength", e.hasBuff("Minus Strength"));
                            await e.loseBuff("Minus Strength");
                        } else {
                            await e.loseBuff("Minus Strength", e.hasBuff("Strength"));
                            await e.loseBuff("Strength");
                        }
                    }
                    let enemyElem = document.createElement("span");
                    enemyElem.setAttribute("class", "tt");
                    let enemyButton = document.createElement("button");
                    enemyButton.setAttribute("id", "enemy_"+eIndex);
                    enemyButton.setAttribute("onclick", `target = enemies[${eIndex}]; updateHtml();`);
                    let intentType = e.intent.intent.split(" ")[0];
                    let intentNumber = "";
                    if(e.intent.intent.split(" ")[1]) {
                        if(parseInt(e.intent.intent.split(" ")[1])) {
                            intentNumber = parseInt(e.intent.intent.split(" ")[1]);
                            if(hasBuff("Vulnerable") > 0) {intentNumber = Math.round(intentNumber*1.5);}
                            if(e.hasBuff("Weak") > 0) {intentNumber = Math.round(intentNumber*0.75);}
                            intentNumber += e.hasBuff("Strength");
                            intentNumber -= e.hasBuff("Minus Strength");
                            if(intentNumber >= 20 && e.intent.intent.includes("attacking")) {
                                intentType = "bigattack";
                            }
                        } else {
                            intentNumber = e.intent.intent.split(" ")[1];
                        }
                    }
                    if(e.number == target.number) {
                        enemyButton.setAttribute("class", intentType);
                    } else {
                        enemyButton.setAttribute("class", intentType+" nonbutton");
                    }
                    enemyButton.innerHTML = "<span style='color:white'>"+intentNumber+"</span>&nbsp;"+e.name;
                    enemyElem.appendChild(enemyButton);
                    enemyElem.innerHTML += " HP: "+e.hp+" / "+e.maxHp;
                    if(e.buffs.length > 0) {
                        enemyElem.innerHTML += " |";
                        for(let x of e.buffs) {
                            let buffStuff = "";
                            if(["Block", "Vulnerable", "Weak", "Strength", "Dexterity", "Strength Down", "No Draw", "Combust", "Dark Embrace", "Thorns", "Ritual", "Frail", "Minus Strength", "Minus Dexterity", "Evolve", "Pen Nib", "Feel No Pain", "Fire Breathing", "Metallicize", "Rage", "Rampage", "Barricade", "Berserk", "Brutality", "Double Tap", "Juggernaut", "Regen", "Dexterity Down", "Artifact", "Hex", "Draw Reduction", "Buffer", "Next Turn Block", "Vigor", "Next Turn Energy", "Poison", "Accuracy", "Blur", "Infinite Blades", "Noxious Fumes", "Next Turn Cards", "Enrage", "Tools of the Trade", "After Image", "Envenom", "Burst", "Thousand Cuts"].includes(x.name)) {
                                buffStuff += "<img src='StS/"+x.name.toLowerCase().replace(" ","_").replace(" ","_")+".png'>";
                            } else {
                                buffStuff += x.name+" ";
                            }
                            let adjustedDamage = function(n) {
                                let newI = n;
                                if(hasBuff("Vulnerable")) {newI = Math.round(newI*1.5);}
                                if(e.hasBuff("Weak")) {newI = Math.round(newI*0.75);}
                                newI += e.hasBuff("Strength");
                                newI -= e.hasBuff("Minus Strength");
                                if(newI > n) {return "<span style='color:lime'>"+newI+"</span>";}
                                else if(newI < n) {return "<span style='color:#f00'>"+newI+"</span>";}
                                else {return newI;}
                            }
                            let adjustedBlock = function(n) {
                                let blockI = n;
                                if(e.hasBuff("Frail")) {blockI = Math.round(blockI*0.75);}
                                blockI += e.hasBuff("Dexterity");
                                blockI -= e.hasBuff("Minus Dexterity");
                                if(blockI > n) {return "<span style='color:lime'>"+blockI+"</span>";}
                                else if(blockI < n) {return "<span style='color:#f00'>"+blockI+"</span>";}
                                else {return blockI;}
                            }
                            enemyElem.innerHTML += "<span class='tt'>"+buffStuff+(x.name.includes("Minus")?"-":"")+x.amt+"<span class='txt'>"+buffDesc[x.name].replace("[DAMT]", adjustedDamage(x.amt)).replace("[BAMT]", adjustedBlock(x.amt)).replace("[AMT]", x.amt).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es"))+"</span></span> ";
                        }
                    }
                    let enemyTooltip = document.createElement("span");
                    enemyTooltip.setAttribute("class", "txt");
                    let newDesc = e.intent.desc;
                    for(let i=1; i<300; i++) {
                        let newI = i;
                        if(hasBuff("Vulnerable") > 0) {newI = Math.round(newI*1.5);}
                        if(e.hasBuff("Weak") > 0) {newI = Math.round(newI*0.75);}
                        newI += e.hasBuff("Strength");
                        newI -= e.hasBuff("Minus Strength");
                        if(newI > i) {newI = "<span style='color:lime'>"+newI+"</span>";}
                        else if(newI < i) {newI = "<span style='color:#f00'>"+newI+"</span>";}
                        newDesc = newDesc.replace("[DAM"+i+"]", newI);
                    }
                    enemyTooltip.innerHTML = e.name+" intends to "+newDesc+".";
                    enemyTooltip.innerHTML += e.buffs.length ? ("<br/>" + e.buffs.map(x => x.name+" "+x.amt+" ("+buffDesc[x.name].replace("[AMT]", x.amt).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es"))+")").join("<br/>")) : "";
                    enemyElem.appendChild(enemyTooltip);
                    enemiesElem.appendChild(enemyElem);
                    enemiesElem.appendChild(document.createElement("br"));
                }
                if(enemies.filter(x => x.hp <= 0).length > 0) {
                    enemies = enemies.filter(x => x.hp > 0);
                    updateHtml();
                }
                if(!enemies.includes(target) || !target) {target = enemies[0];}
                if(enemies.length == 0) {
                    music.boss1.pause(); music.boss2.pause(); music.boss3.pause();
                    music.boss1.currentTime = 0; music.boss2.currentTime = 0; music.boss3.currentTime = 0;
                    if(bossBattle) {music.bossDead.play();}
                    else {
                        for(let i=0; i<50; i++) {
                            setTimeout(function(){music.enemy.volume -= 0.01; music.elite.volume -= 0.01;}, i*50);
                        }
                        setTimeout(function(){
                            music.enemy.pause(); music.elite.pause();
                            music.enemy.currentTime = 0; music.elite.currentTime = 0;
                            music.enemy.volume = 0.5; music.elite.volume = 0.5;
                        }, 2000);
                    }
                    getId("rewardsScreen").style.display = "block";
                    getId("goldReward").style.display = "block";
                    getId("cardReward").style.display = "block";
                    getId("gameScreen").style.display = "none";
                    let goldAmt = Math.round(Math.random()*10) + (getId("ascensionLevel").value >= 13 ? 19 : 25);
                    getId("goldReward").innerHTML = goldAmt+" gold";
                    getId("goldReward").setAttribute("onclick", `gold += ${goldAmt}; updateStatLine(); getId('goldReward').style.display = 'none';`);
                    if(Math.random() < 0.5) { // set to 1 (always drop) for testing
                        getId("potionReward").style.display = "block";
                        potionDrop = choice(potionPool);
                        getId("potionReward").innerHTML = potionDrop.name+" Potion";
                        getId("potionReward").setAttribute("onclick", `if(potions.length < (getId("ascensionLevel").value >= 11 ? 2 : 3)){getPotion(); updateStatLine(); getId('potionReward').style.display = 'none';}`);
                    } else {
                        getId("potionReward").style.display = "none";
                    }
                    if(eliteBattle == true) {
                        getId("relicReward").style.display = "block";
                        let newRelic = choice(relicPool)();
                        getId("relicReward").innerHTML = newRelic.name+"<span class='txt'>"+newRelic.desc+"</span>";
                        getId("relicReward").setAttribute("onclick", `let r = new Relic('${newRelic.name}', '${newRelic.desc}', '${newRelic.trigger}', ${newRelic.use}); relics.push(r); if(r.trigger=='on_pickup') {r.effect();} updateStatLine(); getId('relicReward').style.display = 'none';`);
                    } else {
                        getId("relicReward").style.display = "none";
                    }
                    if(bossBattle == true) {
                        getId("bossRelicReward").style.display = "block";
                        getId("bossRelicReward").innerHTML = "Choose a Relic";
                        getId("bossRelicReward").setAttribute("onclick", "addBossRelic('random'); getId('bossRelicReward').style.display = 'none';");
                    } else {
                        getId("bossRelicReward").style.display = "none";
                    }
                }
                if(hp <= 0) {
                    hp = 0;
                    alert("You died! D:\nReload to try again");
                    getId("gameScreen").style.display = "none";
                    music.enemy.pause(); music.elite.pause(); music.boss1.pause(); music.boss2.pause(); music.boss3.pause();
                    music.enemy.currentTime = 0; music.elite.currentTime = 0;
                    music.boss1.currentTime = 0; music.boss2.currentTime = 0; music.boss3.currentTime = 0;
                    music.death.play();
                    timerRunning = false; updateStatusLine();
                }
                let x = document.getElementsByClassName("txt");
                for (t of x) {
                    t.style.left = (mousex+10) + "px";
                    t.style.top = (mousey+10+window.pageYOffset) + "px";
                }
            }
            
            function addShivs(num=1) {
                for(let i=0; i<num; i++) {
                    if(hand.length < 10) {
                        hand.push(new Card("Shiv", 0, "Attack", "Deal [SHIV] damage. Exhaust.", function(e){dealDamage(e,4,true);}, ["exhausted"]));
                    } else {
                        let dn = getId("playerDamageNumber");
                        let GBCR = getId("statusLine").getBoundingClientRect();
                        dn.innerHTML = "Hand Full!";
                        dn.style.top = GBCR.top - 10;
                        dn.style.left = GBCR.left;
                        dn.style.fontSize = "50px";
                        dn.style.color = "yellow";
                        for(let i of playerTimeouts) {clearTimeout(i);}
                        playerTimeouts = [];
                        dn.style.opacity = "1";
                        for(let i=0; i<100; i++) {
                            playerTimeouts.push(setTimeout(function(){
                                let i2 = 100-i; dn.style.transform = "translate(0px, "+(i2*i2*-0.5+i2*-1.5+5049)*(30/5050)+"px)";
                            }, i*5));
                        }
                        for(let i=0; i<50; i++) {
                            playerTimeouts.push(setTimeout(function(){dn.style.opacity = (49-i)/50;}, i*5 + 750));
                        }
                        playerTimeouts.push(setTimeout(function(){playerTimeouts = [];}, 1000));
                    }
                }
            }
            function addShivPluses(num=1) {
                for(let i=0; i<num; i++) {
                    if(hand.length < 10) {
                        hand.push(new Card("Shiv+", 0, "Attack", "Deal [SHIV+] damage. Exhaust.", function(e){dealDamage(e,6,true);}, ["exhausted"]));
                    } else {
                        let dn = getId("playerDamageNumber");
                        let GBCR = getId("statusLine").getBoundingClientRect();
                        dn.innerHTML = "Hand Full!";
                        dn.style.top = GBCR.top - 10;
                        dn.style.left = GBCR.left;
                        dn.style.fontSize = "50px";
                        dn.style.color = "yellow";
                        for(let i of playerTimeouts) {clearTimeout(i);}
                        playerTimeouts = [];
                        dn.style.opacity = "1";
                        for(let i=0; i<100; i++) {
                            playerTimeouts.push(setTimeout(function(){
                                let i2 = 100-i; dn.style.transform = "translate(0px, "+(i2*i2*-0.5+i2*-1.5+5049)*(30/5050)+"px)";
                            }, i*5));
                        }
                        for(let i=0; i<50; i++) {
                            playerTimeouts.push(setTimeout(function(){dn.style.opacity = (49-i)/50;}, i*5 + 750));
                        }
                        playerTimeouts.push(setTimeout(function(){playerTimeouts = [];}, 1000));
                    }
                }
            }
            
            function drawCard(num=1) {
                if(hasBuff("No Draw") > 0) {num=0;}
                for(let x=0; x<num; x++) {
                    if(drawPile.length <= 0) {
                        drawPile = shuffle(discardPile);
                        discardPile = [];
                    }
                    if(drawPile.length > 0 && hand.length < 10) {
                        let toDraw = drawPile.pop(0);
                        hand.push(toDraw);
                        if(toDraw.type == "Status") {
                            drawCard(hasBuff("Evolve"));
                            for(let e of enemies) {
                                dealDamage(e, hasBuff("Fire Breathing"));
                            }
                        }
                    } else if(hand.length >= 10) {
                        let dn = getId("playerDamageNumber");
                        let GBCR = getId("statusLine").getBoundingClientRect();
                        dn.innerHTML = "Hand Full!";
                        dn.style.top = GBCR.top - 10;
                        dn.style.left = GBCR.left;
                        dn.style.fontSize = "50px";
                        dn.style.color = "yellow";
                        for(let i of playerTimeouts) {clearTimeout(i);}
                        playerTimeouts = [];
                        dn.style.opacity = "1";
                        for(let i=0; i<100; i++) {
                            playerTimeouts.push(setTimeout(function(){
                                let i2 = 100-i; dn.style.transform = "translate(0px, "+(i2*i2*-0.5+i2*-1.5+5049)*(30/5050)+"px)";
                            }, i*5));
                        }
                        for(let i=0; i<50; i++) {
                            playerTimeouts.push(setTimeout(function(){dn.style.opacity = (49-i)/50;}, i*5 + 750));
                        }
                        playerTimeouts.push(setTimeout(function(){playerTimeouts = [];}, 1000));
                    }
                }
            }
            
            async function startTurn() {
                if(hasBuff("Draw Reduction") > 0) {
                    drawCard(4); await loseBuff("Draw Reduction", 1);
                } else {
                    drawCard(5 + hasBuff("Next Turn Cards"));
                    await loseBuff("Next Turn Cards");
                }
                if(hasBuff("Infinite Blades") > 0) {addShivs(hasBuff("Infinite Blades"));}
                for(let relic of relics) {
                    if(relic.name == "Ice Cream") {
                        await gainBuff("Next Turn Energy", energy);
                    }
                }
                energy = maxEnergy + hasBuff("Berserk") + hasBuff("Next Turn Energy");
                await loseBuff("Next Turn Energy");
                if(stats.attacksThisTurn == 0) {
                    for(let relic of relics) {if(relic.trigger == "no_attacks") {relic.effect();}}
                }
                if(stats.rested == true) {
                    stats.rested = false;
                    for(let relic of relics) {if(relic.trigger == "rest") {relic.effect();}}
                }
                for(let r of relics) {if(r.trigger == "turn_start") {r.effect();}}
                stats.attacksThisTurn = 0;
                stats.skillsThisTurn = 0;
                if(hasBuff("Barricade")==0 && hasBuff("Blur")==0){await loseBuff("Block");}
                await loseBuff("Blur", 1);
                if(hasBuff(".") > 0) {await loseBuff(".");} else {await loseBuff("Vulnerable", 1);}
                if(hasBuff("Metallicize")>0){await gainBuff("Block", hasBuff("Metallicize"));}
                if(hasBuff("Next Turn Block")>0){await gainBuff("Block", hasBuff("Next Turn Block")); await loseBuff("Next Turn Block");}
                if(hasBuff("Brutality")>0){hp -= 1; drawCard(hasBuff("Brutality"));}
                if(hasBuff("Tools of the Trade")>0){
                    drawCard(hasBuff("Tools of the Trade"));
                    let chosen = await choose(hand, "Choose a card to discard.");
                    if(chosen) {
                        discardPile.push(chosen);
                        hand.splice(hand.indexOf(chosen), 1);
                        updateHtml();
                    }
                }
                if(hasBuff("Poison")>0) {hp -= hasBuff("Poison"); await loseBuff("Poison", 1);}
                if(hasBuff("Noxious Fumes")>0){for(let e of enemies){await e.gainBuff("Poison", hasBuff("Noxious Fumes"));}}
                updateHtml();
            }
            
            async function endTurn() {
                for(let c of hand) {
                    if(c.flags.includes("ethereal")) {exhaustPile.push(c);}
                    else {discardPile.push(c);}
                    if(c.flags.includes("burning")) {hp -= 1;}
                }
                for(let r of relics) {if(r.trigger == "turn_end") {r.effect();}}
                hand = [];
                if(hasBuff("Combust") > 0) {
                    hp -= 1;
                    for(let e of enemies) {dealDamage(e, hasBuff("Combust"));}
                }
                await loseBuff("Weak", 1);
                await loseBuff("Frail", 1);
                await loseBuff("No Draw", 1);
                hp = Math.min(maxHp, hp + hasBuff("Regen"));
                await loseBuff("Regen", 1);
                await loseBuff("Rage");
                await gainBuff("Strength", hasBuff("Ritual"));
                await loseBuff("Strength", hasBuff("Strength Down"));
                await loseBuff("Strength Down");
                await loseBuff("Dexterity", hasBuff("Dexterity Down"));
                await loseBuff("Dexterity Down");
                for(let e of enemies) {
                    if(e.hasBuff("Barricade")==0){await e.loseBuff("Block");}
                    if(e.hasBuff("Metallicize")>0){await e.gainBuff("Block", await e.hasBuff("Metallicize"));}
                    if(e.hasBuff("Poison")>0) {e.hp -= e.hasBuff("Poison"); await e.loseBuff("Poison", 1);}
                    let func = async function() {await e.attack(); updateHtml();}
                    if(e.hp > 0){func();}
                    await e.loseBuff("Vulnerable", 1);
                    await e.loseBuff("Weak", 1);
                    e.hp = Math.min(e.maxHp, e.hp + e.hasBuff("Regen"));
                    await e.loseBuff("Regen", 1);
                    await e.gainBuff("Strength", e.hasBuff("Ritual"));
                    await e.loseBuff("Strength", e.hasBuff("Strength Down"));
                    await e.loseBuff("Strength Down");
                    await e.loseBuff("Dexterity", e.hasBuff("Dexterity Down"));
                    await e.loseBuff("Dexterity Down");
                }
                updateHtml();
                await startTurn();
            }
            // This has to be at the bottom because it modifies everything else
            getId("ascensionLevel").addEventListener("change", function() {
                let lv = getId("ascensionLevel").value;
                if(lv >= 1) {randomThing = () => choice(["elite","enemy","enemy","enemy","shop&nbsp;","elite","rest&nbsp;"]);}
                if(lv >= 2) {
                    possibleEnemies = [
                () => new Enemy("Cultist", 50, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 4)},
                    {intent: "attacking 2", desc: "deal [DAM2] damage", effect: attack(2)}
                ], ["no-repeat"]),
                () => new Enemy("Jaw Worm", 40, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "attack-block 6", desc: "deal [DAM6] damage and block", effect: attack_block(6, 5)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 2)}
                ], ["randomize"]),
                () => new Enemy("Louse", 35, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 2)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
                ], ["randomize"]),
                () => new Enemy("Spike Slime", 45, [
                    {intent: "attack-nerf 11", desc: "deal [DAM11] damage and generate Status cards", effect: attack_status(11, "Slimed", 1)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 1)}
                ]),
                () => new Enemy("Gremlin", 25, [
                    {intent: "attack-nerf 11", desc: "deal [DAM11] damage and apply a negative effect", effect: attack_apply(11, "Weak", 1)}
                ])
                    ];
                    possibleEnemies_act2 = [
                () => new Enemy("Spheric Guardian", 60, [
                    {intent: "block-buff +", desc: "gain <b>multiple buffs</b>", effect: multi_buff([["Barricade", 1], ["Block", 25], ["Artifact", 3]])},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Frail", 5)},
                    {intent: "attack-block 12", desc: "deal [DAM12] damage and block", effect: attack_block(12, 7)}
                ], ["no-repeat"]),
                () => new Enemy("The Chosen", 95, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: apply("Hex", 1)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Vulnerable", 1)},
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Vulnerable", 1)}
                ]),
                () => new Enemy("Shelled Parasite", 70, [
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 10)},
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 10)},
                    {intent: "attack-nerf 14", desc: "deal [DAM14] damage and apply a negative effect", effect: attack_apply(14, "Frail", 2)}
                ])
                    ];
                    possibleEnemies_act3 = [
                () => new Enemy("Huge Jaw Worm", 70, [
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(8, "Strength", 2)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(8, "Strength", 2)},
                    {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 6)}
                ]),
                () => new Enemy("Spiker", 50, [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                        if(enemies.length <= 8) {
                            let exploder = () => new Enemy("Exploder", 30, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "unknown 7", desc: "deal [DAM7] damage and get ready to explode", effect: attack(7)},
                                {intent: "unknown 7", desc: "deal [DAM7] damage and get ready to explode", effect: attack(7)},
                                {intent: "unknown 24", desc: "deal [DAM24] damage and die", effect: async function(me){
                                    enemies.splice(enemies.indexOf(me), 1); await me.dealDamage(24);}
                                }
                            ], ["no-repeat"]);
                            let repulsor = () => new Enemy("Repulsor", 30, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
                            ], ["no-repeat"]);
                            enemies.push(repulsor());
                            enemies.push(exploder());
                        }
                    }},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 3)}
                ], ["no-repeat"]),
                () => new Enemy("Orb Walker", 90, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 4)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and generate Status cards", effect: attack_status(8, "Burn", 1)}
                ], ["no-repeat"])
                    ];
                }
                if(lv >= 3) {
                    possibleElites = [
                () => new Enemy("Gremlin Nob", 85, [
                    {intent: "buffing +", desc: "gain a <b>powerful buff</b>", effect: buff("Enrage", 2)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(7, "Vulnerable", 1)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)}
                ], ["no-repeat"]),
                () => new Enemy("Lagavulin", 110, [
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "blocking", desc: "block", effect: block(8)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: multi_apply([["Minus Strength", 1], ["Minus Dexterity", 1]])}
                ])
                    ];
                    possibleElites_act2 = [
                () => new Enemy("Book of Stabbing", 160, [
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Strength", 5)},
                    {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Strength", 5)}
                ]),
                () => new Enemy("Gremlin Leader", 150, [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 4)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        let gremlins = [
                            () => new Enemy("Fat Gremlin", 15, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attack-nerf 3", desc: "deal [DAM3] damage and apply a negative effect", effect: attack_apply(3, "Weak", 1)}
                            ]),
                            () => new Enemy("Mad Gremlin", 20, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                            ]),
                            () => new Enemy("Shield Gremlin", 15, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)},
                                {intent: "blocking", desc: "shield a random enemy", effect: block_random(7)}
                            ]),
                            () => new Enemy("Sneaky Gremlin", 10, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}
                            ]),
                            () => new Enemy("Wizard Gremlin", 25, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "unknown", desc: "charge a powerful attack", effect: passTurn()},
                                {intent: "unknown", desc: "charge a powerful attack", effect: passTurn()},
                                {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)}
                            ])
                        ];
                        if(enemies.length <= 8) {enemies.push(choice(gremlins)()()); enemies.push(choice(gremlins)()());}
                    }}
                ], ["randomize"])
                    ];
                    possibleElites_act3 = [
                () => new Enemy("Nemesis", 185, [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 36", desc: "deal [DAM36] damage", effect: attack(36)}
                ], ["randomize"]),
                () => new Enemy("Giant Head", 320, [
                    {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 3)}
                ], ["no-repeat"])
                    ];
                }
                if(lv >= 4) {
                    possibleBosses = [
                () => new Enemy("Slime Boss", 190, [
                    {intent: "meganerf", desc: "generate <b>many Status cards</b>", effect: status("Slimed", 3)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: function(me){}},
                    {intent: "attacking 42", desc: "deal [DAM42] damage", effect: attack(42)}
                ])
                    ];
                    possibleBosses_act2 = [
                () => new Enemy("The Champ", 530, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 4)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(15, "Metallicize", 3)},
                    {intent: "meganerf", desc: "apply <b>many negative effects</b>", effect: multi_apply([["Vulnerable", 2], ["Weak", 2], ["Frail", 2]])},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)}
                ], ["randomize"])
                    ];
                    possibleBosses_act3 = [
                () => new Enemy("Time Eater", 666, [
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 4)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(18, [["Vulnerable", 1], ["Weak", 1]])},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 2)},
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 4)},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 2)}
                ], ["randomize"])
                    ];
                }
                if(lv >= 6) {hp = 0.9 * maxHp;}
                if(lv >= 7) {
                    possibleEnemies = [
                () => new Enemy("Cultist", 60, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 4)},
                    {intent: "attacking 2", desc: "deal [DAM2] damage", effect: attack(2)}
                ], ["no-repeat"]),
                () => new Enemy("Jaw Worm", 50, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "attack-block 6", desc: "deal [DAM6] damage and block", effect: attack_block(6, 6)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 2)}
                ], ["randomize"]),
                () => new Enemy("Louse", 40, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 2)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
                ], ["randomize"]),
                () => new Enemy("Spike Slime", 55, [
                    {intent: "attack-nerf 11", desc: "deal [DAM11] damage and generate Status cards", effect: attack_status(11, "Slimed", 1)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 1)}
                ]),
                () => new Enemy("Gremlin", 30, [
                    {intent: "attack-nerf 11", desc: "deal [DAM11] damage and apply a negative effect", effect: attack_apply(11, "Weak", 1)}
                ])
                    ];
                    possibleEnemies_act2 = [
                () => new Enemy("Spheric Guardian", 70, [
                    {intent: "block-buff +", desc: "gain <b>multiple buffs</b>", effect: multi_buff([["Barricade", 1], ["Block", 30], ["Artifact", 3]])},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Frail", 5)},
                    {intent: "attack-block 12", desc: "deal [DAM12] damage and block", effect: attack_block(12, 8)}
                ], ["no-repeat"]),
                () => new Enemy("The Chosen", 115, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: apply("Hex", 1)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Vulnerable", 1)},
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Vulnerable", 1)}
                ]),
                () => new Enemy("Shelled Parasite", 85, [
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 12)},
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 12)},
                    {intent: "attack-nerf 14", desc: "deal [DAM14] damage and apply a negative effect", effect: attack_apply(14, "Frail", 2)}
                ])
                    ];
                    possibleEnemies_act3 = [
                () => new Enemy("Huge Jaw Worm", 85, [
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(10, "Strength", 2)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(10, "Strength", 2)},
                    {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 7)}
                ]),
                () => new Enemy("Spiker", 60, [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                        if(enemies.length <= 8) {
                            let exploder = () => new Enemy("Exploder", 35, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "unknown 7", desc: "deal [DAM7] damage and get ready to explode", effect: attack(7)},
                                {intent: "unknown 7", desc: "deal [DAM7] damage and get ready to explode", effect: attack(7)},
                                {intent: "unknown 24", desc: "deal [DAM24] damage and die", effect: async function(me){
                                    enemies.splice(enemies.indexOf(me), 1); await me.dealDamage(24);}
                                }
                            ], ["no-repeat"]);
                            let repulsor = () => new Enemy("Repulsor", 35, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
                            ], ["no-repeat"]);
                            enemies.push(repulsor());
                            enemies.push(exploder());
                        }
                    }},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 3)}
                ], ["no-repeat"]),
                () => new Enemy("Orb Walker", 110, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 4)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and generate Status cards", effect: attack_status(8, "Burn", 1)}
                ], ["no-repeat"])
                    ];
                }
                if(lv >= 8) {
                    possibleElites = [
                () => new Enemy("Gremlin Nob", 100, [
                    {intent: "buffing +", desc: "gain a <b>powerful buff</b>", effect: buff("Enrage", 2)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(7, "Vulnerable", 1)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)}
                ], ["no-repeat"]),
                () => new Enemy("Lagavulin", 130, [
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "blocking", desc: "block", effect: block(10)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: multi_apply([["Minus Strength", 1], ["Minus Dexterity", 1]])}
                ])
                    ];
                    possibleElites_act2 = [
                () => new Enemy("Book of Stabbing", 190, [
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Strength", 5)},
                    {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Strength", 5)}
                ]),
                () => new Enemy("Gremlin Leader", 180, [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 4)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        let gremlins = [
                            () => new Enemy("Fat Gremlin", 20, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attack-nerf 3", desc: "deal [DAM3] damage and apply a negative effect", effect: attack_apply(3, "Weak", 1)}
                            ]),
                            () => new Enemy("Mad Gremlin", 25, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                            ]),
                            () => new Enemy("Shield Gremlin", 20, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)},
                                {intent: "blocking", desc: "shield a random enemy", effect: block_random(7)}
                            ]),
                            () => new Enemy("Sneaky Gremlin", 10, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}
                            ]),
                            () => new Enemy("Wizard Gremlin", 30, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "unknown", desc: "charge a powerful attack", effect: passTurn()},
                                {intent: "unknown", desc: "charge a powerful attack", effect: passTurn()},
                                {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)}
                            ])
                        ];
                        if(enemies.length <= 8) {enemies.push(choice(gremlins)()); enemies.push(choice(gremlins)());}
                    }}
                ], ["randomize"])
                    ];
                    possibleElites_act3 = [
                () => new Enemy("Nemesis", 220, [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 36", desc: "deal [DAM36] damage", effect: attack(36)}
                ], ["randomize"]),
                () => new Enemy("Giant Head", 385, [
                    {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 3)}
                ], ["no-repeat"])
                    ];
                }
                if(lv >= 9) {
                    possibleBosses = [
                () => new Enemy("Slime Boss", 230, [
                    {intent: "meganerf", desc: "generate <b>many Status cards</b>", effect: status("Slimed", 3)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: function(me){}},
                    {intent: "attacking 42", desc: "deal [DAM42] damage", effect: attack(42)}
                ])
                    ];
                    possibleBosses_act2 = [
                () => new Enemy("The Champ", 635, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 4)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(18, "Metallicize", 3)},
                    {intent: "meganerf", desc: "apply <b>many negative effects</b>", effect: multi_apply([["Vulnerable", 2], ["Weak", 2], ["Frail", 2]])},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)}
                ], ["randomize"])
                    ];
                    possibleBosses_act3 = [
                () => new Enemy("Time Eater", 800, [
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 4)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(22, [["Vulnerable", 1], ["Weak", 1]])},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 2)},
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 4)},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 2)}
                ], ["randomize"])
                    ];
                }
                if(lv >= 10) {deck.push(new Card("Ascenders Bane", 0, "Curse", "Unplayable.", function(enemy){}, ["unplayable"]))}
                if(lv >= 14) {maxHp -= 5; hp -= 5;}
                if(lv >= 15) {randomThing = () => choice(["elite","elite","enemy","enemy","enemy","enemy","enemy","shop&nbsp;","elite","rest&nbsp;"]);}
                if(lv >= 17) {
                    deck.push(new Card("Strike", 1, "Attack", "Deal [DAM6] damage.", function(enemy){dealDamage(enemy,6);}))
                    deck.push(new Card("Defend", 1, "Skill", "Gain [BLK5] Block.", async function(enemy){await gainBuff("Block",5);}))
                }
                if(lv >= 18) {
                    possibleEnemies = [
                () => new Enemy("Cultist", 60, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 4)},
                    {intent: "attacking 2", desc: "deal [DAM2] damage", effect: attack(2)},
                    {intent: "attacking 2", desc: "deal [DAM2] damage", effect: attack(2)},
                    {intent: "attacking 2", desc: "deal [DAM2] damage", effect: attack(2)},
                    {intent: "attacking 2", desc: "deal [DAM2] damage", effect: attack(2)},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 4)},
                    {intent: "attacking 2", desc: "deal [DAM2] damage", effect: attack(2)}
                ], ["no-repeat"]),
                () => new Enemy("Jaw Worm", 50, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "attack-block 6", desc: "deal [DAM6] damage and block", effect: attack_block(6, 6)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 2)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 2)}
                ], ["randomize"]),
                () => new Enemy("Louse", 40, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 2)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 3)}
                ], ["randomize"]),
                () => new Enemy("Spike Slime", 55, [
                    {intent: "attack-nerf 11", desc: "deal [DAM11] damage and generate Status cards", effect: attack_status(11, "Slimed", 1)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 2)}
                ]),
                () => new Enemy("Gremlin", 30, [
                    {intent: "attack-nerf 11", desc: "deal [DAM11] damage and apply a negative effect", effect: attack_apply(11, "Weak", 1)}
                ])
                    ];
                    possibleEnemies_act2 = [
                () => new Enemy("Spheric Guardian", 70, [
                    {intent: "block-buff +", desc: "gain <b>multiple buffs</b>", effect: multi_buff([["Barricade", 1], ["Block", 30], ["Artifact", 4]])},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Frail", 5)},
                    {intent: "attack-block 12", desc: "deal [DAM12] damage and block", effect: attack_block(12, 8)}
                ], ["no-repeat"]),
                () => new Enemy("The Chosen", 115, [
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: apply("Hex", 2)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Vulnerable", 1)},
                    {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)},
                    {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Vulnerable", 1)}
                ]),
                () => new Enemy("Shelled Parasite", 85, [
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 12)},
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 12)},
                    {intent: "attack-nerf 14", desc: "deal [DAM14] damage and apply a negative effect", effect: attack_apply(14, "Frail", 3)}
                ])
                    ];
                    possibleEnemies_act3 = [
                () => new Enemy("Huge Jaw Worm", 85, [
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(10, "Strength", 2)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(10, "Strength", 2)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(10, "Strength", 2)},
                    {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 7)}
                ]),
                () => new Enemy("Spiker", 60, [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                        if(enemies.length <= 8) {
                            let exploder = () => new Enemy("Exploder", 35, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "unknown 7", desc: "deal [DAM7] damage and get ready to explode", effect: attack(7)},
                                {intent: "unknown 7", desc: "deal [DAM7] damage and get ready to explode", effect: attack(7)},
                                {intent: "unknown 24", desc: "deal [DAM24] damage and die", effect: async function(me){
                                    enemies.splice(enemies.indexOf(me), 1); await me.dealDamage(24);}
                                }
                            ], ["no-repeat"]);
                            let repulsor = () => new Enemy("Repulsor", 35, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 3)}
                            ], ["no-repeat"]);
                            enemies.push(repulsor());
                            enemies.push(exploder());
                        }
                    }},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 4)}
                ], ["no-repeat"]),
                () => new Enemy("Orb Walker", 110, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 4)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and generate Status cards", effect: attack_status(8, "Burn", 2)}
                ], ["no-repeat"])
                    ];
                }
                if(lv >= 19) {
                    possibleElites = [
                () => new Enemy("Gremlin Nob", 100, [
                    {intent: "buffing +", desc: "gain a <b>powerful buff</b>", effect: buff("Enrage", 3)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(7, "Vulnerable", 1)},
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)}
                ], ["no-repeat"]),
                () => new Enemy("Lagavulin", 130, [
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "blocking", desc: "block", effect: block(10)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: multi_apply([["Minus Strength", 2], ["Minus Dexterity", 1]])}
                ])
                    ];
                    possibleElites_act2 = [
                () => new Enemy("Book of Stabbing", 190, [
                    {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)},
                    {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Strength", 5)},
                    {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Strength", 5)},
                    {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Strength", 5)}
                ]),
                () => new Enemy("Gremlin Leader", 180, [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 4)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        let gremlins = [
                            () => new Enemy("Fat Gremlin", 20, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attack-nerf 3", desc: "deal [DAM3] damage and apply a negative effect", effect: attack_apply(3, "Weak", 1)}
                            ]),
                            () => new Enemy("Mad Gremlin", 25, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                            ]),
                            () => new Enemy("Shield Gremlin", 20, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)},
                                {intent: "blocking", desc: "shield a random enemy", effect: block_random(7)}
                            ]),
                            () => new Enemy("Sneaky Gremlin", 10, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}
                            ]),
                            () => new Enemy("Wizard Gremlin", 30, [
                                {intent: "unknown", desc: "Uh-oh! This is a bug! XD", effect: passTurn()},
                                {intent: "unknown", desc: "charge a powerful attack", effect: passTurn()},
                                {intent: "unknown", desc: "charge a powerful attack", effect: passTurn()},
                                {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)}
                            ], ["no-repeat"])
                        ];
                        if(enemies.length <= 8) {enemies.push(choice(gremlins)()); enemies.push(choice(gremlins)());}
                    }}
                ], ["randomize"])
                    ];
                    possibleElites_act3 = [
                () => new Enemy("Nemesis", 220, [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 3)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 36", desc: "deal [DAM36] damage", effect: attack(36)}
                ], ["randomize"]),
                () => new Enemy("Giant Head", 385, [
                    {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)},
                    {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)},
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 3)}
                ], ["no-repeat"])
                    ];
                }
                if(lv >= 20) {
                    possibleBosses = [
                () => new Enemy("Slime Boss", 230, [
                    {intent: "meganerf", desc: "generate <b>many Status cards</b>", effect: status("Slimed", 4)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: function(me){}},
                    {intent: "attacking 42", desc: "deal [DAM42] damage", effect: attack(42)}
                ])
                    ];
                    possibleBosses_act2 = [
                () => new Enemy("The Champ", 635, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 4)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(18, "Metallicize", 3)},
                    {intent: "meganerf", desc: "apply <b>many negative effects</b>", effect: multi_apply([["Vulnerable", 3], ["Weak", 3], ["Frail", 3]])},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)},
                    {intent: "attacking 19", desc: "deal [DAM19] damage", effect: attack(19)}
                ], ["randomize"])
                    ];
                    possibleBosses_act3 = [
                () => new Enemy("Time Eater", 800, [
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 4)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(22, [["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 2)},
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 4)},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 2)}
                ], ["randomize"])
                    ];
                }
            });
            window.setInterval(updateStatLine, 1000);
        </script>
    </body>
</html>
