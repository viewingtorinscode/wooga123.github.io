<html id="html" class="default">
    <head>
        <!--<title>Clone of Slay the Spire  (Shop bug fixed!)</title>-->
        <title>Media Literacy &amp; Dystopian Lit Circles - Google Slides</title>
        <!--<link rel="shortcut icon" href="./StS/intent-attack.png">-->
        <link rel="shortcut icon" href="https://ssl.gstatic.com/docs/presentations/images/favicon5.ico">
        <style>
            html, input, button {
                font-family: monospace;
                color: white;
            }
            html, input {background: #222;}
            html.aqua, html.aqua input {background: #005;}
            html.black, html.black input {background: black;}
            button {
                border: 2px solid lime;
                margin: 1px;
                cursor: pointer;
                background: black;
                color: lime;
                border-radius: 3px;
            }
            button:not(.notrans) {
                transition: 0.3s ease;
            }
            html.aqua button {
                border: 2px solid aqua;
                color: aqua;
            }
            #damage {
                opacity: 0;
                background: #f00;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }
            .nonbutton {border: 2px solid green; color: green;}
            html.aqua .nonbutton {border: 2px solid #007; color: #007;}
            html button.Attack {border: 2px solid red; color: red;}
            html button.Skill {border: 2px solid skyblue; color: skyblue;}
            html button.Power {border: 2px solid yellow; color: yellow;}
            html button.Status {border: 2px solid lightgreen; color: lightgreen;}
            html button.Curse {border: 2px solid #666; color: #666;}
            html button.unplayable {border: 2px solid #555; color: #555;}
            button:hover:not(.unplayable) {background-color: #444;}
            button:not(.restSite):hover > span {font-size: 13px;}
            table {width: 100%;}
            .tt {user-select: none;}
            .txt {
                position: absolute;
                background: #888;
                color: black;
                display: none;
                text-align: left;
                border-radius: 5px;
                margin-left: 10px;
                padding: 5px;
                z-index: 2;
            }
            .tt:hover > .txt {display: inline;}
            #energy, #player {display: inline;}
            #energy {
                border: 2px solid black;
                border-radius: 20px;
                padding: 3px;
                color: black;
                background: yellow;
            }
            #playerTd {width: 750px;}
            #rewardsScreen {text-align: center; width: 100%;}
            #rewardsScreen > button {text-align: center; width: 100%; border: none;}
            #mapScreen {margin-left: 42%; width: 58%;}
            .attacking::before { content: url(StS/intent-attack.png); }
            .bigattack::before { content: url(StS/intent-bigattack.png); }
            .blocking::before { content: url(StS/intent-block.png); }
            .buffing::before { content: url(StS/intent-buff.png); }
            .nerfing::before { content: url(StS/intent-nerf.png); }
            .meganerf::before { content: url(StS/intent-meganerf.png); }
            .unknown::before { content: url(StS/intent-unknown.png); }
            .attack-block::before { content: url(StS/intent-attackblock.png); }
            .block-buff::before { content: url(StS/intent-blockbuff.png); }
            .attack-nerf::before { content: url(StS/intent-attacknerf.png); }
            .attack-buff::before { content: url(StS/intent-attackbuff.png); }
            .block-nerf::before { content: url(StS/intent-blocknerf.png); }
            .stunned::before { content: url(StS/intent-stunned.png); }
            #cardModal, #bossModal, #selectionModal, #msModal {
                position: fixed;
                z-index: 1;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0,0,0,0.7);
            }
            #cardModalContent, #bossModalContent, #selectionModalContent, #msModalContent {
                background-color: #555;
                margin: 15% auto;
                padding: 20px;
                width: 80%;
            }
            #h1 {
                text-align: center;
                font-size: 30px;
                width: 80%;
                animation: grow 0.8s infinite;
                margin: 0px 0px 30px 140px;
            }
            html button.titleButton {
                text-align: center;
                width: 100%;
                border: none;
                font-size: 16px;
            }
            html .titleButton:hover {
                font-size: 21px;
                color: black;
                background: lime;
                font-weight: bold;
            }
            html.aqua .titleButton:hover {background: aqua;}
            #cardDesc {
                display: flex;
                flex-direction: row;
                justify-content: center;
                width: 100%;
            }
            #upgradePart1, #upgradePart2 {
                flex: 5;
                background: #555;
                border-radius: 5px;
                padding: 10px;
            }
            #middleArrow {
                flex: 1;
                text-align: center;
                font-size: 50px;
            }
            .selection {font-weight: bold;}
            #restScreen, #eventScreen, #merchantScreen {text-align: center;}
            .restSite, .eventButton {
                display: inline-block;
                padding: 10px;
                margin: 10px;
                font-size: 16px;
            }
            .restSite .txt {font-size: 13px;}
            #rester {background: green;}
            #smither {background: darkred;}
            #selectionModal {z-index: 100;}
            #merchantScreen {
                display: flex;
            }
            .shopCard, .shopRelic, #crElem {
                display: inline-block;
                padding: 0px 0px 20px 0px;
                width: 15%;
            }
            .shopCard button, .shopRelic button, #crElem button {
                padding: 10px;
                font-size: 16px;
            }
            @keyframes grow {
                0%    { transform: scale(1);    }
                12.5% { transform: scale(1.08); }
                25%   { transform: scale(1.14); }
                37.5% { transform: scale(1.18); }
                50%   { transform: scale(1.20); }
                62.5% { transform: scale(1.18); }
                75%   { transform: scale(1.14); }
                87.5% { transform: scale(1.08); }
                100%  { transform: scale(1);    }
            }
            @keyframes boing {
                0%    { transform: translate(0px, 0px);   }
                12.5% { transform: translate(0px,-8px);   }
                25%   { transform: translate(0px, -14px); }
                37.5% { transform: translate(0px, -18px); }
                50%   { transform: translate(0px, -20px); }
                62.5% { transform: translate(0px, -18px); }
                75%   { transform: translate(0px, -14px); }
                87.5% { transform: translate(0px, -8px);  }
                100%  { transform: translate(0px, 0px);   }
            }
            @keyframes wiggle {
                0%  { transform: rotate(10deg);  }
                10% { transform: rotate(2deg);   }
                20% { transform: rotate(-4deg);  }
                30% { transform: rotate(-8deg);  }
                40% { transform: rotate(-10deg); }
                50% { transform: rotate(-10deg); }
                60% { transform: rotate(-2deg);  }
                70% { transform: rotate(4deg);   }
                80% { transform: rotate(8deg);   }
                90% { transform: rotate(10deg);  }
                100%{ transform: rotate(10deg);  }
            }
        </style>
    </head>
    <body>
        <div id="damage"></div>
        <div id="msModal" style="display: none;">
            <div id="msModalContent"></div>
        </div>
        <div id="selectionModal" style="display: none;">
            <div id="selectionModalContent"></div>
        </div>
        <div id="cardModal" style="display: none;">
            <div id="cardModalContent">
                <p>Choose a card to add to your deck:</p>
                <button id="modalCard1" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(0);"></button>
                <button id="modalCard2" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(1);"></button>
                <button id="modalCard3" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(2);"></button>
                <button id="modalSkipCard" class="Skill" onclick="getId('cardModal').style.display = 'none'; ifRelic('Singing Bowl', function(){maxHp += 2; hp += 2;}); finishAddCard(-1);">Skip</button>
            </div>
        </div>
        <div id="bossModal" style="display: none;">
            <div id="bossModalContent">
                <p>Choose a Relic to obtain:</p>
                <button id="modalRelic1" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(0);"></button>
                <button id="modalRelic2" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(1);"></button>
                <button id="modalRelic3" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(2);"></button>
                <button id="modalSkipRelic" class="Skill" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(-1);">Skip</button>
            </div>
        </div>
        
        <span id="statusContainer" style="display: none;">
            <span id="statusLineB4"></span>
            <button onclick='d=deck.map(x=>x.name);o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);'>View <span style="text-decoration:underline">D</span>eck | <span style="color:white" id="deckSize">10</span></button>
            <span id="statusLine"></span>
        </span>
        <br /><br />
        <div id="introScreen" style="width: 100%;">
            <h1 id="h1">
                Clone of Slay The Spire
                <span class="Power" style="font-size:17px;border:none;" id="funText"><br/><span style="color: red">JavaScript syntax error detected!</span></span>
            </h1>
            <button class="titleButton" onclick="beginGame()">Play <span style="font-size: 13px;color:red;">(SOUND WARNING!!!)</span></button>
            <button class="titleButton" onclick="getId('rulesScreen').style.display = 'block'; getId('ascensionScreen').style.display = 'none'; getId('keyScreen').style.display = 'none'; getId('settingsScreen').style.display = 'none';">Instructions <span style="font-size: 13px;color:red;">(important)</span></button>
            <button class="titleButton" onclick="getId('keyScreen').style.display = 'block'; getId('ascensionScreen').style.display = 'none'; getId('rulesScreen').style.display = 'none'; getId('settingsScreen').style.display = 'none';">Keybinds</button>
            <button class="titleButton" onclick="getId('ascensionScreen').style.display = 'block'; getId('keyScreen').style.display = 'none'; getId('rulesScreen').style.display = 'none'; getId('settingsScreen').style.display = 'none';">Ascension</button>
            <button class="titleButton" onclick="getId('ascensionScreen').style.display = 'none'; getId('keyScreen').style.display = 'none'; getId('rulesScreen').style.display = 'none'; getId('settingsScreen').style.display = 'block';">Settings</button>

            <pre id="rulesScreen" style="display: none;">
When you begin you will be on the Map. Click a highlighted node to travel there.
In combat, your cards will be shown on the left and the enemies will be on the right.
Click a card to play it. Depending on the card, it might target the selected enemy, all enemies, or yourself.
You should watch the enemies' intents and play cards accordingly.

A rest node is extremely useful, allowing you to heal or upgrade a card.
A shop sells cards and relics, gather gold from enemies to buy them.
Elites are stronger enemies that drop rare cards and a helpful Relic on defeat.

One last tip: Many things can be hovered to see their description.
            </pre>
            <pre id="keyScreen" style="display: none;">
Number          select from dialog / buy cards / play cards / travel
D               view and copy deck
T               pause/resume timer
E               end turn
O               change target
P               draw pile
I               discard pile
X               exhaust pile
, . /           use potion
Space           claim reward
C               continue (from shop, combat, rest)
R/S             rest/smith at rest sites
            </pre>
            <pre id="ascensionScreen" style="display: none;">
Your Ascension Level adds various modifiers to the game. The current max is level 20.
Note that the modifiers from lower levels stack.
Modifiers:
* 1 - Elites spawn more often.
* 2 - Normal enemies are stronger.
* 3 - Elites are stronger.
* 4 - Bosses are stronger.
* 5 - Heal less after bosses.
* 6 - Start the run damaged.
* 7 - Normal enemies are tougher.
* 8 - Elites are tougher.
* 9 - Bosses are tougher.
* 10- Start the run cursed.
* 11- One less potion slot.
* 12- No rares from elites.
* 13- Less money.
* 14- Lower Max HP.
* 15- Fewer rests and shops.
* 16- Higher prices.
* 17- Bigger starting deck.
* 18- Normal enemies have stronger abilities.
* 19- Elites have stronger abilities.
* 20- Bosses have stronger abilities.

Selected level: <input id="ascensionLevel" value="0" type="number" style="width: 70px">
            </pre>
            <pre id="settingsScreen" style="display: none;">
Choose the cards that you want to play with:
<input type="checkbox" id="useIronclad" checked> Ironclad Cards
<input type="checkbox" id="useSilent" checked> Silent Cards
<input type="checkbox" id="useWatcher" checked> Watcher Cards
<button onclick="updateCardList();">Save</button>

Themes:
<button onclick="getId('html').classList.add('aqua');">Aqua</button><button onclick="getId('html').classList.add('black');">Black</button>
<button onclick="getId('html').setAttribute('class', 'default');">Reset themes</button>

Credits (in order of importance):
* MegaCrit
* ToasterOven<span style="color: #aaa">#????</span>
* A bunch of people at WSMS
            </pre>
        </div>
        <table id="gameScreen" style="display: none;">
            <tr>
                <td id="playerTd">
                    <div id="player"></div>
                    <br />
                    <span id="energy" class="tt"></span>&nbsp;&nbsp;&nbsp;<span id="hand"></span>
                    <br /><br />
                    <button id="discardPile" onclick='d=discardPile.map(x=>x.name);o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);'>View D<span style="text-decoration:underline">i</span>scard Pile</button>
                    <button id="drawPile" onclick='d=drawPile.map(x=>x.name);o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);'>View Draw <span style="text-decoration:underline">P</span>ile</button>
                    <button id="exhaustPile" onclick='d=exhaustPile.map(x=>x.name);o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);'>View E<span style="text-decoration:underline">x</span>haust Pile</button>
                    | <button id="turnEnder"><span style="text-decoration:underline">E</span>nd Turn</button><br/>
                </td>
                <td id="enemiesTd">
                    <div id="enemies"></div>
                </td>
            </tr>
        </table>
        <div id="rewardsScreen" style="display: none;">
            You won! Rewards:<br />
            <button id="goldReward"></button>
            <button id="cardReward" onclick="getId('cardReward').style.display = 'none'; addCard();">Add a card to your deck</button>
            <button id="potionReward"></button>
            <button id="relicReward" class="tt"></button>
            <button id="bossRelicReward" class="tt"></button>
            <button id="closeRewards" onclick="if(getId('cardReward').style.display != 'none'){ifRelic('Singing Bowl', function(){maxHp += 2; hp += 2;})} showMap();"><span style='text-decoration:underline'>C</span>ontinue</button>
        </div>
        <table id="mapScreen" style="display: none;"></table>
        <div id="restScreen" style="display: none;">
            <h2>Rest Site</h2>
            <span>You can rest or improve your deck here.</span>
            <br/>
            <button onclick="if(!relics.map(x=>x.name).includes('Coffee Dripper')){ifRelic('Regal Pillow', function(){hp += 15}); hp = Math.min(maxHp, Math.round(hp + 0.3*maxHp)); stats.rested = true; ifRelic('Dream Catcher', function(){addCard()}); showMap();}" class="tt restSite" id="rester"><span style='text-decoration:underline'>R</span>est<span class="txt" id="rest_txt">Heal 30% of your max HP. (currently 21 HP)</span></button>
            <button onclick="if(!relics.map(x=>x.name).includes('Fusion Hammer')){upgradeDialog();}" class="tt restSite Attack" id="smither"><span style='text-decoration:underline'>S</span>mith<span class="txt">Upgrade a card in your deck.</span></button>
            <br/><br/>
            <div id="upgradeDialog" style="display: none;">
                <div id="cardDesc"></div>
                <button onclick="upgradeCard(cardToUpgrade); getId('upgradeDialog').style.display = 'none'; showMap();"><span style='text-decoration:underline'>C</span>onfirm</button>
            </div>
        </div>
        <div id="merchantScreen" style="display: none;">
        </div>
        <div id="eventScreen" style="display: none;">
            <h2 id="eventTitle"></h2>
            <span id="eventDesc"></span><br/><br/>
            <span id="eventChoices"></span>
        </div>
        <br/>
        <span style="color: gray;" id="version"></span>
        <script>
            function shuffle(array) {
                let currentIndex = array.length, randomIndex;
                while(currentIndex != 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            }
            let getId = x => document.getElementById(x);
            getId("turnEnder").onclick = () => endTurn();
            let choice = function(...arg) {
                let x = arg.flat();
                return x[Math.floor(Math.random()*x.length)];
            }
            
            let crand = x => Math.ceil(Math.random()*x);
            let newFun = function(){getId("funText").innerHTML = "<br/>last update: "+choice([crand(99)+"% more fun", "browser support", "fourth character", "more interestingness", "less motivation", "graphics", "github page", (1+crand(98))+" new bugs", crand(99)+"% more content", "fire gameplay", "copyright infringement", "added this message", "new relic", "new card", "<a href='https://rickroll.com'>discord server</a>", "<a href='https://rickroll.com'>this</a>", "improved grammar", "snecko fix #"+crand(99), "5 star reviews", "unpopular opinions", "modding", "discord account (wooga123#8513)", "splash screen", "more educational", "now accepting suggestions", "difficulty spike", "unfair difficulty", "added act "+crand(10), "inside jokes", "no longer blocked by securly", "“StS act 2: electric boogaloo”", "now better than the real StS", "headphone support", "v"+crand(5)+"."+crand(15)+"."+crand(15), "can now be played on bus", "can now be played during school", "added cats", "added turtles", "new ascension level", "changed the keybinds again", "rainbows".split("").map(x=>"<span style='color: rgb("+crand(255)+","+crand(255)+","+crand(255)+");'>"+x+"</span>").join(""), crand(99)+"% less boring", "new boss", "lost my progress :(", "covid-"+(9+crand(90)), "hacking", "new event", "events are more eventful"])};
            newFun();
            window.setInterval(newFun, 800);
            
            let currentVersion = "v4.1.5b";
            getId("version").innerHTML = "Clone of Slay the Spire "+currentVersion+" ~ checking for updates";
            let myRequest = new Request("https://api.github.com/repos/wooga123/wooga123.github.io/branches/main");
            function fetchIt() {
                fetch(myRequest)
                .then((response) => {
                    if(!response.ok) return "whoops";
                    else return response.json();
                })
                .then((response) => {
                    if(response == "whoops") {getId("version").innerHTML = "Clone of Slay the Spire "+currentVersion+" ~ failed to check for updates";}
                    let msAgo = Date.now() - Date.parse(response["commit"]["commit"]["author"]["date"]);
                    let lastVer = response["commit"]["commit"]["message"].split("\n")[0];
                    getId("version").innerHTML = "Clone of Slay the Spire "+currentVersion+" ~ newest version is "+lastVer+" ("+(msAgo >= 864e5 ? Math.floor(msAgo / 864e5)+":" : "")+Math.floor((msAgo / 36e5) % 24).toString().padStart(2, "0")+":"+Math.floor((msAgo / 6e4) % 60).toString().padStart(2, "0")+" ago)";
                });
            }
            fetchIt();
            window.setInterval(fetchIt, 6e4);
            
            let resolvePromise;
            let modalNames = [];
            let multiChoice = [];
            function showPopup(displayText) {
                getId("selectionModal").style.display = "block";
                getId("selectionModalContent").innerHTML = "";
                let text = document.createElement("pre");
                text.setAttribute("onclick", "getId('selectionModal').style.display='none';");
                if(!displayText) {displayText="Nothing here..."}
                text.innerHTML = displayText+"\n(Click to close)";
                getId("selectionModalContent").appendChild(text);
            }
            async function showCardChoiceModal(displayCards, prompt, showUps) {
                getId("selectionModal").style.display = "block";
                getId("selectionModalContent").innerHTML = prompt + "<br/>";
                modalNames = [];
                for(let c of displayCards.sort((a,b)=>a.name.localeCompare(b.name))) {
                    modalNames.push(c.number);
                    let cardButton = document.createElement("button");
                    cardButton.setAttribute("onclick", "resolvePromise("+c.number+");");
                    cardButton.setAttribute("class", c.type+" tt");
                    let tips = makeTooltip(c);
                    let upCard = (upgradedCards[c.name] ? upgradedCards[c.name] : 0);
                    if(showUps && upCard) tips = tips.replace("</span>", "<br/>======<br/>"+makeTooltip(upCard()).split("class='txt'>")[1]);
                    cardButton.innerHTML = tips;
                    getId("selectionModalContent").appendChild(cardButton);
                    let helpNumber = document.createElement("span");
                    helpNumber.style.position = "absolute";
                    let coords = cardButton.getBoundingClientRect();
                    helpNumber.style.top = coords.bottom;
                    helpNumber.style.left = coords.left + 0.5 * (coords.right - coords.left) - 5;
                    let ind = displayCards.indexOf(c) + 1;
                    helpNumber.innerHTML = (ind > 10 ? "" : (ind == 10 ? "0" : ind));
                    getId("selectionModalContent").appendChild(helpNumber);
                }
                let promise = new Promise((resolve, reject) => {
                    resolvePromise = resolve;
                });
                let chosenCard;
                await promise.then((result) => {
                    getId("selectionModal").style.display = "none";
                    chosenCard = displayCards[displayCards.map(x=>x.number).indexOf(result)];
                });
                return chosenCard;
            }
            async function showMultiChoiceModal(displayCards, prompt, showUps) {
                getId("msModal").style.display = "block";
                getId("msModalContent").innerHTML = prompt + "<br/>";
                multiChoice = [];
                for(let c of displayCards) {
                    let cardButton = document.createElement("button");
                    cardButton.setAttribute("onclick", `
let num = ${c.number};
if(multiChoice.includes(num)) {
    multiChoice.splice(multiChoice.indexOf(num)); this.classList.remove('selection');
} else {
    multiChoice = [...multiChoice, num]; this.classList.add('selection');
}`
                    );
                    cardButton.setAttribute("class", c.type+" tt");
                    let tips = makeTooltip(c);
                    let upCard = (upgradedCards[c.name] ? upgradedCards[c.name] : 0);
                    if(showUps && upCard) tips = tips.replace("</span>", "<br/>=== Upgrades to: ===<br/>"+makeTooltip(upCard()).split("class='txt'>")[1]);
                    cardButton.innerHTML = tips;
                    getId("msModalContent").appendChild(cardButton);
                }
                let confirmButton = document.createElement("button");
                confirmButton.setAttribute("onclick", "resolvePromise(multiChoice);");
                confirmButton.setAttribute("class", "Status");
                confirmButton.innerHTML = "Confirm";
                let BR = document.createElement("br");
                getId("msModalContent").appendChild(BR);
                getId("msModalContent").appendChild(confirmButton);
                let promise = new Promise((resolve, reject) => {
                    resolvePromise = resolve;
                });
                let chosenCards;
                await promise.then((result) => {
                    getId("msModal").style.display = "none";
                    chosenCards = displayCards.filter(x=>result.includes(x.number));
                });
                return chosenCards;
            }
            async function choose(c, p, m=false, ups=false) {
                if(c.length >= 1) {
                    if(m) {
                        let woogas = await showMultiChoiceModal(c, p, ups);
                        return woogas;
                    } else {
                        let wooga = await showCardChoiceModal(c, p, ups);
                        return wooga;
                    }
                } else {
                    return null;
                }
            }
            let mousex = 0;
            let mousey = 0;
            document.onmousemove = function(e) {
                let x = document.getElementsByClassName("txt");
                mousex = e.clientX;
                mousey = e.clientY;
                for (t of x) {
                    t.style.left = (mousex+10) + "px";
                    t.style.top = (mousey+10+window.pageYOffset) + "px";
                }
            }
            function numberKey(num) {
                let n = num - 1;
                if(getId("cardModal").style.display != "none" && n<=2) {getId('cardModal').style.display='none'; finishAddCard(n);}
                else if(getId("cardModal").style.display != "none" && n==3) {
                    getId('cardModal').style.display='none'; finishAddCard(-1);
                }
                else if(getId("bossModal").style.display != "none" && n<=2) {
                    getId('bossModal').style.display='none'; finishAddRelic(n);
                }
                else if(getId("selectionModal").style.display != "none" && n<modalNames.length) { resolvePromise(modalNames[n]); }
                else if(getId("merchantScreen").style.display != "none" && n<offers.length) {
                    let offer = offers[n].offer;
                    let cost = offers[n].price;
                    if(gold >= cost) {
                        gold -= cost;
                        if(offers[n].index >= 100 && getId("relicElem_"+(n-6))) {
                            let r = offer;
                            relics.push(r);
                            getId("relicElem_"+(n-6)).style.display = "none";
                            updateStatLine();
                        } else if(getId("cardElem_"+n)) {
                            deck.push(new Card(offer.name, offer.cost, offer.type, offer.desc, offer.use, offer.flags));
                            getId("cardElem_"+n).style.display = "none";
                            updateStatLine();
                        }
                    }
                } else if(getId("gameScreen").style.display != "none") { hand[n].play(); }
                else if(getId("mapScreen").style.display != "none" && n <= 2) {
                    if(map[mapY+1][mapX+n-1] != "") {gotoMap(mapY + 1, mapX + n - 1);}
                }
            }
            document.onkeypress = function(e) {
                e = e || window.event;
                if(e.keyCode == 100) { // d
                    let d=deck.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);
                } else if(e.keyCode == 116) { // t
                    if(timerRunning){timerRunning=false;hasPaused=true;getId('timer').setAttribute('class','Attack');updateStatLine();}else{timerRunning=true;getId('timer').setAttribute('class','Skill');updateStatLine();}
                } else if(e.keyCode == 112 && getId("gameScreen").style.display != "none") { // p
                    let d=drawPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);
                } else if(e.keyCode == 105 && getId("gameScreen").style.display != "none") { // i
                    let d=discardPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);
                } else if(e.keyCode == 120 && getId("gameScreen").style.display != "none") { // x
                    let d=exhaustPile.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+"x "+x[0]).join("\n");showPopup(T);
                } else if(e.keyCode == 101 && getId("gameScreen").style.display != "none") { // e
                    endTurn();
                // numbers
                } else if(e.keyCode == 49) {numberKey(1);}
                else if(e.keyCode == 50) {numberKey(2);}
                else if(e.keyCode == 51) {numberKey(3);}
                else if(e.keyCode == 52) {numberKey(4);}
                else if(e.keyCode == 53) {numberKey(5);}
                else if(e.keyCode == 54) {numberKey(6);}
                else if(e.keyCode == 55) {numberKey(7);}
                else if(e.keyCode == 56) {numberKey(8);}
                else if(e.keyCode == 57) {numberKey(9);}
                else if(e.keyCode == 48) {numberKey(10);}
                else if(e.keyCode == 32) { // space
                    if(getId("rewardsScreen").style.display != "none") {
                        if(getId("goldReward").style.display != "none") {
                            let func = getId("goldReward").getAttribute("onclick"); eval(func);
                        } else if(getId("cardReward").style.display != "none") {
                            let func = getId("cardReward").getAttribute("onclick"); eval(func);
                        } else if(getId("potionReward").style.display != "none") {
                            let func = getId("potionReward").getAttribute("onclick"); eval(func);
                        } else if(getId("relicReward").style.display != "none") {
                            let func = getId("relicReward").getAttribute("onclick"); eval(func);
                        } else if(getId("bossRelicReward").style.display != "none") {
                            let func = getId("bossRelicReward").getAttribute("onclick"); eval(func);
                        } else { showMap(); }
                    } else if(getId("eventChoices").textContent == "Leave" && getId("eventScreen").style.display != "none") {
                        showMap();
                    }
                } else if(e.keyCode == 99) { // c
                    if(getId("merchantScreen").style.display != "none" || getId("rewardsScreen").style.display != "none") {
                        showMap();
                    } else if(getId("upgradeDialog").style.display != "none") {
                        upgradeCard(cardToUpgrade); getId('upgradeDialog').style.display = 'none'; showMap();
                    }
                } else if(e.keyCode == 114) { // r
                    if(getId("restScreen").style.display != "none") {
                        hp = Math.min(maxHp, Math.round(hp+0.3*maxHp)); stats.rested = true; showMap();
                    }
                } else if(e.keyCode == 115) { // s
                    if(getId("restScreen").style.display != "none") {upgradeDialog();}
                } else if(e.keyCode == 44) { // ,
                    if(potions.length >= 1) {let x = eval("let tgt=target; "+potions[0].effect); potions.splice(0, 1); updateHtml();}
                } else if(e.keyCode == 46) { // .
                    if(potions.length >= 2) {let x = eval("let tgt=target; "+potions[1].effect); potions.splice(1, 1); updateHtml();}
                } else if(e.keyCode == 47) { // /
                    if(potions.length >= 3) {let x = eval("let tgt=target; "+potions[2].effect); potions.splice(2, 1); updateHtml();}
                } else if(e.keyCode == 111 && getId("gameScreen").style.display != "none") { // o
                    let t = enemies.indexOf(target)+1; if(t >= enemies.length) {target = enemies[0];} else {target = enemies[t];}
                    updateHtml();
                }
            };
            let buffDesc = {
                ".": "You weren't supposed to see this. Just ignore it.",
                "Block": "Until next turn, prevents [AMT] damage.",
                "Shielding": "Prevents [AMT] damage.",
                "Vulnerable": "Take 50% more damage for [AMT] turn[s].",
                "Weak": "Deal 25% less damage for [AMT] turn[s].",
                "Strength": "Attacks deal [AMT] more damage.",
                "Dexterity": "Cards gain you [AMT] more Block.",
                "Strength Down": "At the end of this turn, lose [AMT] Strength.",
                "No Draw": "Cannot draw cards this turn.",
                "Combust": "At the end of your turn, lose 1 HP and deal [DAMT] damage to ALL enemies.",
                "Dark Embrace": "When a card is Exhausted, draw [AMT] card[s].",
                "Thorns": "Upon receiving damage, deal [DAMT] damage back.",
                "Ritual": "At end of turn, gain [AMT] Strength.",
                "Frail": "Gain 25% less Block for [AMT] turn[s].",
                "Enrage": "When you play a Skill, gains [AMT] Strength.",
                "Minus Strength": "Attacks deal [AMT] less damage.",
                "Minus Dexterity": "Gain [AMT] less block from cards.",
                "Evolve": "Whenever you draw a Status card, draw [AMT] card[s].",
                "Pen Nib": "When you get 10 Pen Nib, deal double damage.",
                "Feel No Pain": "When a card is Exausted, gain [BAMT] Block.",
                "Fire Breathing": "Whenever you draw a Status card, deal [DAMT] damage to ALL enemies.",
                "Metallicize": "Start each turn with [BAMT] Block.",
                "Rage": "For each Attack you play this turn, gain [BAMT] Block.",
                "Rampage": "Increase Rampage's damage by [AMT].",
                "Barricade": "Block is not removed at the start of your turn.",
                "Berserk": "Gain [AMT] more energy each turn.",
                "Brutality": "At the start of your turn, lose 1 HP and draw [AMT] card[s].",
                "Double Tap": "Your next [AMT] Attack[s] [are] played twice.",
                "Juggernaut": "Whenever you gain Block, deal [DAMT] damage to a random enemy.",
                "Regen": "At end of turn, heal [AMT] HP and reduce Regen by 1.",
                "Dexterity Down": "At end of turn, lose [AMT] Dexterity.",
                "Artifact": "Negates the next [AMT] debuff[s].",
                "Hex": "When you play a non-Attack card, add [AMT] Dazed to your discard pile.",
                "Draw Reduction": "Draw 1 fewer card for [AMT] turn[s].",
                "Buffer": "Prevent the first [AMT] unblocked hit[s].",
                "Next Turn Block": "Gain [BAMT] Block next turn.",
                "Vigor": "Your first attack deals [AMT] more damage.",
                "Next Turn Energy": "Gain [AMT] more energy next turn.",
                "Poison": "Lose [AMT] HP at start of turn. Poison goes down each turn.",
                "Accuracy": "Shivs deal [AMT] more damage.",
                "Blur": "Keep your Block for [AMT] turn[s].",
                "Infinite Blades": "Get [AMT] Shiv[s] each turn.",
                "Noxious Fumes": "At the start of your turn, apply [AMT] Poison to ALL enemies.",
                "Next Turn Cards": "Draw [AMT] more card[s] next turn.",
                "Thousand Cuts": "Whenever you play a card, deal [DAMT] damage to ALL enemies.",
                "After Image": "Whenever you play a card, gain [BAMT] Block.",
                "Burst": "Your next [AMT] Skill[s] [are] played twice.",
                "Envenom": "When you deal unblocked damage, apply [AMT] Poison.",
                "Tools of the Trade": "At the start of your turn, draw [AMT] card[s] and a discard 1 card.",
                "Flight": "Take 50% less damage. After taking damage [AMT] time[s], this is removed and enemy is stunned.",
                "Confused": "All card costs become randomized.",
                "Corruption": "Skills cost 0, but they Exhaust.",
                "Calm": "When you exit this stance, gain 2 energy.",
                "Wrath": "You deal 2x damage but take 2x damage.",
                "Divinity": "When you enter this stance, gain 3 energy. You deal 3x damage. Exit this stance at start of turn.",
                "Mark": "Does nothing by itself, but is useful for other things.",
                "Precision": "Deal [AMT] more damage per 5 Mark on the enemy. (currently +[PREC])",
                "Battle Hymn": "At the start of your turn, add [AMT] Smite[s] to your hand.",
                "Fasting": "Gain [AMT] less energy each turn.",
                "Collect": "Get a Miracle+ each turn for [AMT] turn[s].",
                "Foresight": "At the start of your turn, scry [AMT].",
                "Like Water": "When you end your turn in Calm, gain [BAMT] Block.",
                "Mental Fortress": "Whenever you change stances, gain [BAMT] Block.",
                "Nirvana": "Whenever you scry, gain [BAMT] Block.",
                "Rushdown": "Whenever you enter Wrath, draw [AMT] card[s].",
                "Study": "Add [AMT] Insight[s] to your draw pile each turn.",
                "Deva Form": "At the start of your turn, gain [AMT] energy and increase the gain by 1.",
                "Devotion": "At the start of your turn, gain [AMT] Mantra.",
                "Establishment": "When a card is Retained, it gets -[AMT] cost until end of combat.",
                "Simmering Fury": "At the start of your next turn, enter Wrath.",
                "Swivel": "The next [AMT] Attack[s] you play costs 0.",
                "Talk to the Hand": "When this gets attacked, you gain [BAMT] Block.",
                "Wave of the Hand": "Whenever you gain Block this turn, apply [AMT] Weak to ALL enemies.",
                "Vault": "Skip the next [AMT] enemy turn[s].",
                "Blasphemy": "Die next turn.",
                "Omega": "At the end of your turn, deal [DAMT] damage to ALL enemies.",
                "Mantra": "When you gain 10 Mantra, enter Divinity.",
                "Time Warp": "When this reaches 12, ends your turn and gains 2 Strength.",
                "Intangible": "Reduce damage and HP loss to 1 for [AMT] turn[s].",
                "Curiosity": "When you play a Power, gains [AMT] Strength.",
                "Split": "When it reaches half or less HP, splits into 2 small slimes.",
                "Thievery": "You lose [AMT] gold if this enemy flees.",
                "Curl Up": "Turns into Block when this takes damage.",
                "Spore Cloud": "On death, applies [AMT] Vulnerable to the player.",
                "Plated Armor": "Start each turn with [BAMT] Block. Goes down when taking damage.",
                "Angry": "Upon receiving damage, gains [AMT] Strength.",
                "Stunned": "Skips the next [AMT] turn[s].",
                "Lifelink": "Survives fatal blows on 1 HP. Dies when all enemies have 1 HP.",
                "Fading": "Dies in [AMT] turns.",
                "Shifting": "Upon receiving damage, loses that much Strength until end of turn.",
                "Strength Up": "At end of turn, gain [AMT] Strength.",
                "Malleable": "Upon recieving damage, gains [BAMT] Block. Goes up when triggered, resets at the end of its turn.",
                "Reactive": "Upon recieving damage, changes its intent.",
                "Constricting": "At the end of your turn, deals [DAMT] damage to you.",
                "Phasing": "Damage on EVEN turns is reduced to 1.",
                "Slow": "Whenever you play a card, takes 10% more damage this turn.",
                "Healer": "When it falls under half HP, uses its turn to heal back to half and cleanse debuffs.",
                "Unawakened": "This enemy has another form.",
                "Painful Stabs": "Whenever you take damage from this enemy, get [AMT] Wound[s]."
            };
            let buffDescPlus = {
                ...buffDesc,
                "ethereal": "Disappears if not used.",
                "exhaust": "Removed until end of combat.",
                "retain": "Not discarded at end of turn.",
                "scry": "Look at the top X cards of your deck. You may discard any of them.",
                "enter": "Entering a stance causes you to exit all others.",
                "shiv": "Costs 0 energy, has “Deals [SHIV] damage. Exhaust.”",
                "smite": "Costs 1 energy, has “Retain. Deal [SMITE] damage. Exhaust.”",
                "insight": "Costs 0 energy, has “Draw 2 cards. Exhaust.”",
                "safety": "Costs 1 energy, has “Retain. Gain [BLK12] Block. Exhaust.”",
                "through violence": "Costs 0 energy, has “Retain. Deal [DAM20] damage. Exhaust.”"
            };
            function addCircle(char) {
                let circles = {"X": "ⓧ", "0": "⓪", "1": "①", "2": "②", "3": "③", "4": "④", "5": "⑤"};
                return "<b style='color: yellow'>"+circles[char]+"</b>";
                //return circles[char];
            }
            function unformat(desc, strike=false) {
                let newDesc = desc.replace("[BLOCK]", "[DAM"+hasBuff("Block")+"]")
                    .replace("[HEAVYBLADE]", "[DAM"+(14+hasBuff("Strength")*2)+"]")
                    .replace("[HEAVYBLADE+]", "[DAM"+(14+hasBuff("Strength")*4)+"]")
                    .replace("[RAMPAGE]", "[DAM"+(8+hasBuff("Rampage"))+"]")
                    .replace("[SHIV]", "[DAM"+(4+hasBuff("Accuracy"))+"]")
                    .replace("[SHIV+]", "[DAM"+(6+hasBuff("Accuracy"))+"]")
                    .replace("[PERS]", "[BLK"+(5+stats.pers)+"]")
                    .replace("[WINDMILL]", "[DAM"+(7+stats.windmill)+"]")
                    .replace("[BRILLIANCE]", "[DAM"+(12+stats.mantraGain)+"]")
                    .replace("[BRILLIANCE+]", "[DAM"+(16+stats.mantraGain)+"]");
                if(enemies.length) {
                    newDesc = newDesc.replace("[FINISHER]", "[DAM"+(6*stats.attacksThisTurn)+"]")
                    .replace("[FINISHER+]", "[DAM"+(8*stats.attacksThisTurn)+"]")
                    .replace("[PREDICT]", "[BLK"+(enemies.map(x=>x.hasBuff("Mark"))).reduce((ps, a) => ps + a, 0)+"]");
                } else {
                    newDesc = newDesc.replace("[FINISHER]", "0")
                    .replace("[FINISHER+]", "0")
                    .replace("[PREDICT]", "0");
                }
                for(let i=1; i<300; i++) {
                    let newI; let blockI;
                    if(enemies.length) {
                        newI = calcYourDamage(target, i);
                        blockI = calcYourBlock(i);
                    } else {
                        newI = calcYourOOCDamage(i, false, strike);
                        blockI = calcYourBlock(i);
                    }
                    if(newI > i) {newI = "<span style='color:lime'>"+newI+"</span>";}
                    else if(newI < i) {newI = "<span style='color:#b00'>"+newI+"</span>";}
                    if(blockI > i) {blockI = "<span style='color:lime'>"+blockI+"</span>";}
                    else if(blockI < i) {blockI = "<span style='color:#b00'>"+blockI+"</span>";}
                    newDesc = newDesc.replaceAll("[DAM"+i+"]", newI).replaceAll("[BLK"+i+"]", blockI);
                }
                return newDesc;
            }
            function makeTooltip(card) {
                let newDesc = unformat(card.desc, card.name.toLowerCase().includes("Strike"));
                for(let buff in buffDescPlus) {
                    let cap = buff.charAt(0).toUpperCase() + buff.slice(1);
                    if(card.desc.toLowerCase().includes(buff.toLowerCase()) && buff != ".") {
                        let bd = buffDescPlus[buff]
                            .replaceAll("[DAMT]", "X")
                            .replaceAll("[BAMT]", "X")
                            .replaceAll("[AMT]", "X")
                            .replaceAll(" (currently +[PREC])", "")
                            .replaceAll("[s]", "s")
                            .replaceAll("[es]", "es")
                            .replaceAll("[are]", "are");
                        if(enemies.length) {
                            bd = bd.replaceAll("[SHIV]", calcYourDamage(target, 4, true)).replaceAll("[SMITE]", calcYourDamage(target, 12)).replaceAll("[DAM20]", calcYourDamage(target, 20)).replaceAll("[BLK12]", calcYourBlock(12));
                        } else {
                            bd = bd.replaceAll("[SHIV]", calcYourOOCDamage(4, true)).replaceAll("[SMITE]", calcYourOOCDamage(12)).replaceAll("[DAM20]", calcYourOOCDamage(20)).replaceAll("[BLK12]", calcYourOOCBlock(12));
                        }
                        newDesc = newDesc.replaceAll(buff, "<b>"+buff+"</b>").replaceAll(cap, "<b>"+cap+"</b>") + "<br/><i style='color:#222'>("+cap+": "+bd+")</i>";
                    }
                }
                return card.name+"<span class='txt'>"+addCircle(card.cost.toString())+" "+card.type+"<br/>"+newDesc+"</span>";
            }
            
            let music = {
                boss1: new Audio("ShovelKnight/therival.mp3"),
                boss2: new Audio("ShovelKnight/therival.mp3"),
                boss3: new Audio("ShovelKnight/therival.mp3"),
                enemy: new Audio("ShovelKnight/fightingwithallofourmight.mp3"),
                elite: new Audio("ShovelKnight/thedecadentdandy.mp3"),
                rest: new Audio("ShovelKnight/noweaponshere.mp3"),
                shop: new Audio("ShovelKnight/onefatefulknight.mp3"),
                menu: new Audio("ShovelKnight/maintheme.mp3"), // Doesn't seem to work, unused right now
                map: new Audio("ShovelKnight/steelthyshovel.mp3"),
                death: new Audio("ShovelKnight/thedonorsdespair.mp3"),
                win: new Audio("ShovelKnight/returntoorder.mp3"),
                bossDead: new Audio("ShovelKnight/forshovelry.mp3")
            };
            music.boss1.loop = true;
            music.boss2.loop = true;
            music.boss3.loop = true;
            music.enemy.loop = true;
            music.elite.loop = true;
            music.rest.loop = true;
            music.shop.loop = true;
            music.menu.loop = true;
            music.map.loop = true;
            music.death.loop = true;
            music.win.loop = true;
            music.boss1.volume = 0.5;
            music.boss2.volume = 0.5;
            music.boss3.volume = 0.5;
            music.enemy.volume = 0.5;
            music.elite.volume = 0.5;
            music.rest.volume = 0.4;
            music.shop.volume = 0.4;
            music.menu.volume = 0.4;
            music.map.volume = 0.25;
            music.death.volume = 0.5;
            music.win.volume = 0.5;
            music.bossDead.volume = 0.5;
            
            let announceMusic = function(name) {};
            
            class Card {
                /*
                'effect' is a function that takes the current target, whether it is used or not.
                */
                constructor(name, cost, type, desc, use, flags=[]) {
                    this.name = name;
                    this.cost = cost;
                    this.type = type;
                    this.desc = desc;
                    this.use = use;
                    this.flags = flags;
                    this.number = Math.random();
                }
                play() {
                    if(stats.cardsThisTurn >= 6 && relics.map(x=>x.name).includes("Velvet Choker")) return;
                    let played = false;
                    if(this.cost == "X") {
                        let useCard = function(c){c.use(target);}
                        for(let x=0; x<energy; x++) {
                            this.use(target);
                        }
                        ifRelic("Chemical X", useCard, [this]);
                        ifRelic("Chemical X", useCard, [this]);
                        if(!(hasBuff("Swivel") && this.type == "Attack")) {
                            energy = 0;
                        }
                        played = true;
                    } else {
                        let newCost = this.cost;
                        if(hasBuff("Corruption") && this.type == "Skill") {
                            newCost = 0;
                        }
                        if(hasBuff("Swivel") && this.type == "Attack") {
                            loseBuff("Swivel", 1);
                            newCost = 0;
                        }
                        if(
                            energy >= newCost &&
                            !this.flags.includes("unplayable") &&
                            !(this.name.includes("Signature Move") && hand.filter(x=>x.type=="Attack"&&!x.name.includes("Signature Move")).length) &&
                            !(this.name.includes("Clash") && hand.map(x=>x.type=="Attack").includes(false))
                        ) {
                            energy -= newCost;
                            this.use(target);
                            played = true;
                        }
                    }
                    if(played) {
                        hand.splice(hand.indexOf(this), 1);
                        if(this.flags.includes("exhausted") || (hasBuff("Corruption") && this.type == "Skill")) {
                            exhaustPile.push(this);
                            drawCard(hasBuff("Dark Embrace"));
                            gainBuff("Block", hasBuff("Feel No Pain"));
                            ifRelic("Dead Branch", function(){hand.push(randCard())});
                            //ifRelic("Charon’s Ashes", function(){for(let e of enemies){dealDamage(e, 3);}});
                        } else if(this.name == "Tantrum") {
                            drawPile.push(this); drawPile = shuffle(drawPile);
                        } else {
                            discardPile.push(this);
                        }
                        this.play_success();
                    }
                    updateHtml();
                }
                play_success() {
                    stats.lastType = this.type;
                    if(hand.length == 0) {ifRelic("Unceasing Top", function(){drawCard()})}
                    for(let i of enemies) {dealDamage(i, hasBuff("Thousand Cuts"));}
                    gainBuff("Block", hasBuff("After Image"));
                    if(Math.random() < 0.1) {ifRelic("Ink Bottle", function(){drawCard();})}
                    stats.cardsThisTurn += 1;
                    if(this.type == "Skill") {
                        stats.skillsThisTurn += 1;
                        if(stats.skillsThisTurn % 3 == 0) {ifRelic("Letter Opener", function(){for(let e of enemies){dealDamage(e, 5)}})}
                        for(let e of enemies) {
                            e.gainBuff("Strength", e.hasBuff("Enrage"));
                        }
                        if(hasBuff("Burst") && this.name != "Burst" && this.name != "Burst+") {
                            loseBuff("Burst", 1);
                            this.use(target);
                        }
                    }
                    if(this.type == "Power") {
                        ifRelic("Bird-Faced Urn", function(){hp = Math.min(maxHp, hp + 2)});
                        ifRelic("Mummified Hand", function(){
                            let eligible = hand.filter(x=>x.cost > 0);
                            if(eligible.length == 0) return;
                            let c = eligible[Math.floor(Math.random()*eligible.length)];
                            c.flags.push("nextcost "+c.cost);
                            c.cost = 0;
                        });
                        let en = enemies[enemies.length - 1];
                        en.gainBuff("Strength", en.hasBuff("Curiosity"));
                    }
                    if(this.type == "Attack") {
                        stats.attacksThisTurn += 1;
                        if(stats.attacksThisTurn % 3 == 0) {
                            ifRelic("Kunai", function(){gainBuff("Dexterity", 1)});
                            ifRelic("Shuriken", function(){gainBuff("Strength", 1)});
                            ifRelic("Ornamental Fan", function(){gainBuff("Block", 4)});
                        }
                        gainBuff("Block", hasBuff("Rage"));
                        if(hasBuff("Double Tap")) {
                            loseBuff("Double Tap", 1);
                            this.use(target);
                        }
                        ifRelic("Pen Nib", function(){gainBuff("Pen Nib", 1)});
                        loseBuff("Vigor");
                    }
                    if(this.name.toLowerCase().includes("strike")) {
                    }
                    if(this.type != "Attack") {
                        if(hasBuff("Hex")) {
                            for(let i=0; i<hasBuff("Hex"); i++) {discardPile.push(statusCards["Dazed"]());}
                        }
                    }
                    let en = enemies[0];
                    if(en.name == "Time Eater") {
                        en.gainBuff("Time Warp", 1);
                        if(en.hasBuff("Time Warp") >= 12) {
                            en.loseBuff("Time Warp");
                            en.gainBuff("Strength", 2);
                            endTurn();
                        }
                    }
                    if(en.name == "Giant Head") {
                        en.gainBuff("Slow", 1);
                    }
                    for(let i of hand) {
                        if(i.name == "Pain") hp -= 1;
                    }
                }
            }
            
            class Enemy {
                /*
                'attacks' is a list of objects. Each one has a 'desc' and an 'effect'.
                The effect is a function that takes this object as a parameter (because it cannot use 'this').
                */
                constructor(name, kind, hp, hpUp, attacks, attacksUp1, attacksUp2, flags=[], buffs={}, buffsUp={}) {
                    this.name = name;
                    this.number = Math.random();
                    this.maxHp = hp;
                    if(getId("ascensionLevel").value > (kind=="n"?4:(kind=="e"?5:6))) {
                        this.maxHp = hpUp;
                    }
                    if(this.maxHp != 999 && kind != "b") {this.maxHp = Math.round((Math.random()*0.2 + 0.9) * this.maxHp);}
                    this.hp = this.maxHp;
                    this.attacks = attacks;
                    if(getId("ascensionLevel").value > (kind=="n"?7:(kind=="e"?8:9))) {
                        this.attacks = attacksUp1;
                    }
                    if(getId("ascensionLevel").value > (kind=="n"?18:(kind=="e"?19:20))) {
                        this.attacks = attacksUp2;
                    }
                    this.flags = flags;
                    this.buffs = [];
                    let b = buffs;
                    if(getId("ascensionLevel").value > (kind=="n"?18:(kind=="e"?19:20))) {
                        b = buffsUp;
                    }
                    for(let i in b) {
                        this.buffs.push({name: i, amt: b[i]});
                    }
                    this.intent = (flags.includes("randomize") ? choice(attacks) : attacks[0]);
                }
                attack() {
                    this.intent.effect(this);
                    if(this.flags.includes("randomize")) {
                        let newIntent = choice(this.attacks);
                        while(newIntent == this.intent && !this.flags.includes("repeatable")) {
                            newIntent = choice(this.attacks);
                        }
                        this.intent = newIntent;
                    } else if(this.attacks.indexOf(this.intent) + 1 == this.attacks.length && !(this.flags.includes("no-repeat"))) {
                        if(this.flags.includes("skip-first")) {
                            this.intent = this.attacks[1];
                        } else {
                            this.intent = this.attacks[0];
                        }
                    } else if(this.attacks.indexOf(this.intent) + 1 != this.attacks.length) {
                        this.intent = this.attacks[this.attacks.indexOf(this.intent) + 1];
                    }
                    updateHtml();
                }
                hasBuff(name) {
                    for(let b of this.buffs) {if(b.name == name) {return b.amt;}}
                    return 0;
                }
                gainBuff(name, amt) {
                    if(amt == 0) return;
                    if(debuffs.includes(name) && this.hasBuff("Artifact")) {this.loseBuff("Artifact", 1); updateHtml(); return;}
                    let newAmt = amt;
                    if(name == "Block") {newAmt = this.calcBlock(amt);}
                    if(name == "Poison") {ifRelic("Snecko Skull", function(){newAmt += 1})}
                    if(amt == 0) return;
                    let foundBuff = false;
                    for(let b of this.buffs) {if(b.name == name) {b.amt += newAmt; foundBuff = true;}}
                    if(!foundBuff && amt > 0) {this.buffs.push({name: name, amt: newAmt});}
                }
                loseBuff(name, amt=9999) {
                    let prevAmt;
                    for(let b of this.buffs) {
                        if(b.name == name) {
                            prevAmt = b.amt;
                            if(amt >= b.amt) {this.buffs.splice(this.buffs.indexOf(b), 1);} else {b.amt -= amt;}
                            break;
                        }
                    }
                }
                
                calcDamage(amt, actuallyDeal=false) {
                    if(amt == 0) return 0;
                    let finalAmt = amt;
                    if(hasBuff("Vulnerable")) {finalAmt = Math.round(finalAmt * 1.5);}
                    if(hasBuff("Wrath")) {finalAmt *= 2;}
                    finalAmt += this.hasBuff("Strength");
                    finalAmt -= this.hasBuff("Minus Strength");
                    if(this.hasBuff("Weak")) {finalAmt = Math.round(finalAmt * 0.75);}
                    let ub = finalAmt - hasBuff("Block");
                    if(ub > 0 && ub <= 5) {ifRelic("Torii", function(){finalAmt = 1;})}
                    if(ub > 0) {ifRelic("Tungsten Rod", function(){finalAmt -= 1;})}
                    if(hasBuff("Intangible")) {finalAmt = 1;}
                    if(hasBuff("Buffer") && ub > 0 && actuallyDeal) {finalAmt = 0; loseBuff("Buffer", 1);}
                    return finalAmt;
                }
                
                calcBlock(amt) {
                    let newAmt = amt;
                    if(this.hasBuff("Frail")          ) {newAmt = Math.round(newAmt * 0.75);}
                    if(this.hasBuff("Dexterity")      ) {newAmt += this.hasBuff("Dexterity");}
                    if(this.hasBuff("Minus Dexterity")) {newAmt -= this.hasBuff("Minus Dexterity");}
                    return newAmt;
                }
                
                dealDamage(amt, procThorns=true) {
                    let finalAmt = this.calcDamage(amt, true);
                    let dealt = Math.max(0, finalAmt - hasBuff("Block"));
                    hp -= dealt;
                    loseBuff("Block", finalAmt);
                    
                    if(dealt > 0) {
                        if(stats.timesLostHp == 0) {ifRelic("Centennial Puzzle", function(){drawCard(3)})}
                        stats.timesLostHp++;
                        ifRelic("Self-Forming Clay", function(){gainBuff("Next Turn Block", 3)});
                        for(let i of [...drawPile, ...hand, ...discardPile]) {
                            if(i.name == "Blood for Blood" && i.cost > 0){
                                i.cost -= 1;
                            }
                        }
                        addStatus("Wound", this.hasBuff("Painful Stabs"));
                        if(hasBuff("Thorns") && procThorns) {dealDamage(this, hasBuff("Thorns")); updateHtml();}
                        loseBuff("Plated Armor", 1);
                        let red = dealt * 0.02 + 0.24;
                        let i = 0;
                        while(red > 0) {
                            setTimeout(function(r){getId("damage").style.opacity = r;}, i * 10, red);
                            i++;
                            red -= 0.012;
                            if(red < 0) {setTimeout(function(){getId("damage").style.opacity = 0;}, i * 10);}
                        }
                    }
                }
            }
            
            function hasBuff(name) {
                for(let b of buffs) {if(b.name == name) {return b.amt;}}
                return 0;
            }
            function gainBuff(name, amt) {
                if(amt == 0) return;
                if(debuffs.includes(name) && hasBuff("Artifact") > 0) {loseBuff("Artifact", 1); updateHtml(); return;}
                let newAmt = amt;
                if(name == "Block") {
                    newAmt = calcYourBlock(amt);
                    for(let e of enemies){e.gainBuff("Weak", hasBuff("Wave of the Hand"));}
                    dealDamage(choice(enemies), hasBuff("Juggernaut"));
                }
                if(name == "Weak") {ifRelic("Ginger", function(){newAmt = 0});}
                if(name == "Frail") {ifRelic("Turnip", function(){newAmt = 0});}
                if(name == "Vulnerable") {gainBuff(".", 1);}
                if(amt == 0) return;
                let foundIt = false; for(let b of buffs) {if(b.name == name) {
                    b.amt += newAmt; foundIt = true;
                }}
                if(!foundIt) {
                    buffs.push({name: name, amt: newAmt});
                }
                if(name == "Mantra") {stats.mantraGain += newAmt;}
                if(name == "Wrath") {loseBuff("Calm"); loseBuff("Divinity"); drawCard(hasBuff("Rushdown"));}
                if(name == "Calm") {loseBuff("Wrath"); loseBuff("Divinity");}
                if(name == "Divinity") {loseBuff("Wrath"); loseBuff("Calm"); energy += 3;}
                if(["Wrath","Calm","Divinity"].includes(name)) {
                    let fobs = discardPile.filter(x=>x.name.includes("Flurry of Blows"));
                    hand = [...hand, ...fobs];
                    discardPile = discardPile.filter(x=>!x.name.includes("Flurry of Blows"));
                    gainBuff("Block", hasBuff("Mental Fortress"));
                }
                if(hasBuff("Mantra") >= 10 && hasBuff("Divinity") == 0) {gainBuff("Divinity", 1); loseBuff("Mantra", 10);}
            }
            function loseBuff(name, amt=9999) {
                for(let b of buffs) {
                    if(b.name == name) {
                        if(amt >= b.amt) {buffs.splice(buffs.indexOf(b), 1);} else {b.amt -= amt;}
                        if(name == "Calm") {energy += 2; ifRelic("Violet Lotus", function(){energy += 1;});}
                    }
                }
            }
            
            function calcYourDamage(enemy, amt, shiv=false, strike=false, actuallyDeal=false) {
                if(amt == 0) return 0;
                let finalAmt = amt;
                if(shiv) {finalAmt += hasBuff("Accuracy"); ifRelic("Wrist Blade", function(){finalAmt += 6;});}
                if(strike) {ifRelic("Strike Dummy", function(){finalAmt += 3;})}
                if(enemy.hasBuff("Vulnerable")) {finalAmt = Math.round(finalAmt * 1.5);}
                finalAmt += Math.floor(target.hasBuff("Mark") * hasBuff("Precision") / 5);
                if(enemy.hasBuff("Flight")) {finalAmt = Math.round(finalAmt*0.5); if(actuallyDeal){
                    enemy.loseBuff("Flight", 1); if(!enemy.hasBuff("Flight")) {enemy.gainBuff("Stunned", 3);}
                }}
                if(hasBuff("Wrath")) {finalAmt *= 2;}
                if(hasBuff("Divinity")) {finalAmt *= 3;}
                if(hasBuff("Pen Nib") >= 9) {
                    if(actuallyDeal) loseBuff("Pen Nib");
                    finalAmt *= 2;
                }
                if(enemy.hasBuff("Phasing") && turn % 2 == 0) {finalAmt = 1;}
                if(finalAmt > 0) {
                    finalAmt += hasBuff("Strength") + hasBuff("Vigor");
                    ifRelic("Red Skull", function(){if(hp<=0.5*maxHp){finalAmt += 3;}});
                    finalAmt -= hasBuff("Minus Strength");
                    if(finalAmt < 5 && relics.map(x=>x.name).includes("The Boot")) {finalAmt = 5;}
                }
                if(hasBuff("Weak")) {finalAmt = Math.round(finalAmt * 0.75);}
                if(enemy.name == "Darkling") {finalAmt = Math.min(finalAmt, enemy.hp - 1);}
                return finalAmt;
            }
            function calcYourOOCDamage(amt, shiv=false, strike=false) {
                if(amt == 0) return 0;
                let finalAmt = amt;
                if(shiv) {ifRelic("Wrist Blade", function(){finalAmt += 6;});}
                if(strike) {ifRelic("Strike Dummy", function(){finalAmt += 3;})}
                if(finalAmt > 0) {
                    ifRelic("Vajra", function(){finalAmt += 1;});
                    ifRelic("Red Skull", function(){if(hp<=0.5*maxHp){finalAmt += 3;}});
                    if(finalAmt < 5 && relics.map(x=>x.name).includes("The Boot")) {finalAmt = 5;}
                }
                return finalAmt;
            }
            function calcYourOOCBlock(amt) {
                let finalAmt = amt;
                ifRelic("Oddly Smooth Stone", function(){finalAmt += 1;});
                return finalAmt;
            }
            function calcYourBlock(amt) {
                if(amt == 0) return 0;
                let newAmt = amt;
                if(hasBuff("Frail")          ) {newAmt = Math.round(newAmt * 0.75);}
                if(hasBuff("Dexterity")      ) {newAmt += hasBuff("Dexterity");}
                if(hasBuff("Minus Dexterity")) {newAmt -= hasBuff("Minus Dexterity");}
                return newAmt;
            }
            
            function dealDamage(enemy, amt, shiv=false, strike=false) {
                let finalAmt = calcYourDamage(enemy, amt, shiv, strike, true);
                if(finalAmt == 0) return;
                let dealt = Math.max(0, finalAmt - enemy.hasBuff("Block"));
                enemy.hp -= dealt;
                if(enemy.hasBuff("Shifting")) {enemy.gainBuff("Minus Strength", dealt);}
                let red = dealt * 10 + 120;
                let i = 0;
                while(red > 0) {
                    setTimeout(function(r){
                        getId("enemy_"+enemies.indexOf(enemy)).classList.add("notrans");
                        getId("enemy_"+enemies.indexOf(enemy)).style.background = `rgb(${r}, 0, 0)`;
                    }, i * 10, red);
                    i++;
                    red -= 5;
                    if(red < 0) {setTimeout(function(){
                        getId("enemy_"+enemies.indexOf(enemy)).style.background = "black";
                    }, i * 10);}
                }
                enemy.loseBuff("Block", finalAmt);
                if(dealt > 0) {
                    if(hasBuff("Envenom")) {enemy.gainBuff("Poison", hasBuff("Envenom"));}
                    enemy.loseBuff("Plated Armor", 1);
                    if(enemy.hasBuff("Curl Up")) {
                        enemy.gainBuff("Block", enemy.hasBuff("Curl Up"));
                        enemy.loseBuff("Curl Up");
                    }
                    if(enemy.hasBuff("Malleable")) {
                        enemy.gainBuff("Block", enemy.hasBuff("Malleable"));
                        enemy.gainBuff("Malleable", 1);
                    }
                    enemy.gainBuff("Strength", enemy.hasBuff("Angry"));
                    if(enemy.hasBuff("Reactive")) {
                        let int = choice(enemy.attacks);
                        while(int == enemy.intent) {int = choice(enemy.attacks);}
                        enemy.intent = int;
                    }
                }
                if(finalAmt > 0) {
                    enemy.dealDamage(enemy.hasBuff("Thorns"), false);
                    gainBuff("Block", enemy.hasBuff("Talk to the Hand"));
                    updateHtml();
                }
            }
            
            let debuffs = ["Vulnerable", "Weak", "Strength Down", "No Draw", "Frail", "Minus Strength", "Minus Dexterity", "Dexterity Down", "Hex", "Draw Reduction", "Poison", "Confused", "Mark", "Fasting", "Talk to the Hand", "Stunned", "Shifting", "Slow"];            
            let statusCards = {
                "Wound": () => new Card("Wound", 0, "Status", "Unplayable.", function(enemy){}, ["unplayable"]),
                "Dazed": () => new Card("Dazed", 0, "Status", "Unplayable. Ethereal.", function(enemy){}, ["unplayable", "ethereal"]),
                "Slimed": () => new Card("Slimed", 1, "Status", "Exhaust.", function(enemy){}, ["exhausted"]),
                "Burn": () => new Card("Burn", 0, "Status", "Unplayable. Lose 1 HP at end of turn.", function(enemy){}, ["unplayable"]),
                "Burn+": () => new Card("Burn+", 0, "Status", "Unplayable. Lose 2 HP at end of turn.", function(enemy){}, ["unplayable"])
            };
            
            function showMap() {
                music.shop.pause(); music.rest.pause();
                music.shop.currentTime = 0; music.rest.currentTime = 0;
                if(mapY >= 15) {
                    mapY = 0;
                    hp = (getId("ascensionLevel").value >= 5 ? Math.round(hp+0.75*(maxHp-hp)) : maxHp);
                    mapGen();
                    if(actNum == 1) {
                        actNum = 2;
                    } else if(actNum == 2) {
                        actNum = 3;
                    } else if(actNum == 3) {
                        actNum = 0;
                        timerRunning = false; updateStatLine(); music.win.play(); announceMusic("A Return To Order"); alert("You win! Nice job"); return;
                    }
                }
                updateStatLine();
                getId("rewardsScreen").style.display = "none";
                getId("restScreen").style.display = "none";
                getId("merchantScreen").style.display = "none";
                getId("eventScreen").style.display = "none";
                if(actNum != 0) {getId("mapScreen").style.display = "block";} else {alert("Weird, actNum==0"); return;}
                music.map.play();
                announceMusic("Steel Thy Shovel");
                getId("mapScreen").innerHTML = "Select your next room...";
                for(let floor in map) {
                    let floorElem = document.createElement("tr");
                    for(let node in map[floor]) {
                        let nodeElem = document.createElement("td");
                        if(map[floor][node] != "") {
                            let nodeButton = document.createElement("button");
                            nodeButton.innerHTML = map[floor][node]+"<span class='txt'>"+
                                (map[floor][node]=="💀" ? "Fight some monsters. Get gold, a card and maybe a potion if you win." : 
                                  (map[floor][node]=="😈" ? "Fight a strong monster. Get gold, a rare card, a relic, and maybe a potion if you win." : 
                                    (map[floor][node]=="🏕️" ? "Rest and heal some HP or upgrade a card." : 
                                     (map[floor][node]=="❓" ? "Encounter a random event." : 
                                       (map[floor][node]=="💲" ? "Buy cards and relics at the shop." : "Fight a Boss. Cool stuff if you win."))))
                                )+"</span>";
                            nodeButton.setAttribute("class", "tt notbig");
                            if(floor-1 == mapY && Math.abs(node-mapX) <= 1) {
                                nodeButton.setAttribute("onclick", `gotoMap(${floor}, ${node});`);
                            } else if(floor == mapY && node == mapX) {
                                nodeButton.innerHTML = "🙂";
                            } else {
                                nodeButton.setAttribute("class", "nonbutton notbig");
                            }
                            nodeElem.appendChild(nodeButton);
                        }
                        floorElem.appendChild(nodeElem);
                    }
                    getId("mapScreen").appendChild(floorElem);
                }
                getId("mapScreen").innerHTML += "&nbsp;".repeat(5) + "Boss: " + runBosses[actNum - 1].name;
            }
            function gotoMap(y, x) {
                mapY = y;
                mapX = x;
                timerRunning = true; updateStatLine();
                music.map.pause();
                music.map.currentTime = 0;
                ifRelic("Maw Bank", function(){gold += 12;});
                let readyBattle = function() {
                    getId("mapScreen").style.display = "none";
                    getId("gameScreen").style.display = "block";
                    if(eliteBattle) {music.elite.play(); announceMusic("Strike The Earth!");}
                    else if(bossBattle && actNum == 1) {music.boss1.play(); announceMusic("The Decadent Dandy");}
                    else if(bossBattle && actNum == 2) {music.boss2.play(); announceMusic("The Schemer");}
                    else if(bossBattle && actNum == 3) {music.boss3.play(); announceMusic("The Rival");}
                    else {music.enemy.play(); announceMusic("Fighting With All Of Our Might");}
                    drawPile = [];
                    discardPile = [];
                    exhaustPile = [];
                    hand = [];
                    buffs = [];
                    energy = 0; // no ice cream hax
                    turn = 0;
                    stats = {...stats, timesLostHp: 0, attacksThisTurn: 999, skillsThisTurn: 999, rested: stats.rested, lastType: "None", pers: 0, windmill: 0, mantraGain: 0, cardsThisTurn: 999};
                    target = enemies[0];
                    for(let c of deck) {
                        if(c.name == "Sands of Time" || c.name == "Sands of Time+" || c.name == "Blood for Blood" || c.name == "Blood for Blood+") {
                            c.cost = 4;
                        }
                    }
                    
                    try {
                        let shuffledDeck = shuffle(deck.slice(0));
                        for(let card of shuffledDeck) {
                            if(card.flags.includes("innate")) {
                                hand.push(card);
                            } else {
                                drawPile.push(card);
                            }
                        }
                    } catch(err) {
                        alert(err);
                    }
                    
                    startTurn();
                }
                if(map[y][x] == "💀") {
                    if(mapY >= 4) {enemies = choice(hardPools[actNum]);}
                    else {enemies = choice(easyPools[actNum]);}
                    enemies = enemies.map(x=>choice(x));
                    enemies = enemies.map(x=>x());
                    eliteBattle = false;
                    bossBattle = false;
                    readyBattle();
                } else if(map[y][x] == "😈") {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleElites)();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleElites_act2)();
                    } else {
                        nme = () => choice(possibleElites_act3)();
                    }
                    enemies = [nme()];
                    if(enemies[0].name == "Sentry") {
                        enemies.push(new Enemy("Sentry", "e", enemies[0].hp, enemies[0].hp,
                            [enemies[0].attacks[1], enemies[0].attacks[0]],
                            [enemies[0].attacks[1], enemies[0].attacks[0]],
                            [enemies[0].attacks[1], enemies[0].attacks[0]],
                            [], {"Artifact": 1}, {"Artifact": 1}));
                        enemies.push(new Enemy("Sentry", "e", enemies[0].hp, enemies[0].hp,
                            enemies[0].attacks, enemies[0].attacks, enemies[0].attacks, [], {"Artifact": 1}, {"Artifact": 1}));
                    }
                    if(enemies[0].name == "Taskmaster") {
                        enemies.push(rSlaver()); enemies.push(bSlaver());
                    }
                    if(enemies[0].name == "Reptomancer") {
                        enemies.push(reptoDagger()); enemies.push(reptoDagger());
                    }
                    eliteBattle = true;
                    bossBattle = false;
                    readyBattle();
                } else if(map[y][x].includes("👺")) {
                    enemies = [runBosses[(actNum - 1)]]
                    if(enemies[0].name == "Donu") {
                        let a_b = (what, amt) => function(me){ for(let e of enemies){e.gainBuff(what, amt);}}
                        let a_mb = (lst) => function(me){ for(let e of enemies){for(let i of lst){e.gainBuff(lst[0], lst[1]);}}}
                        let a_s = (atk, what, amt) => function(me){ addStatus(what, amt); me.dealDamage(atk); }
                        enemies.push(new Enemy("Deca", "b", 250, 265, [
                            {intent: "attack-nerf 20", desc: "deal [DAM20] damage and generate Status cards", effect: a_s(20, "Dazed", 2)},
                            {intent: "blocking", desc: "block", effect: a_b("Block", 16)}
                        ], [
                            {intent: "attack-nerf 24", desc: "deal [DAM24] damage and generate Status cards", effect: a_s(24, "Dazed", 2)},
                            {intent: "blocking", desc: "block", effect: a_b("Block", 16)}
                        ], [
                            {intent: "attack-nerf 24", desc: "deal [DAM24] damage and generate Status cards", effect: a_s(24, "Dazed", 2)},
                            {intent: "block-buff", desc: "block and buff ALL enemies", effect: a_mb([["Block", 16], ["Plated Armor", 3]])}
                        ], [], {"Artifact": 2}, {"Artifact": 3}));
                    }
                    if(enemies[0].name == "Awakened One") {
                        enemies[0].gainBuff("Curiosity", (getId("ascensionLevel").value == 20 ? 2 : 1));
                        enemies.push(new Enemy("Cultist", 50, [
                            {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                            {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                        ], ["no-repeat"]));
                        enemies.push(new Enemy("Cultist", 50, [
                            {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                            {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                        ], ["no-repeat"]));
                    }
                    eliteBattle = false;
                    bossBattle = true;
                    ifRelic("Pantograph", function(){hp = Math.min(maxHp, hp + 25)});
                    readyBattle();
                } else if(map[y][x] == "🏕️") {
                    getId("mapScreen").style.display = "none";
                    getId("restScreen").style.display = "block";
                    ifRelic("Eternal Feather", function(){hp = Math.min(maxHp, Math.round(hp + 0.6 * deck.length))});
                    getId("rest_txt").innerHTML = "Heal 30% of your max HP. (currently "+Math.round(0.3 * maxHp)+" HP)";
                    music.rest.play();
                    announceMusic("No Weapons Here");
                } else if(map[y][x] == "💲") {
                    /*debugging*/ try {
                    getId("mapScreen").style.display = "none";
                    getId("merchantScreen").style.display = "block";
                    music.shop.play();
                    announceMusic("One Fateful Knight");
                    getId("merchantScreen").innerHTML = "";
                    ifRelic("Meal Ticket", function(){hp = Math.min(maxHp, hp + 15)});
                    offers = [];
                    for(let i=0; i<6; i++) {
                        let offer = randCard();
                        let cardCost = Math.round(Math.random()*37 + 45); // cost: 45g to 81g
                        if(getId("ascensionLevel").value >= 16) {cardCost = Math.round(Math.random()*43 + 51);} // cost: 51g to 93g
                        offers.push({index: i, price: cardCost, offer: offer});
                        if(i==0) {cardCost = Math.round(cardCost * 0.45);}
                        if(i==5) {cardCost = Math.round(Math.random()*30 + 135); offer = randRareCard();} // 6th card is rare
                        let cardElem = document.createElement("div");
                        let nameElem = document.createElement("button");
                        let costElem = document.createElement("div");
                        cardElem.setAttribute("id", `cardElem_${i}`);
                        cardElem.setAttribute("class", "shopCard");
                        nameElem.setAttribute("id", `cardName_${i}`);
                        nameElem.setAttribute("class", "shopName");
                        nameElem.innerHTML = makeTooltip(offer);
                        if(i==0) {
                            nameElem.setAttribute("class", "Skill tt");
                        } else {
                            nameElem.setAttribute("class", "tt");
                        }
                        if(offer.cost == "X") {offer.cost = '"X"';}
                        nameElem.setAttribute("onclick", `if(gold >= ${cardCost}) {
gold -= ${cardCost};
deck.push(new Card("${offer.name}", ${offer.cost}, "${offer.type}", "${offer.desc}", ${offer.use}, ${JSON.stringify(offer.flags)}));
getId("cardElem_${i}").style.display = "none";
relics = relics.filter(x=>x.name!="Maw Bank");
updateStatLine();
}
                        `);
                        costElem.innerHTML = "🪙 "+cardCost;
                        cardElem.appendChild(nameElem);
                        cardElem.appendChild(costElem);
                        getId("merchantScreen").appendChild(cardElem);
                    }
                    getId("merchantScreen").innerHTML += "<br/>";
                    for(let i=0; i<3; i++) {
                        let offer = choice(choice(relicPool), choice(relicPool), choice(rareRelicPool));
                        let relicCost = Math.round(Math.random()*119 + 143);
                        offers.push({index: i+100, price: relicCost, offer: offer});
                        let relicElem = document.createElement("div");
                        let nameElem = document.createElement("button");
                        let costElem = document.createElement("div");
                        relicElem.setAttribute("id", `relicElem_${i}`);
                        relicElem.setAttribute("class", "shopRelic");
                        nameElem.setAttribute("id", `relicName_${i}`);
                        nameElem.setAttribute("class", "shopName");
                        nameElem.innerHTML = offer.name+"<span class='txt'>"+offer.desc+"</span>";
                        nameElem.setAttribute("class", "Status tt");
                        nameElem.setAttribute("onclick", `if(gold >= ${relicCost}) {
gold -= ${relicCost};
let r = ${JSON.stringify(offer)};
relics.push(r);
getId("relicElem_${i}").style.display = "none";
relics = relics.filter(x=>x.name!="Maw Bank");
updateStatLine();
}
                        `);
                        costElem.innerHTML = "🪙 "+relicCost;
                        relicElem.appendChild(nameElem);
                        relicElem.appendChild(costElem);
                        getId("merchantScreen").appendChild(relicElem);
                    }
                    
                    ifRelic("Smiling Mask", function(){crCost = 50;});
                    let crElem = document.createElement("div");
                    let nameElem = document.createElement("button");
                    let costElem = document.createElement("div");
                    crElem.setAttribute("id", "crElem");
                    nameElem.setAttribute("id", "crName");
                    nameElem.innerHTML = "Remove a card";
                    nameElem.setAttribute("class", "Power tt");
                    nameElem.setAttribute("onclick", `let fun = async function() { if(gold >= crCost) {
gold -= crCost;
crCost += 25;
let cardToRemove = await choose(deck, "Choose a card to remove.");
deck.splice(deck.indexOf(cardToRemove), 1);
getId("crElem").remove();
relics = relics.filter(x=>x.name!="Maw Bank");
updateStatLine();
                    }}; fun();`);
                    costElem.innerHTML = "🪙 "+crCost;
                    crElem.appendChild(nameElem);
                    crElem.appendChild(costElem);
                    getId("merchantScreen").appendChild(crElem);
                    
                    let continueElem = document.createElement("div");
                    let continueBtn = document.createElement("button");
                    continueBtn.innerHTML = "<span style='text-decoration:underline'>C</span>ontinue";
                    continueBtn.setAttribute("onclick", "showMap();");
                    continueElem.appendChild(continueBtn);
                    getId("merchantScreen").appendChild(continueElem);
                    /*debugging*/ } catch(err) {
                        alert("Oh no!\n"+err);
                    }
                } else if (map[y][x] == "❓") {
                    getId("mapScreen").style.display = "none";
                    getId("eventScreen").style.display = "block";
                    ifRelic("Sssserpent Head", function(){gold += 50;});
                    let event = choice([...possibleEvents["Act "+actNum.toString()], ...possibleEvents["All Acts"]]);
                    getId("eventTitle").innerHTML = event.title;
                    getId("eventDesc").innerHTML = event.desc;
                    getId("eventChoices").innerHTML = event.choices.map(x=>"<button class='eventButton tt' onclick='"+x[2]+"'>"+x[0]+"<span class='txt'>"+x[1]+"</span></button>").join(" ");
                }
            }
            let offers = [];
            
            //
            // Basics
            //
            let strike = () => new Card("Strike", 1, "Attack", "Deal [DAM6] damage.", function(enemy){
                dealDamage(enemy, 6, false, true);
            });
            let defend = () => new Card("Defend", 1, "Skill", "Gain [BLK5] Block.", function(enemy){
                gainBuff("Block", 5);
            });
            let bash = () => new Card("Bash", 2, "Attack", "Deal [DAM8] damage, apply 2 Vulnerable.", function(enemy){
                dealDamage(enemy, 8); enemy.gainBuff("Vulnerable", 2);
            });
            let neutralize = () => new Card("Neutralize", 0, "Attack", "Deal [DAM3] damage. Apply 1 Weak.", function(enemy){
                dealDamage(enemy, 3); enemy.gainBuff("Weak", 1);
            });
            let eruption = () => new Card("Eruption", 2, "Attack", "Deal [DAM9] damage. Enter Wrath.", function(enemy){
                dealDamage(enemy, 9); gainBuff("Wrath", 1);
            });
            let vigilance = () => new Card("Vigilance", 2, "Skill", "Gain [BLK8] Block. Enter Calm.", function(enemy){
                gainBuff("Block", 8); gainBuff("Calm", 1);
            });
            
            //
            // Commons
            //
            let bodySlam = () => new Card("Body Slam", 1, "Attack", "Deal damage equal to your Block. ([BLOCK] damage)", function(enemy){
                dealDamage(enemy, hasBuff("Block"));
            });
            let clash = () => new Card("Clash", 0, "Attack","Deal [DAM14] damage if all cards in your hand are Attacks.", function(enemy){
                if(!hand.map(x=>x.type=="Attack").includes(false)) {dealDamage(enemy, 14);}
            });
            let cleave = () => new Card("Cleave", 1, "Attack", "Deal [DAM8] damage to ALL enemies.", function(enemy){
                for(let e of enemies){dealDamage(e, 8);}
            });
            let clothesline = () => new Card("Clothesline", 2, "Attack", "Deal [DAM12] damage, apply 2 Weak.", function(enemy){
                dealDamage(enemy, 12); enemy.gainBuff("Weak", 2);
            });
            let flex = () => new Card("Flex", 0, "Skill", "Gain 2 Strength. At the end of your turn, lose 2 Strength.", function(enemy){
                gainBuff("Strength", 2); gainBuff("Strength Down", 2);
            });
            let headbutt = () => new Card("Headbutt", 1, "Attack", "Deal [DAM9] damage. Put a card from your discard pile on top of your draw pile.", async function(enemy){
                dealDamage(enemy, 9);
                let chosen = await choose(discardPile, "Choose a card to put on top of your Draw Pile.");
                if(chosen) {
                    drawPile.push(chosen);
                    discardPile.splice(discardPile.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let heavyBlade = () => new Card("Heavy Blade", 2, "Attack", "Deal [HEAVYBLADE] damage. Strength affects the damage 3 times.", function(enemy){
                dealDamage(enemy, 14 + 2 * hasBuff("Strength"));
            });
            let ironWave = () => new Card("Iron Wave", 1, "Attack", "Gain [BLK5] Block. Deal [DAM5] damage.", function(enemy){
                dealDamage(enemy, 5); gainBuff("Block", 5);
            });
            let pommelStrike = () => new Card("Pommel Strike", 1, "Attack", "Deal [DAM9] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 9, false, true); drawCard();
            });
            let shrugItOff = () => new Card("Shrug it Off", 1, "Skill", "Gain [BLK8] Block. Draw a card.", function(enemy){
                drawCard(); gainBuff("Block", 8);
            });
            let swordBoomerang = () => new Card("Sword Boomerang", 1, "Attack", "Deal [DAM3] damage to a random enemy 3 times.", function(enemy){
                let boom = () => dealDamage(choice(enemies), 3);
                boom(); boom(); boom();
            });
            let thunderclap = () => new Card("Thunderclap", 1, "Attack", "Deal [DAM4] damage and apply 1 Vulnerable to ALL enemies.", function(enemy){
                for(let e of enemies){dealDamage(e, 4); e.gainBuff("Vulnerable", 1);}
            });
            let trueGrit = () => new Card("True Grit", 1, "Skill", "Gain [BLK7] Block. Exhaust a random card in your hand.", function(enemy){
               gainBuff("Block", 7); let c=choice(hand); hand.splice(hand.indexOf(c), 1); exhaustPile.push(c);
            });
            let twinStrike = () => new Card("Twin Strike", 1, "Attack", "Deal [DAM5] damage twice.", function(enemy){
                dealDamage(enemy, 5, false, true); dealDamage(enemy, 5, false, true);
            });
            let wildStrike = () => new Card("Wild Strike", 1, "Attack", "Deal [DAM12] damage. Shuffle a Wound into your discard pile.", function(enemy){
                dealDamage(enemy, 12, false, true); discardPile.push(statusCards["Wound"]());
            });
            
            //
            // Uncommons
            //
            let battleTrance = () => new Card("Battle Trance", 0, "Skill", "Draw 3 cards. You cannot draw additional cards this turn.", function(enemy){
                drawCard(3); gainBuff("No Draw", 1);
            });
            let bloodForBlood = () => new Card("Blood for Blood", 4, "Attack", "Deal [DAM18] damage. -1 cost each time you lose HP.", function(enemy){
                dealDamage(enemy, 18);
            });
            let bloodletting = () => new Card("Bloodletting", 0, "Skill", "Lose 3 HP. Gain 2 energy.", function(enemy){
                hp -= 3; energy += 2;
            });
            let burningPact = () => new Card("Burning Pact", 1, "Skill", "Exhaust 1 card. Draw 2 cards.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name != "Burning Pact"), "Choose a card to Exhaust.");
                if(chosen) {
                    hand.splice(hand.indexOf(chosen), 1);
                    exhaustPile.push(chosen);
                }
                drawCard(2);
                updateHtml();
            });
            let carnage = () => new Card("Carnage", 2, "Attack", "Ethereal. Deal [DAM20] damage.", function(enemy){
                dealDamage(enemy, 20);
            }, ["ethereal"]);
            let combust = () => new Card("Combust", 1, "Power", "At the end of your turn, lose 1 HP and deal [DAM5] damage to ALL enemies.", function(enemy){
                gainBuff("Combust", 5);
            }, ["exhausted"]);
            let darkEmbrace = () => new Card("Dark Embrace", 2, "Power", "Whenever a card is Exhausted, draw a card.", function(enemy){
                gainBuff("Dark Embrace", 1);
            }, ["exhausted"]);
            let disarm = () => new Card("Disarm", 1, "Skill", "Enemy gets -2 Strength. Exhaust.", function(enemy){
                enemy.gainBuff("Minus Strength", 2);
            }, ["exhausted"]);
            let dropkick = () => new Card("Dropkick", 1, "Attack", "Deal [DAM5] damage. If the enemy has Vulnerable, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 5);
                if(enemy.hasBuff("Vulnerable")) {
                    energy++;
                    drawCard();
                }
            });
            let dualWield = () => new Card("Dual Wield", 1, "Skill", "Copy an Attack or Power card in your hand.", async function(enemy){
                let chosen = await choose(hand.filter(x=>["Attack","Power"].includes(x.type)), "Choose a card to copy.");
                if(chosen) {
                    hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                    updateHtml();
                } else {
                    alert("Failed to play Dual Wield: No Attack or Power cards in hand.");
                }
            });
            let entrench = () => new Card("Entrench", 2, "Skill", "Double your Block.", function(enemy){
                if(hasBuff("Block")) {gainBuff("Block", hasBuff("Block"));}
            });
            let evolve = () => new Card("Evolve", 1, "Power", "Whenever you draw a Status card, draw another card.", function(enemy){
                gainBuff("Evolve", 1);
            }, ["exhausted"]);
            let feelNoPain = () => new Card("Feel No Pain", 1, "Power", "When a card is Exhausted, gain [BLK3] Block.", function(enemy){
                gainBuff("Feel No Pain", 3);
            }, ["exhausted"]);
            let fireBreathing = () => new Card("Fire Breathing", 1, "Power", "Whenever you draw a Status card, deal 6 damage to ALL enemies.", function(enemy){
                gainBuff("Fire Breathing", 6);
            }, ["exhausted"]);
            let flameBarrier = () => new Card("Flame Barrier", 2, "Skill", "Gain [BLK12] Block and 2 Thorns.", function(enemy){
                gainBuff("Block", 12); gainBuff("Thorns", 2);
            });
            let ghostlyArmor = () => new Card("Ghostly Armor", 1, "Skill", "Ethereal. Gain [BLK10] Block.", function(enemy){
                gainBuff("Block", 10);
            }, ["ethereal"]);
            let hemokinesis = () => new Card("Hemokinesis", 1, "Attack", "Lose 2 HP. Deal [DAM15] damage.", function(enemy){
                hp -= 2; dealDamage(enemy, 15);
            });
            let infernalBlade = () => new Card("Infernal Blade", 0, "Skill", "Add a random Attack to your hand. Exhaust.", function(enemy){
                let extraCard = randCard();
                while(extraCard.type != "Attack") {extraCard = randCard();}
                hand.push(extraCard);
            }, ["exhausted"]);
            let inflame = () => new Card("Enflame", 1, "Power", "Gain 2 Strength.", function(enemy){
                gainBuff("Strength", 2);
            }, ["exhausted"]);
            let intimidate = () => new Card("Intimidate", 0, "Skill", "Apply 1 Weak to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {e.gainBuff("Weak", 1);}
            }, ["exhausted"]);
            let metallicize = () => new Card("Metallicize", 1, "Power", "Start each turn with [BLK3] Block.", function(enemy){
                gainBuff("Metallicize", 3);
            }, ["exhausted"]);
            let powerThrough = () => new Card("Power Through", 1, "Skill","Add 2 Wounds to your hand. Gain [BLK15] Block.", function(enemy){
                hand.push(statusCards["Wound"]()); hand.push(statusCards["Wound"]()); gainBuff("Block", 15);
            });
            let pummel = () => new Card("Pummel", 2, "Attack", "Deal [DAM2] damage 6 times.", function(enemy){
                dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);
            });
            let rage = () => new Card("Rage", 0, "Skill", "For each Attack you play this turn, gain [BLK3] Block.", function(enemy){
                gainBuff("Rage", 3);
            });
            let rampage = () => new Card("Rampage", 1, "Attack", "Deal [RAMPAGE] damage. This card deals 5 more damage this combat.", function(enemy){
                dealDamage(enemy, 8 + hasBuff("Rampage")); gainBuff("Rampage", 5);
            });
            let recklessCharge = () => new Card("Reckless Charge",0,"Attack","Deal [DAM7] damage. Get a Dazed card.", function(enemy){
                dealDamage(enemy, 7); discardPile.push(statusCards["Dazed"]());
            });
            let secondWind = () => new Card("Second Wind", 1, "Skill", "Exhaust all non-Attack cards in your hand. Gain [BLK5] Block for each card Exhausted.", function(enemy){
                for(let card of hand) {
                    if(card.type != "Attack") {
                        exhaustPile.push(card);
                        hand.splice(hand.indexOf(card), 1);
                        gainBuff("Block", 5);
                    }
                }
            });
            let seeingRed = () => new Card("Seeing Red", 0, "Skill", "Gain 1 energy. Exhaust.", function(enemy){
                energy += 1;
            }, ["exhausted"]);
            let severSoul = () => new Card("Sever Soul", 2, "Attack", "Exhaust all non-Attack cards in your hand. Deal [DAM16] damage.", function(enemy){
                for(let card of hand) {
                    if(card.type != "Attack") {
                        exhaustPile.push(card);
                        hand.splice(hand.indexOf(card), 1);
                    }
                }
                dealDamage(enemy, 16);
            });
            let spotWeakness = () => new Card("Spot Weakness", 1, "Skill", "If the enemy intends to attack, gain 3 Strength.", function(enemy){
                if(enemy.intent.intent.includes("attack")) {
                    gainBuff("Strength", 3);
                } else {
                    alert("Failed to play Spot Weakness: That enemy does not intend to attack.");
                }
            });
            let uppercut = () => new Card("Uppercut", 2, "Attack", "Deal [DAM13] damage. Apply 1 Weak and Vulnerable.", function(enemy){
                dealDamage(enemy, 13); enemy.gainBuff("Weak", 1); enemy.gainBuff("Vulnerable", 1);
            });
            let whirlwind = () => new Card("Whirlwind", "X", "Attack", "Deal [DAM5] damage to ALL enemies X times.", function(enemy){
                for(let e of enemies){dealDamage(e, 5);}
            });
            
            //
            // Rares
            //
            let barricade = () => new Card("Barricade", 3, "Power", "Block is not removed at the start of your turn.", function(enemy){
                gainBuff("Barricade", 1);
            }, ["exhausted"]);
            let berserk = () => new Card("Berserk", 0, "Power", "Gain 2 Vulnerable, but gain 1 more energy each turn.", function(enemy){
                gainBuff("Vulnerable", 2); gainBuff("Berserk", 1);
            }, ["exhausted"]);
            let bludgeon = () => new Card("Bludgeon", 3, "Attack", "Deal [DAM32] damage.", function(enemy){
                dealDamage(enemy, 32);
            });
            let brutality = () => new Card("Brutality", 0, "Power", "At the start of your turn, lose 1 HP and draw 1 more card.", function(enemy){
                gainBuff("Brutality", 1);
            }, ["exhausted"]);
            let demonForm = () => new Card("Demon Form", 3, "Power", "At the end of your turn, gain 2 Strength.", function(enemy){
                gainBuff("Ritual", 2);
            }, ["exhausted"]);
            let doubleTap = () => new Card("Double Tap", 1, "Skill", "Your next Attack is played twice.", function(enemy){
                gainBuff("Double Tap", 1);
            }, ["exhausted"]);
            let exhume = () => new Card("Exhume", 1, "Skill", "Put a card from your exhaust pile in your hand. Exhaust.", async function(enemy){
                let chosen = await choose(exhaustPile, "Choose a card to put into your hand.");
                if(chosen) {
                    hand.push(chosen);
                    exhaustPile.splice(exhaustPile.indexOf(chosen), 1);
                    updateHtml();
                } else {
                    alert("Failed to play Exhume: Exhaust pile is empty.");
                }
            }, ["exhausted"]);
            let feed = () => new Card("Feed", 1, "Skill", "Enemy loses 10 HP. If they die from it, gain 3 Max HP. Exhaust.", function(enemy){
                if(enemy.hp <= 10) {maxHp += 3; hp += 3;}
                enemy.hp -= 10;
            }, ["exhausted"]);
            let impervious = () => new Card("Impervious", 2, "Skill", "Gain [BLK30] Block. Exhaust.", function(enemy){
                gainBuff("Block", 30);
            }, ["exhausted"]);
            let juggernaut = () => new Card("Juggernaut", 2, "Power", "Whenever you gain Block, deal [DAM5] damage to a random enemy.", function(enemy){
                gainBuff("Juggernaut", 5);
            }, ["exhausted"]);
            let limitBreak = () => new Card("Limit Break", 1, "Skill", "Double your Strength. Exhaust.", function(enemy){
                if(hasBuff("Strength")) {gainBuff("Strength", hasBuff("Strength"));}
            }, ["exhausted"]);
            let offering = () => new Card("Offering", 0, "Skill", "Lose 6 HP. Gain 2 energy. Draw 3 cards. Exhaust.", function(enemy){
                hp -= 6; energy += 2; drawCard(3);
            }, ["exhausted"]);
            let reaper = () => new Card("Reaper", 2, "Attack", "Deal [DAM8] damage. Heal that much HP. Exhaust.", function(enemy){
                hp = Math.min(maxHp, hp + calcYourDamage(enemy, 8)); dealDamage(enemy, 8);
            }, ["exhausted"]);
            let corruption = () => new Card("Corruption", 3, "Power", "Skills cost 0. Whenever you play a Skill, exhaust it.", function(enemy) {
                gainBuff("Corruption", 1);
            }, ["exhausted"]);
            
            //
            // Silent Commons
            //
            let acrobatics = () => new Card("Acrobatics", 1, "Skill", "Draw 3 cards. Discard 1 card.", async function(enemy){
                drawCard(3);
                let chosen = await choose(hand.filter(x=>x.name!="Acrobatics"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let backflip = () => new Card("Backflip", 1, "Skill", "Gain [BLK5] Block. Draw 2 cards.", function(enemy){
                drawCard(2); gainBuff("Block", 5);
            });
            let bane = () => new Card("Bane", 1, "Attack", "Deal [DAM7] damage, twice if enemy has Poison.", function(enemy){
                dealDamage(enemy, 7); if(enemy.hasBuff("Poison")) {dealDamage(enemy, 7);}
            });
            let bladeDance = () => new Card("Blade Dance", 1, "Skill", "Add 3 Shivs to your hand.", function(enemy){
                addShivs(3);
            });
            let cloakAndDagger = () => new Card("Cloak and Dagger", 1, "Skill", "Gain [BLK6] Block. Add a Shiv to your hand.", function(enemy){
                addShivs(1); gainBuff("Block", 6);
            });
            let daggerSpray = () => new Card("Dagger Spray", 1, "Attack", "Deal [DAM4] damage to ALL enemies twice.", function(enemy){
                for(let e of enemies){dealDamage(e, 4);dealDamage(e, 4);}
            });
            let daggerThrow = () => new Card("Dagger Throw", 1, "Attack", "Deal [DAM9] damage. Draw a card. Discard a card.", async function(enemy){
                dealDamage(enemy, 9); drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Dagger Throw"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let deadlyPoison = () => new Card("Deadly Poison", 1, "Skill", "Apply 5 Poison.", function(enemy){
                enemy.gainBuff("Poison", 5);
            });
            let deflect = () => new Card("Deflect", 0, "Skill", "Gain [BLK4] Block.", function(enemy){
                gainBuff("Block", 4);
            });
            let dodgeAndRoll = () => new Card("Dodge and Roll", 1, "Skill", "Gain [BLK3] Block. Next turn, gain [BLK6] Block.", function(enemy){
                gainBuff("Block", 3); gainBuff("Next Turn Block", 6);
            });
            let flyingKnee = () => new Card("Flying Knee", 1, "Attack", "Deal [DAM8] damage. Gain 1 more energy next turn.", function(enemy){
                dealDamage(enemy, 8); gainBuff("Next Turn Energy", 1);
            });
            let outmaneuver = () => new Card("Outmaneuver", 1, "Skill", "Gain 2 more energy next turn.", function(enemy){
                gainBuff("Next Turn Energy", 2);
            });
            let poisonedStab = () => new Card("Poisoned Stab", 1, "Attack", "Deal [DAM6] damage. Apply 3 Poison.", function(enemy){
                dealDamage(enemy, 6); enemy.gainBuff("Poison", 3);
            });
            let prepared = () => new Card("Prepared", 0, "Skill", "Draw a card. Discard a card.", async function(enemy){
                drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let quickSlash = () => new Card("Quick Slash", 1, "Attack", "Deal [DAM8] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 8); drawCard();
            });
            let slice = () => new Card("Slice", 0, "Attack", "Deal [DAM6] damage.", function(enemy){
                dealDamage(enemy, 6);
            });
            let suckerPunch = () => new Card("Sucker Punch", 1, "Attack", "Deal [DAM7] damage. Apply 1 Weak.", function(enemy){
                dealDamage(enemy, 7); enemy.gainBuff("Weak", 1);
            });
            
            //
            // Silent Uncommons
            //
            let accuracy = () => new Card("Accuracy", 1, "Power", "Shivs deal 4 more damage.", function(enemy){
                gainBuff("Accuracy", 4);
            }, ["exhausted"]);
            let allOutAttack = () => new Card("All-Out Attack", 1, "Attack", "Deal [DAM10] damage to ALL enemies. Discard a random card.", function(enemy){
                for(let e of enemies) {dealDamage(e,10);}
                let chosen = choice(hand);
                discardPile.push(chosen);
                hand.splice(hand.indexOf(chosen), 1);
            });
            let backstab = () => new Card("Backstab", 0, "Attack", "Innate. Deal [DAM11] damage. Exhaust.", function(enemy){
                dealDamage(enemy, 11);
            }, ["exhausted", "innate"]);
            let blur = () => new Card("Blur", 1, "Skill", "Gain [BLK5] Block. Block is not removed next turn.", function(enemy){
                gainBuff("Blur", 1); gainBuff("Block", 5);
            });
            let bouncingFlask = () => new Card("Bouncing Flask", 2, "Skill", "Apply 9 Poison to a random enemy.", function(enemy){
                choice(enemies).gainBuff("Poison", 9);
            });
            let caltrops = () => new Card("Caltrops", 1, "Skill", "Gain 3 Thorns. Exhaust.", function(enemy){
                gainBuff("Thorns", 3);
            }, ["exhausted"]);
            let catalyst = () => new Card("Catalyst", 1, "Skill", "Double the enemy's Poison. Exhaust.", function(enemy){
                enemy.gainBuff("Poison", enemy.hasBuff("Poison"));
            }, ["exhausted"]);
            let concentrate = () => new Card("Concentrate", 0, "Skill", "Discard 3 cards. Gain 2 energy.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
                let chosen3 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a third card to discard.");
                if(chosen3) {
                    discardPile.push(chosen3);
                    hand.splice(hand.indexOf(chosen3), 1);
                    updateHtml();
                }
                energy += 2;
                updateHtml();
            });
            let cripplingCloud = () => new Card("Crippling Cloud", 2, "Skill", "Apply 4 Poison and 2 Weak to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {e.gainBuff("Poison", 4); e.gainBuff("Weak", 2); updateHtml();}
            }, ["exhausted"]);
            let dash = () => new Card("Dash", 2, "Attack", "Deal [DAM10] damage. Gain [BLK10] Block.", function(enemy){
                dealDamage(enemy, 10); gainBuff("Block", 10);
            });
            let distraction = () => new Card("Distraction", 0, "Skill", "Add a random Skill to your hand. Exhaust.", function(enemy){
                let extraCard = randCard();
                while(extraCard.type != "Skill") {extraCard = randCard();}
                hand.push(extraCard);
            }, ["exhausted"]);
            let escapePlan = () => new Card("Escape Plan", 0, "Skill", "Draw a card. If it's a Skill, gain [BLK3] Block.", function(enemy){
                drawCard();
                if(hand[hand.length - 1].type == "Skill") {gainBuff("Block", 3);}
            });
            let expertise = () => new Card("Expertise", 1, "Skill", "Draw cards until you have 6 in hand.", function(enemy){
                if(hand.length < 6) {drawCard(6 - hand.length);}
            });
            let finisher = () => new Card("Finisher", 1, "Attack", "Deal 6 damage for each Attack played this turn. (Deals [FINISHER] damage)", function(enemy){
                dealDamage(enemy, stats.attacksThisTurn * 6);
            });
            let footwork = () => new Card("Footwork", 1, "Power", "Gain 2 Dexterity.", function(enemy){
                gainBuff("Dexterity", 2);
            }, ["exhausted"]);
            let heelHook = () => new Card("Heel Hook", 1, "Attack", "Deal [DAM5] damage. If the enemy has Weak, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 5);
                if(enemy.hasBuff("Weak")) {energy += 1; drawCard();}
            });
            let infiniteBlades = () => new Card("Infinite Blades", 1, "Power", "At the start of your turn, add a Shiv into your hand.", function(enemy){
                gainBuff("Infinite Blades", 1);
            }, ["exhausted"]);
            let legSweep = () => new Card("Leg Sweep", 2, "Skill", "Apply 2 Weak. Gain [BLK11] Block.", function(enemy){
                gainBuff("Block", 11); enemy.gainBuff("Weak", 2);
            });
            let noxiousFumes = () => new Card("Noxious Fumes", 1, "Power", "At the start of your turn, apply 2 Poison to ALL enemies.", function(enemy){
                gainBuff("Noxious Fumes", 2);
            }, ["exhausted"]);
            let predator = () => new Card("Predator", 2, "Attack", "Deal [DAM15] damage. Next turn, draw 2 more cards.", function(enemy){
                dealDamage(enemy, 15); gainBuff("Next Turn Cards", 2);
            });
            let skewer = () => new Card("Skewer", "X", "Attack", "Deal [DAM7] damage X times.", function(enemy){
                dealDamage(enemy, 7);
            });
            let terror = () => new Card("Terror", 1, "Skill", "Apply 999 Vulnerable. Exhaust.", function(enemy){
                enemy.gainBuff("Vulnerable", 999);
            }, ["exhausted"]);
            
            //
            // Silent Rares
            //
            let thousandCuts = () => new Card("A Thousand Cuts", 2, "Power", "Whenever you play a card, deal [DAM1] damage to ALL enemies.", function(enemy) {
                gainBuff("Thousand Cuts", 1);
            }, ["exhausted"]);
            let adrenaline = () => new Card("Adrenaline", 0, "Skill", "Gain 1 energy. Draw 2 cards. Exhaust.", function(enemy){
                energy += 1; drawCard(2);
            }, ["exhausted"]);
            let afterImage = () => new Card("After Image", 1, "Power", "Whenever you play a card, gain [BLK1] Block.", function(enemy){
                gainBuff("After Image", 1);
            }, ["exhausted"]);
            let burst = () => new Card("Burst", 1, "Skill", "Your next Skill is played twice.", function(enemy){
                gainBuff("Burst", 1);
            });
            let dieDieDie = () => new Card("Die Die Die", 1, "Attack", "Deal [DAM13] damage to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {dealDamage(e, 13);}
            }, ["exhausted"]);
            let doppelganger = () => new Card("Doppelganger", "X", "Skill", "Next turn, draw X more cards and gain X more energy. Exhaust.", function(enemy){
                gainBuff("Next Turn Cards", 1); gainBuff("Next Turn Energy", 1);
            }, ["exhausted"]);
            let envenom = () => new Card("Envenom", 2, "Power", "Whenever you deal unblocked damage, apply 1 Poison.", function(enemy){
                gainBuff("Envenom", 1);
            }, ["exhausted"]);
            let grandFinale = () => new Card("Grand Finale", 0, "Attack", "If there are no cards in your draw pile, deal [DAM50] damage to ALL enemies.", function(enemy) {
                if(drawPile.length == 0) {for(let e of enemies){dealDamage(e, 50);}} else {alert("Failed to play Grand Finale: There are cards in your draw pile.");}
            });
            let stormOfSteel = () => new Card("Storm of Steel", 1, "Skill", "Replace your hand with Shivs.", function(enemy){
                let handSize = hand.length;
                for(let i of hand) {discardPile.push(i);}
                hand = [];
                addShivs(handSize);
            });
            let toolsOfTheTrade = () => new Card("Tools of the Trade", 1, "Power", "At the start of your turn, draw a card and discard a card.", function(enemy){
                gainBuff("Tools of the Trade", 1);
            }, ["exhausted"]);
            //
            // Watcher Commons
            //
            let bowlingBash = () => new Card("Bowling Bash", 1, "Attack", "Deal [DAM7] damage for each enemy in combat.", function(enemy){
                dealDamage(enemy, 7 * enemies.length);
            });
            let consecrate = () => new Card("Consecrate", 0, "Attack", "Deal [DAM5] damage to ALL enemies.", function(enemy){
                for(let i of enemies){dealDamage(i, 5);}
            });
            let crescendo = () => new Card("Crescendo", 1, "Skill", "Retain. Enter Wrath. Exhaust.", function(enemy){
                gainBuff("Wrath", 1);
            }, ["retain", "exhausted"]);
            let crushJoints = () => new Card("Crush Joints", 1, "Attack", "Deal [DAM8] damage. If the last card played this combat was a Skill, apply 1 Vulnerable.", function(enemy){
                dealDamage(enemy, 8); if(stats.lastType == "Skill") {enemy.gainBuff("Vulnerable", 1);}
            });
            let cutThroughFate = () => new Card("Cut Through Fate", 1, "Attack", "Deal [DAM7] damage. Scry 2. Draw a card.", function(enemy){
                dealDamage(enemy, 7); scry(2); drawCard(1);
            });
            let emptyBody = () => new Card("Empty Body", 1, "Skill", "Gain [BLK7] Block. Exit your stance.", function(enemy){
                gainBuff("Block", 7); loseBuff("Wrath"); loseBuff("Calm"); loseBuff("Divinity");
            });
            let emptyFist = () => new Card("Empty Fist", 1, "Attack", "Deal [DAM9] damage. Exit your stance.", function(enemy){
                dealDamage(enemy, 9); loseBuff("Wrath"); loseBuff("Calm"); loseBuff("Divinity");
            });
            let evaluate = () => new Card("Evaluate", 1, "Skill", "Gain [BLK6] Block. Shuffle an Insight into your draw pile.", function(enemy){
                gainBuff("Block", 6); addInsights(1);
                drawPile = shuffle(drawPile);
            });
            let flurryOfBlows = () => new Card("Flurry of Blows", 0, "Attack", "Deal [DAM4] damage. When you change stances, return this from discard to hand.", function(enemy){
                dealDamage(enemy, 4);
            });
            let flyingSleeves = () => new Card("Flying Sleeves", 1, "Attack", "Retain. Deal [DAM4] damage twice.", function(enemy){
                dealDamage(enemy, 4); dealDamage(enemy, 4);
            }, ["retain"]);
            let followUp = () => new Card("Follow Up", 1, "Attack", "Deal [DAM7] damage. If the last card played this combat was an Attack, gain 1 energy.", function(enemy){
                dealDamage(enemy, 7); if(stats.lastType == "Attack") {energy += 1;}
            });
            let halt = () => new Card("Halt", 0, "Skill", "Gain [BLK3] Block. If you're in Wrath, gain [BLK9] more Block.", function(enemy){
                gainBuff("Block", 3); if(hasBuff("Wrath")) {gainBuff("Block", 9);}
            });
            let justLucky = () => new Card("Just Lucky", 0, "Attack", "Scry 1, gain [BLK2] Block, deal [DAM3] damage.", function(enemy){
                scry(1); gainBuff("Block", 2); dealDamage(enemy, 3);
            });
            let pressurePoints = () => new Card("Pressure Points", 1, "Skill", "Apply 8 Mark. ALL enemies lose HP equal to their Mark.", function(enemy){
                enemy.gainBuff("Mark", 8); for(let e of enemies) {e.hp -= e.hasBuff("Mark");}
            });
            let precision = () => new Card("Precision", 1, "Power", "Deal 1 more damage for every 5 Mark on target.", function(enemy){
                gainBuff("Precision", 1);
            }, ["exhausted"]);
            let predict = () => new Card("Predict", 1, "Skill", "Apply 7 Mark. Gain Block equal to Mark on ALL enemies. (Gains [PREDICT] Block)", function(enemy){
                enemy.gainBuff("Mark", 7); let b=0; for(let i of enemies) {b += i.hasBuff("Mark");} gainBuff("Block", b);
            }, ["exhausted"]);
            let prostrate = () => new Card("Prostrate", 0, "Skill", "Gain 2 Mantra. Gain [BLK4] Block.", function(enemy){
                gainBuff("Mantra", 2); gainBuff("Block", 4);
            });
            let protect = () => new Card("Protect", 2, "Skill", "Retain. Gain [BLK12] Block.", function(enemy){
                gainBuff("Block", 12);
            }, ["retain"]);
            let sashWhip = () => new Card("Sash Whip", 1, "Attack", "Deal [DAM8] damage. If the last card played this combat was an Attack, apply 1 Weak.", function(enemy){
                dealDamage(enemy, 8); if(stats.lastType == "Attack") {enemy.gainBuff("Weak", 1);}
            });
            let thirdEye = () => new Card("Third Eye", 1, "Skill", "Gain [BLK7] Block. Scry 3.", function(enemy){
                gainBuff("Block", 7); scry(3);
            });
            let tranquility = () => new Card("Tranquility", 1, "Skill", "Enter Calm. Retain. Exhaust.", function(enemy){
                gainBuff("Calm", 1);
            }, ["exhausted", "retain"]);
            //
            // Watcher Uncommons
            //
            let battleHymn = () => new Card("Battle Hymn", 1, "Power", "At the start of your turn, add a Smite to your hand.", function(enemy){
                gainBuff("Battle Hymn", 1);
            }, ["exhausted"]);
            let carveReality = () => new Card("Carve Reality", 1, "Attack", "Deal [DAM6] damage. Add a Smite to your hand.", function(enemy){
                dealDamage(enemy, 6); addSmites(1);
            });
            let collect = () => new Card("Collect", "X", "Skill", "Put a Miracle+ into your hand each turn for X turns. Exhaust.", function(enemy){
                gainBuff("Collect", 1);
            }, ["exhausted"]);
            let conclude = () => new Card("Conclude", 1, "Attack", "Deal [DAM11] damage to ALL enemies. Discard your hand.", function(enemy){
                for(let e of enemies){dealDamage(e, 11);} discardPile = [...discardPile, ...hand]; hand = [];
            });
            let deceiveReality = () => new Card("Deceive Reality", 1, "Skill", "Gain [BLK4] Block. Add a Safety to your hand.", function(enemy){
                gainBuff("Block", 4); hand.push(new Card("Safety", 1, "Skill", "Gain [BLK12] Block. Retain. Exhaust.", function(enemy){gainBuff("Block", 12);}, ["retain", "exhaust"]));
            });
            let emptyMind = () => new Card("Empty Mind", 1, "Skill", "Draw 2 cards. Exit your stance.", function(enemy){
                drawCard(2); loseBuff("Wrath"); loseBuff("Calm"); loseBuff("Divinity");
            });
            let fasting = () => new Card("Fasting", 2, "Power", "Gain 4 Strength and 4 Dexterity, but gain 1 less energy each turn.", function(enemy){
                gainBuff("Strength", 4); gainBuff("Dexterity", 4); gainBuff("Fasting", 1);
            }, ["exhausted"]);
            let fearNoEvil = () => new Card("Fear No Evil", 1, "Attack", "Deal [DAM8] damage. If the enemy intends to attack, enter Calm.", function(enemy){
                dealDamage(enemy, 8); if(enemy.intent.intent.includes("attack")) {gainBuff("Calm", 1);}
            });
            let foresight = () => new Card("Foresight", 1, "Power", "At the start of your turn, scry 3.", function(enemy){
                gainBuff("Foresight", 3);
            }, ["exhausted"]);
            let indignation = () => new Card("Indignation", 1, "Skill", "If you are in Wrath, apply 3 Vulnerable to ALL enemies, otherwise enter Wrath.", function(enemy){
                if(hasBuff("Wrath")) {for(let e of enemies){e.gainBuff("Vulnerable", 3);}} else {gainBuff("Wrath", 1);}
            });
            let innerPeace = () => new Card("Inner Peace", 1, "Skill", "If you are in Calm, draw 3 cards, otherwise enter Calm.", function(enemy){
                if(hasBuff("Calm")) {drawCard(3);} else {gainBuff("Calm", 1);}
            });
            let likeWater = () => new Card("Like Water", 1, "Power", "If you end your turn in Calm, gain [BLK5] Block.", function(enemy){
                gainBuff("Like Water", 5);
            }, ["exhausted"]);
            let mentalFortress = () => new Card("Mental Fortress", 1, "Power", "Whenever you switch stances, gain [BLK3] Block.", function(enemy){
                gainBuff("Mental Fortress", 3);
            }, ["exhausted"]);
            let nirvana = () => new Card("Nirvana", 1, "Power", "Whenever you scry, gain [BLK4] Block.", function(enemy){
                gainBuff("Nirvana", 4);
            }, ["exhausted"]);
            let perseverance = () => new Card("Perseverance", 1, "Skill", "Gain [PERS] Block. Retain. When this is Retained, it gets +2 Block this combat.", function(enemy){
                gainBuff("Block", 5 + stats.pers);
            }, ["retain"]);
            let pray = () => new Card("Pray", 1, "Skill", "Gain 3 Mantra. Shuffle an Insight into your draw pile.", function(enemy){
                gainBuff("Mantra", 3); addInsights(1);
            });
            let reachHeaven = () => new Card("Reach Heaven", 2, "Attack", "Deal [DAM10] damage. Shuffle a Through Violence into your draw pile.", function(enemy){
                dealDamage(enemy, 10); drawPile.push(new Card("Through Violence", 0, "Attack", "Retain. Deal [DAM20] damage. Exhaust.", function(enemy){dealDamage(enemy,20);}, ["retain", "exhausted"])); drawPile = shuffle(drawPile);
            });
            let rushdown = () => new Card("Rushdown", 1, "Power", "Whenever you enter Wrath, draw 2 cards.", function(enemy){
                gainBuff("Rushdown", 2);
            }, ["exhausted"]);
            let sanctity = () => new Card("Sanctity", 1, "Skill", "Gain [BLK6] Block. If the last card played this combat was a Skill, draw 2 cards.", function(enemy) {
                gainBuff("Block", 6); if(stats.lastType = "Skill") {drawCard(2);}
            });
            let sandsOfTime = () => new Card("Sands of Time", 4, "Attack", "Deal [DAM20] damage. Retain. When this is Retained, it gets -1 cost this combat.", function(enemy){
                dealDamage(enemy, 20);
            }, ["retain"]);
            let signatureMove = () => new Card("Signature Move", 2, "Attack", "Can only be played if this is the only Attack in your hand. Deal [DAM30] damage.", function(enemy){
                if(!hand.filter(x=>x.type=="Attack"&&!x.name.includes("Signature Move")).length) {dealDamage(enemy, 30);}
            });
            let simmeringFury = () => new Card("Simmering Fury", 1, "Skill", "At the start of your next turn, enter Wrath and draw 2 cards.", function(enemy){
                gainBuff("Simmering Fury", 1); gainBuff("Next Turn Cards", 2);
            });
            let study = () => new Card("Study", 2, "Power", "At end of turn, shuffle an Insight into your draw pile", function(enemy){
                gainBuff("Study", 1);
            }, ["exhausted"]);
            let swivel = () => new Card("Swivel", 2, "Skill", "Gain [BLK8] Block. The next Attack you play costs 0.", function(enemy){
                gainBuff("Block", 8), gainBuff("Swivel", 1);
            });
            let talkToTheHand = () => new Card("Talk to the Hand", 1, "Attack", "Deal [DAM5] damage. Whenever you attack this enemy, gain [BLK2] Block. Exhaust.", function(enemy){
                dealDamage(enemy, 5); enemy.gainBuff("Talk to the Hand", 2);
            }, ["exhausted"]);
            let tantrum = () => new Card("Tantrum", 1, "Attack", "Deal [DAM3] damage 3 times. Enter Wrath. Shuffle this into your draw pile.", function(enemy){
                dealDamage(enemy,3);dealDamage(enemy,3);dealDamage(enemy,3); gainBuff("Wrath", 1);
            });
            let wallop = () => new Card("Wallop", 2, "Attack", "Deal [DAM9] damage. Gain Block equal to unblocked damage dealt.", function(enemy){
                gainBuff("Block", calcYourDamage(enemy, 9) - enemy.hasBuff("Block")); dealDamage(enemy, 9);
            });
            let waveOfTheHand = () => new Card("Wave of the Hand", 1, "Skill", "Whenever you gain Block this turn, apply 1 Weak to ALL enemies.", function(enemy){
                gainBuff("Wave of the Hand", 1);
            });
            let weave = () => new Card("Weave", 0, "Attack", "Deal [DAM5] damage. Whenever you scry, return this from discard to hand.", function(enemy){
                dealDamage(enemy, 4);
            });
            let wheelKick = () => new Card("Wheel Kick", 2, "Attack", "Deal [DAM15] damage. Draw 2 cards.", function(enemy){
                dealDamage(enemy, 15); drawCard(2);
            });
            let windmillStrike = () => new Card("Windmill Strike", 2, "Attack", "Retain. Deal [WINDMILL] damage. When Retained, it gets +4 damage this combat.", function(enemy){
                dealDamage(enemy, 7 + stats.windmill);
            }, ["retain"]);
            let worship = () => new Card("Worship", 2, "Skill", "Gain 5 Mantra.", function(enemy){
                gainBuff("Mantra", 5);
            });
            let wreathOfFlame = () => new Card("Wreath of Flame", 1, "Skill", "Your next attack deals 5 more damage.", function(enemy){
                gainBuff("Vigor", 5);
            });
            //
            // Watcher Rares
            //
            let alpha = () => new Card("Alpha", 1, "Skill", "Shuffle a Beta into your draw pile. Exhaust.", function(enemy){
                drawPile.push(
                    new Card("Beta", 1, "Skill", "Shuffle an Omega into your draw pile. Exhaust.", function(enemy){
                        drawPile.push(
                            new Card("Omega", 0, "Power", "At the end of your turn, deal [DAM50] damage to ALL enemies.", function(enemy){gainBuff("Omega", 50);}, ["exhausted"])
                        );
                    }, ["exhausted"])
                );
            }, ["exhausted"]);
            let blasphemy = () => new Card("Blasphemy", 1, "Skill", "Enter Divinity. Die next turn. Exhaust.", function(enemy){
                gainBuff("Divinity", 1); gainBuff("Blasphemy", 1);
            }, ["exhausted"]);
            let brilliance = () => new Card("Brilliance", 1, "Attack", "Deal [BRILLIANCE] damage. More effective based on Mantra gained this combat.", function(enemy){
                dealDamage(enemy, 12 + stats.mantraGain);
            });
            let conjureBlade = () => new Card("Conjure Blade", "X", "Skill", "Shuffle X Expungers into your draw pile. Exhaust.", function(enemy){
                drawPile.push(new Card("Expunger", 0, "Attack", "Deal [DAM4] damage. Draw a card.", function(enemy){dealDamage(enemy,4);drawCard();}));
            }, ["exhausted"]);
            let deusExMachina = () => new Card("Deus Ex Machina", 0, "Skill", "Add 2 Miracles to your hand. Exhaust.", function(enemy){
                hand.push(new Card("Miracle", 0, "Skill", "Retain. Gain 1 energy. Exhaust.", function(enemy){energy += 1;}, ["exhausted", "retain"]));
                hand.push(new Card("Miracle", 0, "Skill", "Retain. Gain 1 energy. Exhaust.", function(enemy){energy += 1;}, ["exhausted", "retain"]));
            }, ["exhausted"]);
            let devaForm = () => new Card("Deva Form", 3, "Power", "Ethereal. At the start of your turn, gain 1 energy and increase the gain by 1.", function(enemy){
                gainBuff("Deva Form", 1);
            }, ["exhausted", "ethereal"]);
            let devotion = () => new Card("Devotion", 1, "Power", "At the start of your turn, gain 2 Mantra.", function(enemy){
                gainBuff("Devotion", 2);
            }, ["exhausted"]);
            let establishment = () => new Card("Establishment", 1, "Power", "When a card is Retained, it gets -1 cost this combat.", function(enemy){
                gainBuff("Establishment", 1);
            }, ["exhausted"]);
            let judgment = () => new Card("Judgment", 1, "Skill", "If the enemy has 30 or less HP, set their HP to 0.", function(enemy){
                if(enemy.hp <= 30) dealDamage(enemy, 9999);
            });
            let lessonLearned = () => new Card("Lesson Learned", 2, "Attack", "Deal [DAM10] damage. If fatal, upgrade a random card in your deck. Exhaust.", function(enemy){
                if(calcYourDamage(enemy, 10) >= (enemy.hp + enemy.hasBuff("Block"))) {
                    let eligible = deck.filter(x=>!x.name.includes("+"));
                    if(eligible.length) {
                        let card = choice(eligible);
                        upgradeCard(card);
                    }
                }
                dealDamage(enemy, 10);
            }, ["exhausted"]);
            let ragnarok = () => new Card("Ragnarok", 3, "Attack", "Deal [DAM5] damage to a random enemy 5 times.", function(enemy){
                for(let i=0; i<5; i++) {
                    dealDamage(choice(enemies), 5);
                }
            });
            let scrawl = () => new Card("Scrawl", 1, "Skill", "Draw cards until your hand is full. Exhaust.", function(enemy){
                drawCard(10);
            }, ["exhausted"]);
            let spiritShield = () => new Card("Spirit Shield", 2, "Skill", "Gain [BLK3] Block for each card in your hand.", function(enemy){
                for(let i=0; i<hand.length; i++) {
                    gainBuff("Block", 3);
                }
            });
            let vault = () => new Card("Vault", 3, "Skill", "Take another turn after this one. Exhaust.", function(enemy){
                gainBuff("Vault", 1);
            }, ["exhausted"]);
            let wish = () => new Card("Wish", 3, "Skill", "Gain 1 Metallicize, 1 Strength, and 8 Gold. Exhaust.", function(enemy){
                gainBuff("Strength", 1);
                gainBuff("Metallicize", 1);
                gold += 8;
            }, ["exhausted"]);
            //
            // Upgraded Cards
            //
            let upgradedCards = {
                "Strike": () => new Card("Strike+", 1, "Attack", "Deal [DAM9] damage.", function(enemy){
                    dealDamage(enemy, 9, false, true);
                }), "Defend": () => new Card("Defend+", 1, "Skill", "Gain [BLK8] Block.", function(enemy){
                    gainBuff("Block", 8);
                }), "Bash": () => new Card("Bash+", 2, "Attack", "Deal [DAM10] damage, apply 3 Vulnerable.", function(enemy){
                    dealDamage(enemy, 10); enemy.gainBuff("Vulnerable", 3);
                }), "Neutralize": () => new Card("Neutralize+", 0, "Attack", "Deal [DAM4] damage. Apply 2 Weak.", function(enemy){
                    dealDamage(enemy, 4); enemy.gainBuff("Weak", 2);
                }), "Eruption": () => new Card("Eruption+", 1, "Attack", "Deal [DAM9] damage. Enter Wrath.", function(enemy){
                    dealDamage(enemy, 9); gainBuff("Wrath", 1);
                }), "Vigilance": () => new Card("Vigilance+", 2, "Skill", "Gain [BLK12] Block. Enter Calm.", function(enemy){
                    gainBuff("Block", 12); gainBuff("Calm", 1);
                }), "Body Slam": () => new Card("Body Slam+", 0, "Attack", "Deal damage equal to your Block. ([BLOCK] damage)", function(enemy){
                    dealDamage(enemy, hasBuff("Block"));
                }), "Clash": () => new Card("Clash+", 0, "Attack","Deal [DAM18] damage if all cards in your hand are Attacks.", function(enemy){
                    if(!hand.map(x=>x.type=="Attack").includes(false)) {dealDamage(enemy, 18);}
                }), "Cleave": () => new Card("Cleave+", 1, "Attack", "Deal [DAM11] damage to ALL enemies.", function(enemy){
                    for(let e of enemies){dealDamage(e, 11);}
                }), "Clothesline": () => new Card("Clothesline+", 2, "Attack", "Deal [DAM14] damage, apply 3 Weak.", function(enemy){
                    dealDamage(enemy, 14); enemy.gainBuff("Weak", 3);
                }), "Flex": () => new Card("Flex+", 0, "Skill", "Gain 4 Strength. At the end of your turn, lose 4 Strength.", function(enemy){
                    gainBuff("Strength", 4); gainBuff("Strength Down", 4);
                }), "Headbutt": () => new Card("Headbutt", 1, "Attack", "Deal [DAM12] damage. Put a card from your discard pile on top of your draw pile.", async function(enemy){
                    dealDamage(enemy, 12);
                    let chosen = await choose(discardPile, "Choose a card to put on top of your Draw Pile.");
                    if(chosen) {
                        drawPile = [chosen, ...drawPile];
                        discardPile.splice(discardPile.indexOf(chosen), 1);
                        updateHtml();
                    }
                }), "Heavy Blade": () => new Card("Heavy Blade+", 2, "Attack", "Deal [HEAVYBLADE+] damage. Strength affects the damage 5 times.", function(enemy){
                    dealDamage(enemy, 14 + 4 * hasBuff("Strength"));
                }), "Iron Wave": () => new Card("Iron Wave+", 1, "Attack", "Gain [BLK7] Block. Deal [DAM7] damage.", function(enemy){
                    dealDamage(enemy, 7); gainBuff("Block", 7);
                }), "Pommel Strike": () => new Card("Pommel Strike+", 1, "Attack", "Deal [DAM10] damage. Draw 2 cards.", function(enemy){
                    dealDamage(enemy, 10, false, true); drawCard(2);
                }), "Shrug it Off": () => new Card("Shrug it Off+", 1, "Skill", "Gain [BLK11] Block. Draw a card.", function(enemy){
                    drawCard(); gainBuff("Block", 11);
                }), "Sword Boomerang": () => new Card("Sword Boomerang+", 1, "Attack", "Deal [DAM3] damage to a random enemy 4 times.", function(enemy){
                    dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3);
                }), "Thunderclap": () => new Card("Thunderclap+", 1, "Attack", "Deal [DAM7] damage and apply 1 Vulnerable to ALL enemies.", function(enemy){
                    for(let e of enemies){dealDamage(e, 7); e.gainBuff("Vulnerable", 1);}
                }), "True Grit": () => new Card("True Grit+", 1, "Skill", "Gain [BLK7] Block. Exhaust a card in your hand.", async function(enemy){
                    gainBuff("Block", 7);
                    let chosen = await choose(hand, "Choose a card to Exhaust.");
                    if(chosen) {
                        hand.splice(hand.indexOf(chosen), 1);
                        exhaustPile.push(chosen);
                        updateHtml();
                    }
                }), "Twin Strike": () => new Card("Twin Strike+", 1, "Attack", "Deal [DAM7] damage twice.", function(enemy){
                    dealDamage(enemy, 7, false, true); dealDamage(enemy, 7, false, true);
                }), "Wild Strike": () => new Card("Wild Strike+", 1, "Attack", "Deal [DAM17] damage. Shuffle a Wound into your discard pile.", function(enemy){
                    dealDamage(enemy, 17, false, true); discardPile.push(statusCards["Wound"]());
                }), "Battle Trance": () => new Card("Battle Trance+", 0, "Skill", "Draw 4 cards. You cannot draw additional cards this turn.", function(enemy){
                    drawCard(4); gainBuff("No Draw", 1);
                }), "Blood for Blood": () => new Card("Blood for Blood+", 4, "Attack", "Deal [DAM26] damage. -1 cost each time you lose HP.", function(enemy){
                    dealDamage(enemy, 26);
                }), "Bloodletting": () => new Card("Bloodletting+", 0, "Skill", "Lose 3 HP. Gain 3 energy.", function(enemy){
                    hp -= 3; energy += 3;
                }), "Burning Pact": () => new Card("Burning Pact+", 1, "Skill", "Exhaust 1 card. Draw 3 cards.", async function(enemy){
                    let chosen = await choose(hand, "Choose a card to Exhaust.");
                    if(chosen) {
                        hand.splice(hand.indexOf(chosen), 1);
                        exhaustPile.push(chosen);
                    }
                    drawCard(3);
                    updateHtml();
                }), "Carnage": () => new Card("Carnage+", 2, "Attack", "Ethereal. Deal [DAM28] damage.", function(enemy){
                    dealDamage(enemy, 28);
                }, ["ethereal"]), "Combust": () => new Card("Combust+", 1, "Power", "At the end of your turn, lose 1 HP and deal [DAM7] damage to ALL enemies.", function(enemy){
                    gainBuff("Combust", 7);
                }, ["exhausted"]), "Dark Embrace": () => new Card("Dark Embrace+", 1, "Power", "Whenever a card is Exhausted, draw a card.", function(enemy){
                    gainBuff("Dark Embrace", 1);
                }, ["exhausted"]), "Disarm": () => new Card("Disarm+", 1, "Skill", "Enemy gets -3 Strength. Exhaust.", function(enemy){
                    enemy.gainBuff("Minus Strength", 3);
                }, ["exhausted"]), "Dropkick": () => new Card("Dropkick+", 1, "Attack", "Deal [DAM8] damage. If the enemy has Vulnerable, gain 1 energy and draw a card.", function(enemy){
                    dealDamage(enemy, 8);
                    if(enemy.hasBuff("Vulnerable")) {
                        energy++;
                        drawCard();
                    }
                }), "Dual Wield": () => new Card("Dual Wield+", 1, "Skill", "Create 2 copies of an Attack or Power card in your hand.", async function(enemy){
                    let chosen = await choose(hand.filter(x=>["Attack","Power"].includes(x.type)), "Choose a card to copy.");
                    if(chosen) {
                        hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                        hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                        updateHtml();
                    } else {
                        alert("Failed to play Dual Wield: No Attack or Power cards in hand.");
                    }
                }), "Entrench": () => new Card("Entrench+", 1, "Skill", "Double your Block.", function(enemy){
                    if(hasBuff("Block")) {gainBuff("Block", hasBuff("Block"));}
                }), "Evolve": () => new Card("Evolve+", 1, "Power", "Whenever you draw a Status card, draw 2 more cards.", function(enemy){
                    gainBuff("Evolve", 2);
                }, ["exhausted"]), "Feel No Pain": () => new Card("Feel No Pain+", 1, "Power", "When a card is Exhausted, gain [BLK4] Block.", function(enemy){
                    gainBuff("Feel No Pain", 4);
                }, ["exhausted"]), "Fire Breathing": () => new Card("Fire Breathing+", 1, "Power", "Whenever you draw a Status card, deal 10 damage to ALL enemies.", function(enemy){
                    gainBuff("Fire Breathing", 10);
                }, ["exhausted"]), "Flame Barrier": () => new Card("Flame Barrier+", 2, "Skill", "Gain [BLK16] Block and 3 Thorns.", function(enemy){
                    gainBuff("Block", 16); gainBuff("Thorns", 3);
                }), "Ghostly Armor": () => new Card("Ghostly Armor+", 1, "Skill", "Ethereal. Gain [BLK13] Block.", function(enemy){
                    gainBuff("Block", 13);
                }, ["ethereal"]), "Hemokinesis": () => new Card("Hemokinesis+", 1, "Attack", "Lose 2 HP. Deal [DAM20] damage.", function(enemy){
                    hp -= 2; dealDamage(enemy, 20);
                }), "Infernal Blade": () => new Card("Infernal Blade+", 0, "Skill", "Add 2 random Attacks to your hand. Exhaust", function(enemy){
                    let extraCard = randCard();
                    while(extraCard.type != "Attack") {extraCard = randCard();}
                    hand.push(extraCard);
                    let extraCard2 = randCard();
                    while(extraCard2.type != "Attack") {extraCard2 = randCard();}
                    hand.push(extraCard2);
                }, ["exhausted"]), "Enflame": () => new Card("Enflame+", 1, "Power", "Gain 3 Strength.", function(enemy){
                    gainBuff("Strength", 3);
                }, ["exhausted"]), "Intimidate": () => new Card("Intimidate+", 0, "Skill", "Apply 2 Weak to ALL enemies. Exhaust.", function(enemy){
                    for(let e of enemies) {e.gainBuff("Weak", 2);}
                }, ["exhausted"]), "Metallicize": () => new Card("Metallicize+", 1, "Power", "Start each turn with [BLK4] Block.", function(enemy){
                    gainBuff("Metallicize", 4);
                }, ["exhausted"]), "Power Through": () => new Card("Power Through+", 1, "Skill", "Add 2 Wounds to your hand. Gain [BLK20] Block.", function(enemy){
                    hand.push(statusCards["Wound"]()); hand.push(statusCards["Wound"]()); gainBuff("Block", 20);
                }), "Pummel": () => new Card("Pummel+", 2, "Attack", "Deal [DAM2] damage 8 times.", function(enemy){
                    dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2);
                }), "Rage": () => new Card("Rage+", 0, "Skill", "For each Attack you play this turn, gain [BLK5] Block.", function(enemy){
                    gainBuff("Rage", 5);
                }), "Rampage": () => new Card("Rampage+", 1, "Attack", "Deal [RAMPAGE] damage. This card deals 8 more damage this combat.", function(enemy){
                    dealDamage(enemy, 8 + hasBuff("Rampage")); gainBuff("Rampage", 8);
                }), "Reckless Charge": () => new Card("Reckless Charge+", 0, "Attack","Deal [DAM10] damage. Get a Dazed card.", function(enemy){
                    dealDamage(enemy, 10); discardPile.push(statusCards["Dazed"]());
                }), "Second Wind": () => new Card("Second Wind+", 1, "Skill", "Exhaust all non-Attack cards in your hand. Gain [BLK7] Block for each card Exhausted.", function(enemy){
                    for(let card of hand) {
                        if(card.type != "Attack") {
                            exhaustPile.push(card);
                            hand.splice(hand.indexOf(card), 1);
                            gainBuff("Block", 7);
                        }
                    }
                }), "Seeing Red": () => new Card("Seeing Red+", 0, "Skill", "Gain 2 energy. Exhaust.", function(enemy){
                    energy += 2;
                }, ["exhausted"]), "Sever Soul": () => new Card("Sever Soul+", 2, "Attack", "Exhaust all non-Attack cards in your hand. Deal [DAM22] damage.", function(enemy){
                    for(let card of hand) {
                        if(card.type != "Attack") {
                            exhaustPile.push(card);
                            hand.splice(hand.indexOf(card), 1);
                        }
                    }
                    dealDamage(enemy, 22);
                }), "Spot Weakness": () => new Card("Spot Weakness+", 1, "Skill", "If the enemy intends to attack, gain 4 Strength.", function(enemy){
                    if(enemy.intent.intent.includes("attack")) {
                        gainBuff("Strength", 4);
                    } else {
                        alert("That enemy does not intend to attack.");
                    }
                }), "Uppercut": () => new Card("Uppercut+", 2, "Attack", "Deal [DAM13] damage. Apply 2 Weak and Vulnerable.", function(enemy){
                    dealDamage(enemy, 13); enemy.gainBuff("Weak", 2); enemy.gainBuff("Vulnerable", 2);
                }), "Whirlwind": () => new Card("Whirlwind+", "X", "Attack", "Deal [DAM8] damage to ALL enemies X times.", function(enemy){
                    for(let e of enemies){dealDamage(e, 8);}
                }), "Barricade": () => new Card("Barricade+", 2, "Power", "Block is not removed at the start of your turn.", function(enemy){
                    gainBuff("Barricade", 1);
                }, ["exhausted"]), "Berserk": () => new Card("Berserk+", 0, "Power", "Gain 1 Vulnerable, but gain 1 more energy each turn.", function(enemy){
                    gainBuff("Vulnerable", 1); gainBuff("Berserk", 1);
                }, ["exhausted"]), "Bludgeon": () => new Card("Bludgeon+", 3, "Attack", "Deal [DAM42] damage.", function(enemy){
                    dealDamage(enemy, 42);
                }), "Brutality": new Card("Brutality+", 0, "Power", "Innate. At the start of your turn, lose 1 HP and draw 1 more card.", function(enemy){
                    gainBuff("Brutality", 1);
                }, ["exhausted", "innate"]), "Demon Form": () => new Card("Demon Form+", 3, "Power", "At the end of your turn, gain 3 Strength.", function(enemy){
                    gainBuff("Ritual", 3);
                }, ["exhausted"]), "Double Tap": () => new Card("Double Tap+", 1, "Skill", "Your next 2 Attacks are played twice.", function(enemy){
                    gainBuff("Double Tap", 2);
                }, ["exhausted"]), "Exhume": () => new Card("Exhume+", 0, "Skill", "Put a card from your exhaust pile in your hand. Exhaust.", async function(enemy){
                    let chosen = await choose(exhaustPile, "Choose a card to put into your hand.");
                    if(chosen) {
                        hand.push(chosen);
                        exhaustPile.splice(exhaustPile.indexOf(chosen), 1);
                        updateHtml();
                    } else {
                        alert("Failed to play Exhume: Exhaust pile is empty.");
                    }
                }, ["exhausted"]), "Feed": () => new Card("Feed+", 1, "Attack", "Enemy loses 12 HP. If they die from it, gain 4 Max HP. Exhaust.", function(enemy){
                    if(enemy.hp <= 12) {maxHp += 4; hp += 4;}
                    enemy.hp -= 12;
                }, ["exhausted"]), "Impervious": () => new Card("Impervious+", 2, "Skill", "Gain [BLK40] Block. Exhaust.", function(enemy){
                    gainBuff("Block", 40);
                }, ["exhausted"]), "Juggernaut": () => new Card("Juggernaut+", 2, "Power", "Whenever you gain Block, deal [DAM7] damage to a random enemy.", function(enemy){
                    gainBuff("Juggernaut", 7);
                }, ["exhausted"]), "Limit Break": () => new Card("Limit Break+", 1, "Skill", "Double your Strength.", function(enemy){
                    if(hasBuff("Strength")) {gainBuff("Strength", hasBuff("Strength"));}
                }), "Offering": () => new Card("Offering+", 0, "Skill", "Lose 6 HP. Gain 2 energy. Draw 5 cards. Exhaust.", function(enemy){
                    hp -= 6; energy += 2; drawCard(5);
                }, ["exhausted"]), "Reaper": () => new Card("Reaper+", 2, "Attack", "Deal [DAM10] damage. Heal 10 HP. Exhaust.", function(enemy){
                    dealDamage(enemy, 10); hp = Math.min(maxHp, hp + 10);
                }, ["exhausted"]), "Corruption": () => new Card("Corruption+", 2, "Power", "Skills cost 0. Whenever you play a Skill, exhaust it.", function(enemy) {
                gainBuff("Corruption", 1);
            }, ["exhausted"]), "Acrobatics": () => new Card("Acrobatics+", 1, "Skill", "Draw 4 cards. Discard 1 card.", async function(enemy){
                drawCard(4);
                let chosen = await choose(hand.filter(x=>x.name!="Acrobatics+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            }), "Backflip": () => new Card("Backflip+", 1, "Skill", "Gain [BLK8] Block. Draw 2 cards.", function(enemy){
                drawCard(2); gainBuff("Block", 8);
            }), "Bane": () => new Card("Bane+", 1, "Attack", "Deal [DAM10] damage, twice if enemy has Poison.", function(enemy){
                dealDamage(enemy, 10); if(enemy.hasBuff("Poison")) {dealDamage(enemy, 10);}
            }), "Blade Dance": () => new Card("Blade Dance+", 1, "Skill", "Add 4 Shivs to your hand.", function(enemy){
                addShivs(4);
            }), "Cloak and Dagger": () => new Card("Cloak and Dagger+", 1, "Skill", "Gain [BLK6] Block. Add 2 Shivs to your hand.", function(enemy){
                addShivs(2); gainBuff("Block", 6);
            }), "Dagger Spray": () => new Card("Dagger Spray+", 1, "Attack", "Deal [DAM6] damage to ALL enemies twice.", function(enemy){
                for(let e of enemies){dealDamage(e, 6);dealDamage(e, 6);}
            }), "Dagger Throw": () => new Card("Dagger Throw+", 1, "Attack", "Deal [DAM12] damage. Draw a card. Discard a card.", async function(enemy){
                dealDamage(enemy, 12); drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Dagger Throw+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            }), "Deadly Poison": () => new Card("Deadly Poison+", 1, "Skill", "Apply 7 Poison.", function(enemy){
                enemy.gainBuff("Poison", 7);
            }), "Deflect": () => new Card("Deflect+", 0, "Skill", "Gain [BLK7] Block.", function(enemy){
                gainBuff("Block", 7);
            }), "Dodge and Roll": () => new Card("Dodge and Roll+", 1, "Skill", "Gain [BLK5] Block. Next turn, gain [BLK8] Block.", function(enemy){
                gainBuff("Block", 5); gainBuff("Next Turn Block", 8);
            }), "Flying Knee": () => new Card("Flying Knee+", 1, "Attack", "Deal [DAM11] damage. Gain 1 more energy next turn.", function(enemy){
                dealDamage(enemy, 11); gainBuff("Next Turn Energy", 1);
            }), "Outmaneuver": () => new Card("Outmaneuver+", 1, "Skill", "Gain 3 more energy next turn.", function(enemy){
                gainBuff("Next Turn Energy", 3);
            }), "Poisoned Stab": () => new Card("Poisoned Stab+", 1, "Attack", "Deal [DAM8] damage. Apply 4 Poison.", function(enemy){
                dealDamage(enemy, 8); enemy.gainBuff("Poison", 4);
            }), "Prepared": () => new Card("Prepared+", 0, "Skill", "Draw 2 cards. Discard 2 cards.", async function(enemy){
                drawCard(2);
                let chosen = await choose(hand.filter(x=>x.name!="Prepared+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared+"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
            }), "Quick Slash": () => new Card("Quick Slash+", 1, "Attack", "Deal [DAM12] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 12); drawCard();
            }), "Slice": () => new Card("Slice+", 0, "Attack", "Deal [DAM9] damage.", function(enemy){
                dealDamage(enemy, 9);
            }), "Sucker Punch": () => new Card("Sucker Punch+", 1, "Attack", "Deal [DAM9] damage. Apply 2 Weak.", function(enemy){
                dealDamage(enemy, 9); enemy.gainBuff("Weak", 2);
            }), "Accuracy": () => new Card("Accuracy+", 1, "Power", "Shivs deal 6 more damage.", function(enemy){
                gainBuff("Accuracy", 6);
            }, ["exhausted"]), "All-Out Attack": () => new Card("All-Out Attack+", 1, "Attack", "Deal [DAM14] damage to ALL enemies. Discard a random card.", function(enemy){
                for(let e of enemies) {dealDamage(e, 14);}
                let chosen = choice(hand);
                discardPile.push(chosen);
                hand.splice(hand.indexOf(chosen), 1);
            }), "Backstab": () => new Card("Backstab+", 0, "Attack", "Innate. Deal [DAM15] damage. Exhaust.", function(enemy){
                dealDamage(enemy, 15);
            }, ["exhausted", "innate"]), "Blur": () => new Card("Blur+", 1, "Skill", "Gain [BLK8] Block. Block is not removed next turn.", function(enemy){
                gainBuff("Blur", 1); gainBuff("Block", 8);
            }), "Bouncing Flask": () => new Card("Bouncing Flask+", 2, "Skill", "Apply 12 Poison to a random enemy.", function(enemy){
                choice(enemies).gainBuff("Poison", 12);
            }), "Caltrops": () => new Card("Caltrops+", 1, "Skill", "Gain 5 Thorns. Exhaust.", function(enemy){
                gainBuff("Thorns", 5);
            }, ["exhausted"]), "Catalyst": () => new Card("Catalyst+", 1, "Skill", "Triple the enemy's Poison. Exhaust.", function(enemy){
                enemy.gainBuff("Poison", enemy.hasBuff("Poison") * 2);
            }, ["exhausted"]), "Concentrate": () => new Card("Concentrate+", 0, "Skill", "Discard 2 cards. Gain 2 energy.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
                energy += 2;
                updateHtml();
            }), "Crippling Cloud": () => new Card("Crippling Cloud+", 2, "Skill", "Apply 7 Poison and 2 Weak to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {e.gainBuff("Poison", 7); e.gainBuff("Weak", 2); updateHtml();}
            }, ["exhausted"]), "Dash": () => new Card("Dash+", 2, "Attack", "Deal [DAM13] damage. Gain [BLK13] Block.", function(enemy){
                dealDamage(enemy, 13); gainBuff("Block", 13);
            }), "Distraction": () => new Card("Distraction+", 0, "Skill", "Add 2 random Skills to your hand. Exhaust.", function(enemy){
                let extraCard = randCard();
                while(extraCard.type != "Skill") {extraCard = randCard();}
                hand.push(extraCard);
                extraCard = randCard();
                while(extraCard.type != "Skill") {extraCard = randCard();}
                hand.push(extraCard);
            }, ["exhausted"]), "Escape Plan": () => new Card("Escape Plan+", 0, "Skill", "Draw a card. If it's a Skill, gain [BLK5] Block.", function(enemy){
                drawCard();
                if(hand[hand.length - 1].type == "Skill") {gainBuff("Block", 5);}
            }), "Expertise": () => new Card("Expertise+", 1, "Skill", "Draw cards until you have 7 in hand.", function(enemy){
                if(hand.length < 7) {drawCard(7 - hand.length);}
            }), "Finisher": () => new Card("Finisher+", 1, "Attack", "Deal 8 damage for each Attack played this turn. (Deals [FINISHER+] damage)", function(enemy){
                dealDamage(enemy, stats.attacksThisTurn * 8);
            }), "Footwork": () => new Card("Footwork+", 1, "Power", "Gain 3 Dexterity.", function(enemy){
                gainBuff("Dexterity", 3);
            }, ["exhausted"]), "Heel Hook": () => new Card("Heel Hook+", 1, "Attack", "Deal [DAM8] damage. If the enemy has Weak, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 8);
                if(enemy.hasBuff("Weak")) {energy += 1; drawCard();}
            }), "Infinite Blades": () => new Card("Infinite Blades+", 1, "Power", "Innate. At the start of your turn, add a Shiv into your hand.", function(enemy){
                gainBuff("Infinite Blades", 1);
            }, ["exhausted", "innate"]), "Leg Sweep": () => new Card("Leg Sweep+", 2, "Skill", "Apply 3 Weak. Gain [BLK14] Block.", function(enemy){
                gainBuff("Block", 14); enemy.gainBuff("Weak", 3);
            }), "Noxious Fumes": () => new Card("Noxious Fumes+", 1, "Power", "At the start of your turn, apply 3 Poison to ALL enemies.", function(enemy){
                gainBuff("Noxious Fumes", 3);
            }, ["exhausted"]), "Predator": () => new Card("Predator+", 2, "Attack", "Deal [DAM20] damage. Next turn, draw 2 more cards.", function(enemy){
                dealDamage(enemy, 20); gainBuff("Next Turn Cards", 2);
            }), "Skewer": () => new Card("Skewer+", "X", "Attack", "Deal [DAM10] damage X times.", function(enemy){
                dealDamage(enemy, 10);
            }), "Terror": () => new Card("Terror+", 0, "Skill", "Apply 999 Vulnerable. Exhaust.", function(enemy){
                enemy.gainBuff("Vulnerable", 999);
            }, ["exhausted"]), "A Thousand Cuts": () => new Card("A Thousand Cuts+", 2, "Power", "Whenever you play a card, deal [DAM2] damage to ALL enemies.", function(enemy) {
                gainBuff("Thousand Cuts", 2);
            }, ["exhausted"]), "Adrenaline": () => new Card("Adrenaline+", 0, "Skill", "Gain 2 energy. Draw 2 cards. Exhaust.", function(enemy){
                energy += 2; drawCard(2);
            }, ["exhausted"]), "After Image": () => new Card("After Image+", 1, "Power", "Innate. Whenever you play a card, gain [BLK1] Block.", function(enemy){
                gainBuff("After Image", 1);
            }, ["exhausted", "innate"]), "Burst": () => new Card("Burst+", 1, "Skill", "Your next 2 Skills are played twice.", function(enemy){
                gainBuff("Burst", 2);
            }), "Die Die Die": () => new Card("Die Die Die+", 1, "Attack", "Deal [DAM17] damage to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {dealDamage(e, 17);}
            }, ["exhausted"]), "Doppelganger": () => new Card("Doppelganger+", "X", "Skill", "Next turn, draw 2X more cards and gain X more energy.", function(enemy){
                gainBuff("Next Turn Cards", 2); gainBuff("Next Turn Energy", 1);
            }), "Envenom": () => new Card("Envenom+", 1, "Power", "Whenever you deal unblocked damage, apply 1 Poison.", function(enemy){
                gainBuff("Envenom", 1);
            }, ["exhausted"]), "Grand Finale": () => new Card("Grand Finale+", 0, "Attack", "If there are no cards in your draw pile, deal [DAM60] damage to ALL enemies.", function(enemy) {
                if(drawPile.length == 0) {for(let e of enemies){dealDamage(e, 60);}} else {alert("Failed to play Grand Finale: There are cards in your draw pile.");}
            }), "Storm of Steel": () => new Card("Storm of Steel+", 1, "Skill", "Replace your hand with upgraded Shivs.", function(enemy){
                let handSize = hand.length;
                for(let i of hand) {discardPile.push(i);}
                hand = [];
                addShivPluses(handSize);
            }), "Tools of the Trade": () => new Card("Tools of the Trade+", 0, "Power", "At the start of your turn, draw a card and discard a card.", function(enemy){
                gainBuff("Tools of the Trade", 1);
            }, ["exhausted"]), "Ascenders’ Bane": () => new Card("Ascenders’ Bane+", 0, "Curse", "Ethereal.", function(enemy){}, ["ethereal"]), "Bowling Bash": () => new Card("Bowling Bash+", 1, "Attack", "Deal [DAM10] damage for each enemy in combat.", function(enemy){
                dealDamage(enemy, 10 * enemies.length);
            }), "Consecrate": () => new Card("Consecrate+", 0, "Attack", "Deal [DAM8] damage to ALL enemies.", function(enemy){
                for(let i of enemies){dealDamage(i, 8);}
            }), "Crescendo": () => new Card("Crescendo+", 0, "Skill", "Retain. Enter Wrath. Exhaust.", function(enemy){
                gainBuff("Wrath", 1);
            }, ["retain", "exhausted"]), "Crush Joints": () => new Card("Crush Joints+", 1, "Attack", "Deal [DAM10] damage. If the last card played this combat was a Skill, apply 2 Vulnerable.", function(enemy){
                dealDamage(enemy, 10); if(stats.lastType == "Skill") {enemy.gainBuff("Vulnerable", 2);}
            }), "Cut Through Fate": () => new Card("Cut Through Fate+", 1, "Attack", "Deal [DAM9] damage. Scry 3. Draw a card.", function(enemy){
                dealDamage(enemy, 9); scry(3); drawCard(1);
            }), "Empty Body": () => new Card("Empty Body+", 1, "Skill", "Gain [BLK10] Block. Exit your stance.", function(enemy){
                gainBuff("Block", 10); loseBuff("Wrath"); loseBuff("Calm"); loseBuff("Divinity");
            }), "Empty Fist": () => new Card("Empty Fist+", 1, "Attack", "Deal [DAM14] damage. Exit your stance.", function(enemy){
                dealDamage(enemy, 14); loseBuff("Wrath"); loseBuff("Calm"); loseBuff("Divinity");
            }), "Evaluate": () => new Card("Evaluate+", 1, "Skill", "Gain [BLK10] Block. Shuffle an Insight into your draw pile.", function(enemy){
                gainBuff("Block", 10); addInsights(1);
                drawPile = shuffle(drawPile);
            }), "Flurry of Blows": () => new Card("Flurry of Blows+", 0, "Attack", "Deal [DAM6] damage. When you change stances, return this from discard to hand.", function(enemy){
                dealDamage(enemy, 6);
            }), "Flying Sleeves": () => new Card("Flying Sleeves+", 1, "Attack", "Retain. Deal [DAM6] damage twice.", function(enemy){
                dealDamage(enemy, 6); dealDamage(enemy, 6);
            }, ["retain"]), "Follow Up": () => new Card("Follow Up+", 1, "Attack", "Deal [DAM11] damage. If the last card played this combat was an Attack, gain 1 energy.", function(enemy){
                dealDamage(enemy, 11); if(stats.lastType == "Attack") {energy += 1;}
            }), "Halt": () => new Card("Halt+", 0, "Skill", "Gain [BLK4] Block. If you're in Wrath, gain [BLK14] more Block.", function(enemy){
                gainBuff("Block", 4); if(hasBuff("Wrath")) {gainBuff("Block", 14);}
            }), "Just Lucky": () => new Card("Just Lucky+", 0, "Attack", "Scry 2, gain [BLK3] Block, deal [DAM4] damage.", function(enemy){
                scry(2); gainBuff("Block", 3); dealDamage(enemy, 4);
            }), "Pressure Points": () => new Card("Pressure Points+", 1, "Skill", "Apply 11 Mark. ALL enemies lose HP equal to their Mark.", function(enemy){
                enemy.gainBuff("Mark", 11); for(let e of enemies) {e.hp -= e.hasBuff("Mark");}
            }), "Precision": () => new Card("Precision+", 0, "Power", "Deal 1 more damage for every 5 Mark on target.", function(enemy){
                gainBuff("Precision", 1);
            }, ["exhausted"]), "Predict": () => new Card("Predict+", 1, "Skill", "Apply 10 Mark. Gain Block equal to Mark on ALL enemies. (Gains [PREDICT] Block)", function(enemy){
                enemy.gainBuff("Mark", 10); let b=0; for(let i of enemies) {b += i.hasBuff("Mark");} gainBuff("Block", b);
            }, ["exhausted"]), "Prostrate": () => new Card("Prostrate+", 0, "Skill", "Gain 3 Mantra. Gain [BLK4] Block.", function(enemy){
                gainBuff("Mantra", 3); gainBuff("Block", 4);
            }), "Protect": () => new Card("Protect+", 2, "Skill", "Retain. Gain [BLK16] Block.", function(enemy){
                gainBuff("Block", 16);
            }, ["retain"]), "Sash Whip": () => new Card("Sash Whip+", 1, "Attack", "Deal [DAM10] damage. If the last card played this combat was an Attack, apply 2 Weak.", function(enemy){
                dealDamage(enemy, 10); if(stats.lastType == "Attack") {enemy.gainBuff("Weak", 2);}
            }), "Third Eye": () => new Card("Third Eye+", 1, "Skill", "Gain [BLK9] Block. Scry 5.", function(enemy){
                gainBuff("Block", 9); scry(5);
            }), "Tranquility": () => new Card("Tranquility+", 0, "Skill", "Enter Calm. Retain. Exhaust.", function(enemy){
                gainBuff("Calm", 1);
            }, ["exhausted", "retain"]), "Battle Hymn": () => new Card("Battle Hymn+", 1, "Power", "Innate. At the start of your turn, add a Smite to your hand.", function(enemy){
                gainBuff("Battle Hymn", 1);
            }, ["exhausted", "innate"]), "Carve Reality": () => new Card("Carve Reality+", 1, "Attack", "Deal [DAM10] damage. Add a Smite to your hand.", function(enemy){
                dealDamage(enemy, 10); addSmites(1);
            }), "Collect": () => new Card("Collect+", "X", "Skill", "Put a Miracle+ into your hand each turn for X turns.", function(enemy){
                gainBuff("Collect", 1);
            }), "Conclude": () => new Card("Conclude+", 1, "Attack", "Deal [DAM15] damage to ALL enemies. Discard your hand.", function(enemy){
                for(let e of enemies){dealDamage(e, 15);} discardPile = [...discardPile, ...hand]; hand = [];
            }), "Deceive Reality": () => new Card("Deceive Reality+", 1, "Skill", "Gain [BLK7] Block. Add a Safety to your hand.", function(enemy){
                gainBuff("Block", 7); hand.push(new Card("Safety", 1, "Skill", "Gain [BLK12] Block. Retain. Exhaust.", function(enemy){gainBuff("Block", 12);}, ["retain", "exhaust"]));
            }), "Empty Mind": () => new Card("Empty Mind+", 1, "Skill", "Draw 3 cards. Exit your stance.", function(enemy){
                drawCard(3); loseBuff("Wrath"); loseBuff("Calm"); loseBuff("Divinity");
            }), "Fasting": () => new Card("Fasting+", 2, "Power", "Gain 5 Strength and 5 Dexterity, but gain 1 less energy each turn.", function(enemy){
                gainBuff("Strength", 5); gainBuff("Dexterity", 5); gainBuff("Fasting", 1);
            }, ["exhausted"]), "Fear No Evil": () => new Card("Fear No Evil+", 1, "Attack", "Deal [DAM11] damage. If the enemy intends to attack, enter Calm.", function(enemy){
                dealDamage(enemy, 11); if(enemy.intent.intent.includes("attack")) {gainBuff("Calm", 1);}
            }), "Foresight": () => new Card("Foresight+", 1, "Power", "At the start of your turn, scry 4.", function(enemy){
                gainBuff("Foresight", 4);
            }, ["exhausted"]), "Indignation": () => new Card("Indignation+", 1, "Skill", "If you are in Wrath, apply 5 Vulnerable to ALL enemies, otherwise enter Wrath.", function(enemy){
                if(hasBuff("Wrath")) {for(let e of enemies){e.gainBuff("Vulnerable", 5);}} else {gainBuff("Wrath", 1);}
            }), "Inner Peace": () => new Card("Inner Peace+", 1, "Skill", "If you are in Calm, draw 4 cards, otherwise enter Calm.", function(enemy){
                if(hasBuff("Calm")) {drawCard(4);} else {gainBuff("Calm", 1);}
            }), "Like Water": () => new Card("Like Water+", 1, "Power", "If you end your turn in Calm, gain [BLK7] Block.", function(enemy){
                gainBuff("Like Water", 7);
            }, ["exhausted"]), "Mental Fortress": () => new Card("Mental Fortress+", 1, "Power", "Whenever you switch stances, gain [BLK4] Block.", function(enemy){
                gainBuff("Mental Fortress", 4);
            }, ["exhausted"]), "Nirvana": () => new Card("Nirvana+", 1, "Power", "Whenever you scry, gain [BLK6] Block.", function(enemy){
                gainBuff("Nirvana", 6);
            }, ["exhausted"]), "Perseverance": () => new Card("Perseverance+", 1, "Skill", "Gain [PERS] Block. Retain. When this is Retained, it gets +4 Block this combat.", function(enemy){
                gainBuff("Block", 5 + stats.pers); stats.pers += 4;
            }, ["retain"]), "Pray": () => new Card("Pray+", 1, "Skill", "Gain 4 Mantra. Shuffle an Insight into your draw pile.", function(enemy){
                gainBuff("Mantra", 4); addInsights(1);
            }), "Reach Heaven": () => new Card("Reach Heaven+", 2, "Attack", "Deal [DAM15] damage. Shuffle a Through Violence into your draw pile.", function(enemy){
                dealDamage(enemy, 15); drawPile.push(new Card("Through Violence", 0, "Attack", "Retain. Deal [DAM20] damage. Exhaust.", function(enemy){dealDamage(enemy,20);}, ["retain", "exhausted"])); drawPile = shuffle(drawPile);
            }), "Rushdown": () => new Card("Rushdown+", 0, "Power", "Whenever you enter Wrath, draw 2 cards.", function(enemy){
                gainBuff("Rushdown", 2);
            }, ["exhausted"]), "Sanctity": () => new Card("Sanctity+", 1, "Skill", "Gain [BLK9] Block. If the last card played this combat was a Skill, draw 2 cards.", function(enemy) {
                gainBuff("Block", 9); if(stats.lastType = "Skill") {drawCard(2);}
            }), "Sands of Time": () => new Card("Sands of Time+", 4, "Attack", "Deal [DAM25] damage. Retain. When this is Retained, it gets -1 cost this combat.", function(enemy){
                dealDamage(enemy, 25);
            }, ["retain"]), "Signature Move": () => new Card("Signature Move+", 2, "Attack", "Can only be played if this is the only Attack in your hand. Deal [DAM40] damage.", function(enemy){
                if(!hand.filter(x=>x.type=="Attack"&&!x.name.includes("Signature Move")).length) {dealDamage(enemy, 40);}
            }), "Simmering Fury": () => new Card("Simmering Fury+", 1, "Skill", "At the start of your next turn, enter Wrath and draw 3 cards.", function(enemy){
                gainBuff("Simmering Fury", 1); gainBuff("Next Turn Cards", 3);
            }), "Study": () => new Card("Study+", 1, "Power", "At end of turn, shuffle an Insight into your draw pile", function(enemy){
                gainBuff("Study", 1);
            }, ["exhausted"]), "Swivel": () => new Card("Swivel+", 2, "Skill", "Gain [BLK11] Block. The next Attack you play costs 0.", function(enemy){
                gainBuff("Block", 11), gainBuff("Swivel", 1);
            }), "Talk to the Hand": () => new Card("Talk to the Hand+", 1, "Attack", "Deal [DAM7] damage. Whenever you attack this enemy, gain [BLK3] Block. Exhaust.", function(enemy){
                dealDamage(enemy, 7); enemy.gainBuff("Talk to the Hand", 3);
            }, ["exhausted"]), "Tantrum": () => new Card("Tantrum+", 1, "Attack", "Deal [DAM3] damage 4 times. Enter Wrath. Shuffle this into your draw pile.", function(enemy){
                dealDamage(enemy,3);dealDamage(enemy,3);dealDamage(enemy,3);dealDamage(enemy,3); gainBuff("Wrath", 1);
            }), "Wallop": () => new Card("Wallop+", 2, "Attack", "Deal [DAM12] damage. Gain Block equal to unblocked damage dealt.", function(enemy){
                gainBuff("Block", calcYourDamage(enemy, 12)); dealDamage(enemy, 12);
            }), "Wave of the Hand": () => new Card("Wave of the Hand+", 1, "Skill", "Whenever you gain Block this turn, apply 2 Weak to ALL enemies.", function(enemy){
                gainBuff("Wave of the Hand", 2);
            }), "Weave": () => new Card("Weave+", 0, "Attack", "Deal [DAM7] damage. Whenever you scry, return this from discard to hand.", function(enemy){
                dealDamage(enemy, 7);
            }), "Wheel Kick": () => new Card("Wheel Kick+", 2, "Attack", "Deal [DAM20] damage. Draw 2 cards.", function(enemy){
                dealDamage(enemy, 20); drawCard(2);
            }), "Windmill Strike": () => new Card("Windmill Strike+", 2, "Attack", "Retain. Deal [WINDMILL] damage. When Retained, it gets +7 damage this combat.", function(enemy){
                dealDamage(enemy, 7 + stats.windmill);
            }, ["retain"]), "Worship": () => new Card("Worship+", 2, "Skill", "Retain. Gain 5 Mantra.", function(enemy){
                gainBuff("Mantra", 5);
            }, ["retain"]), "Wreath of Flame": () => new Card("Wreath of Flame+", 1, "Skill", "Your next attack deals 8 more damage.", function(enemy){
                gainBuff("Vigor", 8);
            }), "Alpha": () => new Card("Alpha+", 1, "Skill", "Innate. Shuffle a Beta into your draw pile. Exhaust.", function(enemy){
                drawPile.push(
                    new Card("Beta", 1, "Skill", "Shuffle an Omega into your draw pile. Exhaust.", function(enemy){
                        drawPile.push(
                            new Card("Omega", 0, "Power", "At the end of your turn, deal [DAM50] damage to ALL enemies.", function(enemy){gainBuff("Omega", 50);}, ["exhausted"])
                        );
                    }, ["exhausted"])
                );
            }, ["exhausted", "innate"]), "Blasphemy": () => new Card("Blasphemy+", 1, "Skill", "Retain. Enter Divinity. Die next turn. Exhaust.", function(enemy){
                    gainBuff("Divinity", 1); gainBuff("Blasphemy", 1);
            }, ["exhausted", "retain"]), "Brilliance": () => new Card("Brilliance+", 1, "Attack", "Deal [BRILLIANCE+] damage. More effective based on Mantra gained this combat.", function(enemy){
                    dealDamage(enemy, 16 + stats.mantraGain);
            }), "Conjure Blade": () => new Card("Conjure Blade+", "X", "Skill", "Shuffle X upgraded Expungers into your draw pile. Exhaust.", function(enemy){
                drawPile.push(new Card("Expunger+", 0, "Attack", "Deal [DAM6] damage. Draw a card.", function(enemy){dealDamage(enemy,6);drawCard();}));
            }, ["exhausted"]), "Deus Ex Machina": () => new Card("Deus Ex Machina+", 0, "Skill", "Add 3 Miracles to your hand. Exhaust.", function(enemy){
                hand.push(new Card("Miracle", 0, "Skill", "Retain. Gain 1 energy. Exhaust.", function(enemy){energy += 1;}, ["exhausted", "retain"]));
                hand.push(new Card("Miracle", 0, "Skill", "Retain. Gain 1 energy. Exhaust.", function(enemy){energy += 1;}, ["exhausted", "retain"]));
                hand.push(new Card("Miracle", 0, "Skill", "Retain. Gain 1 energy. Exhaust.", function(enemy){energy += 1;}, ["exhausted", "retain"]));
            }, ["exhausted"]), "Deva Form": () => new Card("Deva Form", 3, "Power", "At the start of your turn, gain 1 energy and increase the gain by 1.", function(enemy){
                gainBuff("Deva Form", 1);
            }, ["exhausted"]), "Devotion": () => new Card("Devotion", 1, "Power", "At the start of your turn, gain 3 Mantra.", function(enemy){
                gainBuff("Devotion", 3);
            }, ["exhausted"]), "Establishment": () => new Card("Establishment+", 1, "Power", "Innate. When a card is Retained, it gets -1 cost this combat.", function(enemy){
                gainBuff("Establishment", 1);
            }, ["exhausted", "innate"]), "Judgment": () => new Card("Judgment+", 1, "Skill", "If the enemy has 40 or less HP, set their HP to 0.", function(enemy){
                if(enemy.hp <= 40) dealDamage(enemy, 9999);
            }), "Lesson Learned": () => new Card("Lesson Learned+", 2, "Attack", "Deal [DAM13] damage. If fatal, upgrade a random card in your deck. Exhaust.", function(enemy){
                if(calcYourDamage(enemy, 13) >= (enemy.hp + enemy.hasBuff("Block"))) {
                    let eligible = deck.filter(x=>!x.name.includes("+"));
                    if(eligible.length) {
                        let card = choice(eligible);
                        upgradeCard(card);
                    }
                }
                dealDamage(enemy, 13);
            }, ["exhausted"]), "Ragnarok": () => new Card("Ragnarok+", 3, "Attack", "Deal [DAM6] damage to a random enemy 6 times.", function(enemy){
                for(let i=0; i<6; i++) {
                    dealDamage(choice(enemies), 6);
                }
            }), "Scrawl": () => new Card("Scrawl+", 0, "Skill", "Draw cards until your hand is full. Exhaust.", function(enemy){
                drawCard(10);
            }, ["exhausted"]), "Spirit Shield": () => new Card("Spirit Shield+", 2, "Skill", "Gain [BLK4] Block for each card in your hand.", function(enemy){
                for(let i=0; i<hand.length; i++) {
                    gainBuff("Block", 4);
                }
            }), "Vault": () => new Card("Vault+", 2, "Skill", "Take another turn after this one. Exhaust.", function(enemy){
                gainBuff("Vault", 1);
            }, ["exhausted"]), "Wish": () => new Card("Wish+", 3, "Skill", "Gain 1 Metallicize, 1 Strength, and 16 Gold. Exhaust.", function(enemy){
                gainBuff("Strength", 1);
                gainBuff("Metallicize", 1);
                gold += 16;
            }, ["exhausted"]), "Apparition": () => new Card("Apparition+", 1, "Skill", "Gain 1 Intangible. Exhaust.", function(enemy){
                    gainBuff("Intangible", 1);
            }, ["exhausted"])
            };
            
            function upgradeCard(c) {
                let newCard = upgradedCards[c.name];
                if(!newCard) return;
                let deckNames = deck.map(x=>x.name);
                deck.splice(deckNames.indexOf(c.name), 1);
                deck.push(newCard());
            }
            let cardToUpgrade;
            async function upgradeDialog() {
                let chosen = await choose(deck.filter(x=>(!x.name.includes("+"))), "Choose a card to upgrade.");
                cardToUpgrade = chosen;
                let upg = upgradedCards[cardToUpgrade.name]();
                getId("upgradeDialog").style.display = "block";
                if(upg) {
                    getId("cardDesc").innerHTML = `
<div id='upgradePart1'>${makeTooltip(cardToUpgrade).split("<span class='txt'>")[1].replace("</span>", "")}</div>
<div id='middleArrow'>→</div>
<div id='upgradePart2'>${makeTooltip(upg).split("<span class='txt'>")[1].replace("</span>", "")}</div>`;
                } else {
                    getId("cardDesc").innerHTML = "That card is not upgradable.";
                }
            }
            
            let randCard = function(upg=true) {
                let card = choice([bodySlam, clash, cleave, clothesline, flex, headbutt, heavyBlade, ironWave, pommelStrike, shrugItOff, swordBoomerang, thunderclap, trueGrit, twinStrike, wildStrike, battleTrance, bloodForBlood, bloodletting, burningPact, carnage, combust, darkEmbrace, disarm, dropkick, dualWield, entrench, evolve, feelNoPain, fireBreathing, flameBarrier, ghostlyArmor, hemokinesis, infernalBlade, inflame, intimidate, metallicize, powerThrough, pummel, rage, rampage, secondWind, seeingRed, severSoul, spotWeakness, uppercut, whirlwind, acrobatics, backflip, bane, bladeDance, cloakAndDagger, daggerSpray, daggerThrow, deadlyPoison, deflect, dodgeAndRoll, flyingKnee, outmaneuver, poisonedStab, prepared, quickSlash, slice, suckerPunch, accuracy, allOutAttack, backstab, blur, bouncingFlask, caltrops, catalyst, concentrate, cripplingCloud, dash, distraction, expertise, finisher, footwork, heelHook, infiniteBlades, legSweep, noxiousFumes, predator, skewer, terror, bowlingBash, consecrate, crescendo, crushJoints, cutThroughFate, emptyBody, emptyFist, evaluate, flurryOfBlows, flyingSleeves, followUp, halt, justLucky, pressurePoints, predict, precision, prostrate, protect, sashWhip, thirdEye, tranquility, battleHymn, collect, conclude, deceiveReality, emptyMind, fasting, fearNoEvil, foresight, indignation, innerPeace, likeWater, mentalFortress, nirvana, perseverance, pray, reachHeaven, rushdown, sanctity, sandsOfTime, signatureMove, simmeringFury, study, swivel, talkToTheHand, tantrum, wallop, waveOfTheHand, weave, wheelKick, windmillStrike, worship, wreathOfFlame]);
                if(Math.random() < 0.3 * (actNum - 1) && upg) {
                    return upgradedCards[card().name]();
                } else {
                    return card();
                }
            };
            let randRareCard = function(upg=true) {
                let card = choice([barricade, berserk, bludgeon, brutality, demonForm, doubleTap, corruption, exhume, feed, impervious, juggernaut, limitBreak, offering, reaper, thousandCuts, adrenaline, afterImage, burst, dieDieDie, doppelganger, envenom, grandFinale, stormOfSteel, toolsOfTheTrade, alpha, blasphemy, brilliance, conjureBlade, deusExMachina, devaForm, devotion, establishment, judgment, lessonLearned, ragnarok, scrawl, spiritShield, vault, wish]);
                if(Math.random() < 0.3 * (actNum - 1) && upg) {
                    return upgradedCards[card().name]();
                } else {
                    return card();
                }
            };
            
            function updateCardList() {
                let normals = [];
                let rares = [];
                deck = [];
                if(getId("useIronclad").checked) {
                    normals = [...normals, bodySlam, clash, cleave, clothesline, flex, headbutt, heavyBlade, ironWave, pommelStrike, shrugItOff, swordBoomerang, thunderclap, trueGrit, twinStrike, wildStrike, battleTrance, bloodForBlood, bloodletting, burningPact, carnage, combust, darkEmbrace, disarm, dropkick, dualWield, entrench, evolve, feelNoPain, fireBreathing, flameBarrier, ghostlyArmor, hemokinesis, infernalBlade, inflame, intimidate, metallicize, powerThrough, pummel, rage, rampage, secondWind, seeingRed, severSoul, spotWeakness, uppercut, whirlwind];
                    rares = [...rares, barricade, berserk, bludgeon, brutality, demonForm, doubleTap, corruption, exhume, feed, impervious, juggernaut, limitBreak, offering, reaper];
                    deck.push(bash());
                }
                if(getId("useSilent").checked) {
                    normals = [...normals, acrobatics, backflip, bane, bladeDance, cloakAndDagger, daggerSpray, daggerThrow, deadlyPoison, deflect, dodgeAndRoll, flyingKnee, outmaneuver, poisonedStab, prepared, quickSlash, slice, suckerPunch, accuracy, allOutAttack, backstab, blur, bouncingFlask, caltrops, catalyst, concentrate, cripplingCloud, dash, distraction, expertise, finisher, footwork, heelHook, infiniteBlades, legSweep, noxiousFumes, predator, skewer, terror];
                    rares = [...rares, thousandCuts, adrenaline, afterImage, burst, dieDieDie, doppelganger, envenom, grandFinale, stormOfSteel, toolsOfTheTrade];
                    deck.push(neutralize());
                }
                if(getId("useWatcher").checked) {
                    normals = [...normals, bowlingBash, consecrate, crescendo, crushJoints, cutThroughFate, emptyBody, emptyFist, evaluate, flurryOfBlows, flyingSleeves, followUp, halt, justLucky, pressurePoints, predict, precision, prostrate, protect, sashWhip, thirdEye, tranquility, battleHymn, collect, conclude, deceiveReality, emptyMind, fasting, fearNoEvil, foresight, indignation, innerPeace, likeWater, mentalFortress, nirvana, perseverance, pray, reachHeaven, rushdown, sanctity, sandsOfTime, signatureMove, simmeringFury, study, swivel, talkToTheHand, tantrum, wallop, waveOfTheHand, weave, wheelKick, windmillStrike, worship, wreathOfFlame];
                    rares = [...rares, alpha, blasphemy, brilliance, conjureBlade, deusExMachina, devaForm, devotion, establishment, judgment, lessonLearned, ragnarok, scrawl, spiritShield, vault, wish];
                    deck.push(eruption()); deck.push(vigilance());
                }
                while(deck.length < 10) {
                    deck.push(strike());
                    deck.push(defend());
                }
                if(getId("ascensionLevel").value >= 10) {deck.push(new Card("Ascenders’ Bane", 0, "Curse", "Unplayable. Ethereal.", function(enemy){}, ["unplayable", "ethereal"]))}
                randCard = function(upg) {
                    let card = choice(normals);
                    if(Math.random() < 0.3 * (actNum - 1) && upg) {
                        return upgradedCards[card().name]();
                    } else {
                        return card();
                    }
                };
                randRareCard = function(upg) {
                    let card = choice(rares);
                    if(Math.random() < 0.3 * (actNum - 1) && upg) {
                        return upgradedCards[card().name]();
                    } else {
                        return card();
                    }
                };
            }
            
            function addCard() {
                let newCards;
                if((eliteBattle && getId("ascensionLevel").value < 12) || bossBattle) {
                    newCards = shuffle([randRareCard(), randRareCard(), randRareCard()]);
                } else {
                    newCards = [randCard(), randCard(), randCard()];
                }
                while(newCards.filter((v, i, a) => a.map(x=>x.name).indexOf(v.name) == i).length < newCards.length) {
                    if((eliteBattle && getId("ascensionLevel").value < 12) || bossBattle) {
                        newCards = shuffle([randCard(), randRareCard(), randRareCard()]);
                    } else {
                        newCards = [randCard(), randCard(), randCard()];
                    }
                }
                if(relics.map(x=>x.name).includes("Busted Crown")) newCards = [newCards[0]];
                possibleCards = newCards;
                getId("cardModal").style.display = "block";
                for(let x=0; x<newCards.length; x++) {
                    let cardTooltip = document.createElement("span");
                    let modalCard = getId("modalCard"+(x+1));
                    modalCard.innerHTML = makeTooltip(newCards[x]);
                }
            };
            async function scry(amount) {
                if(amount <= 0) return;
                let amt = (relics.map(x=>x.name).includes("Golden Eye") ? amount+2 : amount);
                let chosen = await choose(drawPile.filter(x=>drawPile.indexOf(x) < amt), "Choose cards to discard.", true);
                drawPile = drawPile.filter(x=>!(chosen.includes(x)));
                discardPile = [...discardPile, ...chosen];
                gainBuff("Block", hasBuff("Nirvana"));
                let weaves = discardPile.filter(x=>x.name == "Weave");
                hand = [...hand, ...weaves];
                discardPile = discardPile.filter(x=>x.name != "Weave");
            }
            function finishAddCard(cardNumber) {
                if(cardNumber >= 0 && cardNumber < possibleCards.length) {
                    let c = possibleCards[cardNumber];
                    deck.push(c);
                    ifRelic("Ceramic Fish", function(){gold += 9});
                    if(c.type == "Power") {
                        ifRelic("Frozen Egg", function(){upgradeCard(deck.filter(e => e.number == c.number)[0])});
                    }
                    if(c.type == "Attack") {
                        ifRelic("Molten Egg", function(){upgradeCard(deck.filter(e => e.number == c.number)[0])});
                    }
                    if(c.type == "Skill") {
                        ifRelic("Toxic Egg", function(){upgradeCard(deck.filter(e => e.number == c.number)[0])});
                    }
                    updateStatLine();
                } else if(cardNumber == -1) {
                    updateStatLine();
                }
            }
            
            function addBossRelic() {
                let newCards = [choice(bossRelicPool), choice(bossRelicPool), choice(bossRelicPool)];
                while(newCards.filter((v, i, a) => a.map(x=>x.name).indexOf(v.name) == i).length < newCards.length) {
                    newCards = [choice(bossRelicPool), choice(bossRelicPool), choice(bossRelicPool)];
                }
                possibleCards = newCards;
                getId("bossModal").style.display = "block";
                for(let x=0; x<3; x++) {
                    let cardTooltip = document.createElement("span");
                    let modalCard = getId("modalRelic"+(x+1));
                    modalCard.innerHTML = newCards[x].name;
                    cardTooltip.innerHTML = newCards[x].desc;
                    cardTooltip.setAttribute("class", "txt");
                    modalCard.appendChild(cardTooltip);
                }
            };
            function finishAddRelic(cardNumber) {
                if(cardNumber >= 0 && cardNumber < possibleCards.length) {
                    let r = possibleCards[cardNumber];
                    relics.push(r);
                    if(["Busted Crown", "Coffee Dripper", "Cursed Key", "Ectoplasm", "Fusion Hammer", "Philosopher’s Stone", "Runic Dome", "Velvet Choker", "Sozu"].includes(r.name)) maxEnergy += 1;
                    if(r.name == "Empty Cage") {
                        let fun = async function() {
                            let c1 = await choose(deck, "Choose a card to remove.");
                            deck.splice(deck.indexOf(c1), 1);
                            let c2 = await choose(deck, "Choose another card to remove.");
                            deck.splice(deck.indexOf(c2), 1);
                        }; fun();
                    }
                    if(r.name == "Pandora’s Box") {
                        let toAdd = 0;
                        for(let i of deck) {if(["Strike", "Strike+", "Defend", "Defend+"].includes(i.name)) {toAdd += 1;}}
                        deck = deck.filter(x=>!["Strike", "Strike+", "Defend", "Defend+"].includes(x.name));
                        for(let j=0; j<toAdd; j++) {
                            if(j % 3 == 0) deck.push(randRareCard());
                            else deck.push(randCard());
                        }
                    }
                    if(r.name == "Mark of Pain") {
                        deck.push(new Card("Injury", 0, "Curse", "Unplayable.", function(){}, ["unplayable"]));
                        deck.push(new Card("Injury", 0, "Curse", "Unplayable.", function(){}, ["unplayable"]));
                    }
                    if(r.name == "Serpent Ring") {
                        relics = relics.filter(x=>x.name!="Snake Ring");
                    }
                    if(r.name == "Coffee Dripper") {
                        getId("rester").style.display = "none";
                    }
                    if(r.name == "Fusion Hammer") {
                        getId("smither").style.display = "none";
                    }
                    updateStatLine();
                } else if(cardNumber == -1) {
                    updateStatLine();
                }
            }
            let possibleCards = [];
            
            let ifRelic = function(rel, func, args=[]) {
                for(let r of relics) {
                    if(r.name == rel) {func(...args);}
                }
            }
            let relicPool = [
                {name: "Akabeko", desc: "Your first attack each combat deals 8 more damage."},
                {name: "Anchor", desc: "Start each combat with 10 Block."},
                {name: "Ancient Tea Set", desc: "When you leave a Rest Site, start the next combat with 2 more energy."},
                {name: "Art of War", desc: "If you play no Attacks in a turn, gain 1 more Energy next turn."},
                {name: "Bag of Marbles", desc: "ALL enemies start combat with 1 Vulnerable."},
                {name: "Ball Bearing", desc: "When you shuffle your deck, add a Flash of Steel into it."},
                {name: "Blood Vial", desc: "At the start of each combat, heal 2 HP."},
                {name: "Bronze Scales", desc: "When you take damage, deal 3 back."},
                {name: "Centennial Puzzle", desc: "The first time you lose HP each combat, draw 3 cards."},
                {name: "Ceramic Fish", desc: "When you add a card to your deck, gain 9 gold."},
                {name: "Damaru", desc: "At the start of your turn, gain 1 Mantra"},
                {name: "Dream Catcher", desc: "When you Rest, you may add a card to your deck."},
                {name: "Happy Flower", desc: "Gain 1 energy every 3rd turn."},
                {name: "Lantern", desc: "Start each combat with 1 more energy."},
                {name: "Maw Bank", desc: "When you climb a floor, gain 12 gold. Lose this when you spend gold at a shop."},
                {name: "Meal Ticket", desc: "When you enter a shop, heal 15 HP."},
                {name: "Oddly Smooth Stone", desc: "Start each combat with 1 Dexterity."},
                {name: "Orichalcum", desc: "When you end your turn without Block, gain 6 Block."},
                {name: "Pen Nib", desc: "Every 10th Attack you play deals double damage."},
                {name: "Preserved Insect", desc: "Elites have 25% less HP."},
                {name: "Red Skull", desc: "Deal 3 more damage when your HP is half or less."},
                {name: "Regal Pillow", desc: "Heal 15 more HP when you rest."},
                {name: "Smiling Mask", desc: "The merchant’s card removal service always costs 50 gold."},
                {name: "Strawberry", desc: "On pickup, gain 7 max HP."},
                {name: "The Boot", desc: "When you would deal 4 or less damage, deal 5 instead."},
                {name: "Toy Ornithopter", desc: "When you use a Potion, heal 5 HP."},
                {name: "Vajra", desc: "Start each combat with 1 Strength."},
                {name: "Snecko Skull", desc: "When you apply Poison, apply 1 more."},
                {name: "Eternal Feather", desc: "Heal 3 HP for each 5 cards in your deck when you rest."},
                {name: "Frozen Egg", desc: "When you add a Power to your deck, upgrade it."},
                {name: "Gremlin Horn", desc: "When an enemy dies, gain 1 energy and draw 1 card."},
                {name: "Horn Cleat", desc: "Start turn 2 with 14 Block."},
                {name: "Kunai", desc: "When you play 3 Attacks in a turn, gain 1 Dexterity."},
                {name: "Letter Opener", desc: "When you play 3 Skills in a turn, deal 5 damage to ALL enemies."},
                {name: "Meat on the Bone", desc: "At end of combat, heal 12 HP, up to 50% of max HP."},
                {name: "Mercury Hourglass", desc: "At the start of your turn, deal 3 damage to ALL enemies."},
                {name: "Molten Egg", desc: "When you add an Attack to your deck, upgrade it."},
                {name: "Mummified Hand", desc: "When you play a Power, a random card in your hand costs 0 that turn."},
                {name: "Ornamental Fan", desc: "When you play 3 Attacks in a turn, gain 4 Block."},
                {name: "Pantograph", desc: "Heal 25 HP at the start of Boss combats."},
                {name: "Pear", desc: "On pickup, gain 10 max HP."},
                {name: "Shuriken", desc: "When you play 3 Attacks in a turn, gain 1 Strength."},
                {name: "Singing Bowl", desc: "When you view and skip the card reward, gain 2 max HP."},
                {name: "Strike Dummy", desc: "Strikes deal 3 more damage."},
                {name: "Sundial", desc: "When you shuffle your deck, gain 1 energy."},
                {name: "Teardrop Locket", desc: "Start each combat in Calm."},
                {name: "Toxic Egg", desc: "When you add a Skill to your deck, upgrade it."},
                {name: "White Beast Statue", desc: "Potions always drop after combat."},
                {name: "Self-Forming Clay", desc: "When you lose HP in combat, gain 3 Block next turn."},
                {name: "Ninja Scroll", desc: "Start each combat with 3 Shivs in hand."},
                {name: "Chemical X", desc: "Cards that cost X repeat their effect 2 more times."}
            ];
            let rareRelicPool = [
                {name: "Bird-Faced Urn", desc: "When you play a Power, heal 2 HP."},
                {name: "Calipers", desc: "At the start of your turn, lose 15 Block rather than all your Block."},
                {name: "Captain’s Wheel", desc: "Start turn 3 with 18 Block."},
                {name: "Charon’s Ashes", desc: "When you Exhaust a card, deal 3 damage to ALL enemies."},
                {name: "Cloak Clasp", desc: "At end of turn, gain 1 Block per card in your hand."},
                {name: "Dead Branch", desc: "When you Exhaust a card, add a random card to your hand."},
                {name: "Fossilized Helix", desc: "Prevent the first time you lose HP each combat."},
                {name: "Ginger", desc: "You are immune to Weak."},
                {name: "Golden Eye", desc: "Whenever you Scry, Scry 2 more."},
                {name: "Ice Cream", desc: "You can save energy between turns."},
                {name: "Mango", desc: "On pickup, gain 14 max HP."},
                {name: "Old Coin", desc: "Instantly gain 300 gold."},
                {name: "Pocketwatch", desc: "If you play 2 or fewer Attacks in a turn, draw 2 more cards next turn."},
                {name: "Stone Calendar", desc: "At the end of turn 7, deal 52 damage to ALL enemies."},
                {name: "Thread and Needle", desc: "Start each combat with 4 Plated Armor."},
                {name: "Torii", desc: "When you take 5 or less unblocked damage, reduce it to 1."},
                {name: "Tungsten Rod", desc: "When you take unblocked damage, reduce it by 1."},
                {name: "Turnip", desc: "You are immune to Frail."},
                {name: "Unceasing Top", desc: "When your hand is empty during your turn, draw a card."}
            ];
            let bossRelicPool = [
                {name: "Busted Crown", desc: "+1 Max Energy. Card reward screens have only 1 card to choose from."},
                {name: "Coffee Dripper", desc: "+1 Max Energy. You can no longer rest at rest sites."},
                {name: "Cursed Key", desc: "+1 Max Energy. Whenever you defeat a boss, gain a Curse."},
                {name: "Ectoplasm", desc: "+1 Max Energy. You can no longer gain Gold."},
                {name: "Empty Cage", desc: "On pickup, remove 2 cards from your deck."},
                {name: "Fusion Hammer", desc: "+1 Max Energy. You can no longer smith at rest sites."},
                {name: "Pandora’s Box", desc: "On pickup, transform all Strikes and Defends."},
                {name: "Philosopher’s Stone", desc: "+1 Max Energy. ALL enemies start combat with 1 Strength."},
                {name: "Runic Dome", desc: "+1 Max Energy. You can no longer see enemy intents."},
                {name: "Runic Pyramid", desc: "At the end of your turn, you no longer discard your hand."},
                {name: "Sacred Bark", desc: "Double the effects of potions."},
                {name: "Slaver’s Collar", desc: "During Boss and Elite battles, gain 1 energy each turn."},
                {name: "Snecko Eye", desc: "At the start of each turn, draw 2 cards. Start each combat Confused."},
                {name: "Sozu", desc: "+1 Max Energy. You can no longer obtain Potions."},
                {name: "Velvet Choker", desc: "+1 Max Energy. You can only play 6 cards per turn."},
                {name: "Burning Blood", desc: "At end of combat, heal 6 HP."},
                {name: "Mark of Pain", desc: "+1 Max Energy. On pickup, become Cursed (x2)."},
                {name: "Serpent Ring", desc: "Replaces Snake Ring. At the start of each turn, draw a card."},
                {name: "Holy Water", desc: "Start each combat with a Miracle+ in hand."},
                {name: "Violet Lotus", desc: "Whenever you exit Calm, gain an additional energy."},
                {name: "Wrist Blade", desc: "Shivs deal 6 additional damage."}
            ];
            
            let potionPool = [
                {name: "Block", desc: "Gain 12 Block.", effect: 'Promise.resolve(gainBuff("Block", 12))'},
                {name: "Blood", desc: "Heal for 20% of your Max HP.", effect: 'hp = Math.min(maxHp, hp + Math.round(0.2 * maxHp))'},
                {name: "Cultist", desc: "Gain 1 Ritual.", effect: 'Promise.resolve(gainBuff("Ritual", 1))'},
                {name: "Dexterity", desc: "Gain 2 Dexterity.", effect: 'Promise.resolve(gainBuff("Dexterity", 2))'},
                {name: "Energy", desc: "Gain 2 energy.", effect: 'energy += 2'},
                {name: "Iron", desc: "Gain 5 Plated Armor.", effect: 'Promise.resolve(gainBuff("Plated Armor", 5))'},
                {name: "Explosive", desc: "Deal 10 damage to ALL enemies.", effect: 'for(let e of enemies){dealDamage(e, 10);}'},
                {name: "Fear", desc: "Apply 3 Vulnerable to target.", effect: 'Promise.resolve(tgt.gainBuff("Vulnerable", 3))'},
                {name: "Fire", desc: "Deal 20 damage to target.", effect: 'dealDamage(tgt, 20)'},
                {name: "Flex", desc: "Gain 5 Strength. At end of turn, lose 5 Strength.", effect: 'Promise.resolve(gainBuff("Strength", 5)); Promise.resolve(gainBuff("Strength Down", 5))'},
                {name: "Fruit Juice", desc: "Gain 5 Max HP.", effect: 'maxHp += 5; hp += 5'},
                {name: "Steel", desc: "Gain 5 Metallicize.", effect: 'Promise.resolve(gainBuff("Metallicize", 5))'},
                {name: "Bronze", desc: "Gain 3 Thorns.", effect: 'Promise.resolve(gainBuff("Thorns", 3))'},
                {name: "Regen", desc: "Gain 5 Regen.", effect: 'Promise.resolve(gainBuff("Regen", 5))'},
                {name: "Speed", desc: "Gain 5 Dexterity. At end of turn, lose 5 Dexterity.", effect: 'Promise.resolve(gainBuff("Dexterity", 5)); Promise.resolve(gainBuff("Dexterity Down", 5))'}
            ];
            
            let possibleEvents = {
                "All Acts": [
                    {
                        title: "Bonfire Spirits",
                        desc: "You happen upon a group of what looks like <span style='color:#f7f'>purple fire spirits</span> dancing around a large bonfire. The spirits toss small bones and fragments into the fire, which brilliantly erupts each time. As you approach, the spirits all turn to you expectantly...",
                        choices: [
                            ["Offer", "Receive a reward based on your offer.", `let fun = async function(){
let c = await choose(deck, "Choose a card to offer.");
if(["Barricade", "Berserk", "Bludgeon", "Brutality", "Demon Form", "Double Tap", "Corruption", "Exhume", "Feed", "Impervious", "Juggernaut", "Limit Break", "Offering", "Reaper", "A Thousand Cuts", "Adrenaline", "After Image", "Burst", "Die Die Die", "Doppelganger", "Envenom", "Grand Finale", "Storm of Steel", "Tools of the Trade"].includes(c.name.replace("+", ""))) {
    getId("eventDesc").innerHTML = "The flames <b>burst</b>, nearly knocking you off your feet, as the fire <b>doubles</b> in strength. The spirits dance around you excitedly before merging with you, filling you with strength. Your Max HP increases by 10 and you heal to full HP.";
    maxHp += 10; hp = maxHp;
} else if(["Strike", "Defend", "Bash", "Neutralize", "Eruption", "Vigilance"].includes(c.name.replace("+", ""))) {
    getId("eventDesc").innerHTML = "Nothing happens. The spirits seem to be ignoring you now. Disappointing...";
} else if(c.type == "Curse") {
    getId("eventDesc").innerHTML = "The spirits aren’t happy that you offered a Curse. You receive... something... in return.";
    relics.push({name: "Spirit Poop", desc: "It’s unpleasant."});
} else {
    getId("eventDesc").innerHTML = "The flames grow slightly brighter and you feel warmer. The spirits continue dancing. You heal 10 HP.";
    hp = Math.min(maxHp, hp + 10);
}
deck.splice(deck.indexOf(c), 1);
updateStatLine();
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}

                            }; fun();`]
                        ]
                    },
                    {
                        title: "We Meet Again!",
                        desc: '"We meet again!" A cheery, disheveled man walks up to you. "It\'s me, <span style=\'color: bb3\'>Ranwid</span>! Have anything for me today?" You have never met this man before.',
                        choices: [
                            ["Give Potion", "Trade one of your potions for a random relic.", `
if(!potions.length) {return;}
potions.splice(Math.floor(Math.random()*potions.length), 1);
let r = choice(choice(relicPool), choice(relicPool), choice(rareRelicPool));
relics.push(r);
if(r.name == "Strawberry"){maxHp += 7; hp += 7;}
if(r.name == "Pear"){maxHp += 10; hp += 10;}
if(r.name == "Mango"){maxHp += 14; hp += 14;}
if(r.name == "Old Coin"){gold += 300;}
updateStatLine();
getId("eventDesc").innerHTML = "He downs the potion in one go and lets out a satisfied burp. “Here, look what I’ve got for you today!” He pulls out a relic and hands it to you.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Give Gold", "Trade 100 gold for a random relic.", `
if(gold < 100) {return;}
gold -= 100;
let r = choice(choice(relicPool), choice(relicPool), choice(rareRelicPool));
relics.push(r);
if(r.name == "Strawberry"){maxHp += 7; hp += 7;}
if(r.name == "Pear"){maxHp += 10; hp += 10;}
if(r.name == "Mango"){maxHp += 14; hp += 14;}
if(r.name == "Old Coin"){gold += 300;}
updateStatLine();
getId("eventDesc").innerHTML = "“Thanks, this will be handy if I run into those mask wearing hoodlums again! Here, look what I’ve got for you today!” He pulls out a relic and hands it to you.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Leave", "No effect.", `
getId("eventDesc").innerHTML = "“Aargh! What a jerk you are sometimes!” He runs away.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Face Trader",
                        desc: "You walk by an eerie statue holding several masks. Something behind you softly whispers “Stop.” You spin around and realize that it's not a statue but a gaunt man. He says to you, “Face. Let me touch? Maybe trade?”",
                        choices: [
                            ["Touch", "Gain 75 gold, but lose 8 HP.", `
gold += 75;
hp -= 8;
let red = 0.4;
let i = 0;
while(red > 0) {
    setTimeout(function(r){getId("damage").style.opacity = r;}, i * 10, red);
    i++;
    red -= 0.012;
    if(red < 0) {setTimeout(function(){getId("damage").style.opacity = 0;}, i * 10);}
}
updateStatLine();
getId("eventDesc").innerHTML = "“Compensation. Compensation.” He takes out a stack of coins and places them in your pouch. “Nice face. Nice face.” As he touches your face, you feel your life begin to drain out! During this, his mask falls off and shatters. He quickly covers his face with his hands, dropping even more masks! In the commotion, you escape.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Trade", "40%: Good Face. 40%: Bad Face. 20%: Neutral Face.", `
relics.push(choice([
{name: "Cultist Headpiece", desc: "You feel more talkative."},
{name: "Face of Cleric", desc: "Raise your max HP by 1 after combat."},
{name: "Gremlin Visage", desc: "Start each combat with 1 Weak."},
{name: "N’loth’s Hungry Face", desc: "The next elite you fight drops no relic."},
{name: "Sssserpent Head", desc: "Whenever you enter a ❓ room, gain 50 gold."}
]));
updateStatLine();
getId("eventDesc").innerHTML = "His arm flickers for a moment, and afterward, you see your face in it. Your face has been swapped.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Leave", "No effect.", `
getId("eventDesc").innerHTML = "This was probably the right call.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Designer In-Spire",
                        desc: "You discover a <span style='color: #7f7'>colorful shop</span> with the banner IN-SPIRE and walk inside. A man appears, and with an exaggerated sigh, points at a list of services.",
                        choices: [
                            ["Clean Up", "Pay $60 to remove a card from your deck.", `let fun = async function() {
if(gold < 60) {return;}
gold -= 60;
let c = await choose(deck, "Choose a card to remove.");
deck.splice(deck.indexOf(c), 1);
updateStatLine();
getId("eventDesc").innerHTML = "“Okay, bye bye now.” ... should’ve punched him.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Adjustments", "Pay $40 to upgrade a card from your deck.", `let fun = async function() {
if(gold < 40) {return;}
gold -= 40;
let c = await choose(deck.filter(x=>!x.name.includes("+")), "Choose a card to upgrade.", false, true);
upgradeCard(c);
getId("eventDesc").innerHTML = "“Okay, bye bye now.” ... should’ve punched him.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Full Service", "Pay $120 to do both.", `let fun = async function() {
if(gold < 120) {return;}
gold -= 120;
let c = await choose(deck.filter(x=>!x.name.includes("+")), "Choose a card to upgrade.", false, true);
upgradeCard(c);
let d = await choose(deck, "Choose a card to remove.");
deck.splice(deck.indexOf(d), 1);
updateStatLine();
getId("eventDesc").innerHTML = "“Okay, bye bye now.” ... should’ve punched him.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Punch", "Lose 3 HP.", `
hp -= 3;
getId("eventDesc").innerHTML = "You punch him so hard, your fist hurts. “Oww! What was that for?”";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Duplicator",
                        desc: "Before you lies a decorated altar to some ancient entity.",
                        choices: [
                            ["Pray", "Duplicate a card.", `let fun = async function() {
let d = await choose(deck, "Choose a card to duplicate.");
deck.push(d);
for(let i of deck) {i.number = Math.random();} /* re-randomize the uuids */
getId("eventDesc").innerHTML = "As you kneel in prayer, a mirror image appears from the shrine and collides with you.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`]
                        ]
                    }
                ],
                "Act 1": [
                    {
                        title: "The Ssssserpent",
                        desc: "You walk into a room with a large hole in the ground. As you approach, an enormous serpent creature appears from within. “Hello adventurer, I ask a simple question. The most fulfilling of lives is that in which you can <span style='color: #bb3'>buy anything!</span> Do you agree?”",
                        choices: [
                            ["Yes", "Gain 175 gold, but gain Doubt.<br/><i>(Doubt: Unplayable. When drawn, gain 1 Frail.)</i>", `
gold += 175;
deck.push(new Card("Doubt", 0, "Curse", "Unplayable. When drawn, gain 1 Frail.", function(enemy){}, ["unplayable"]));
updateStatLine();
getId("eventDesc").innerHTML = "“Yessssssssssssssssssss... This will all be worth it. ..ssSSs... ..ss.. ..sSSsSss...!”<br/>The serpent blasts a stream of gold upwards! It is amazing and terrifying simultaneously.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["No", "No effect.", `
getId("eventDesc").innerHTML = "The serpent stares at you with a look of disappointment.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "World of Goop",
                        desc: "You fall into a puddle. <span style='color: #7f7'>IT'S MADE OF SLIME GOOP!!</span> You frantically claw yourself out, but notice that you -- and some other unfortunate adventurers -- left some gold behind.",
                        choices: [
                            ["Gather It", "Gain 75 gold, but lose 11 HP.", `
gold += 75;
hp -= 11;
let red = 0.46;
let i = 0;
while(red > 0) {
    setTimeout(function(r){getId("damage").style.opacity = r;}, i * 10, red);
    i++;
    red -= 0.012;
    if(red < 0) {setTimeout(function(){getId("damage").style.opacity = 0;}, i * 10);}
}
updateStatLine();
getId("eventDesc").innerHTML = "Feeling the sting of the prolonged exposure to the goop, you manage to fish out the gold.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Leave It", "Lose 40 gold.", `
gold = Math.max(gold-40, 0);
updateStatLine();
getId("eventDesc").innerHTML = "You decide that mess is not worth it.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Big Fish",
                        desc: "As you make your way down a long corridor, you see a <span style='color: #77f'>banana</span>, a <span style='color: #7f7'>donut</span>, and a <span style='color: #777'>box</span> floating around. On closer inspection, they are actually tied to strings hanging from the ceiling. There is a quiet cackling from above.",
                        choices: [
                            ["Banana", "Heal 24 HP.", `
hp = Math.min(hp + 24, maxHp);
updateStatLine();
getId("eventDesc").innerHTML = "You grab the banana. It is nutritious and slightly magical, healing you.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Donut", "Max HP +5.", `
maxHp += 5; hp += 5;
updateStatLine();
getId("eventDesc").innerHTML = "You grab the donut. It really hits the spot! Your Max HP increases.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Box", "Obtain a random relic, but gain Regret.<br/><i>(Regret: Unplayable. At the end of your turn, lose 1 HP per card in your hand.)</i>", `
let r = choice(choice(relicPool), choice(relicPool), choice(rareRelicPool));
relics.push(r);
if(r.name == "Strawberry"){maxHp += 7; hp += 7;}
if(r.name == "Pear"){maxHp += 10; hp += 10;}
if(r.name == "Mango"){maxHp += 14; hp += 14;}
if(r.name == "Old Coin"){gold += 300;}
deck.push(new Card("Regret", 0, "Curse", "Unplayable. At the end of your turn, lose 1 HP per card in your hand.", function(enemy){}, ["unplayable"]));
updateStatLine();
getId("eventDesc").innerHTML = "You grab the box and find a relic inside! However, you really craved that donut... You are filled with regret.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Ominous Forge",
                        desc: "You duck into a small hut. Inside you find what appears to be a forge. The smithing tools are covered with dust, yet a fire still burns in the furnace.",
                        choices: [
                            ["Forge", "Upgrade a card.", `let fun = async function(){
let c = await choose(deck.filter(x=>!x.name.includes("+")), "Choose a card to upgrade.", false, true);
upgradeCard(c);
updateStatLine();
getId("eventDesc").innerHTML = "You decide to put the forge to use, improving your arsenal.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Rummage", "Obtain a special relic, but gain Pain.<br/><i>(Pain: Unplayable. Whenever you play a card this turn, lose 1 HP.)</i>", `
relics.push({name: "Warped Tongs", desc: "At the start of your turn, upgrade a random card in your hand this combat."});
deck.push(new Card("Pain", 0, "Curse", "Unplayable. Whenever you play a card this turn, lose 1 HP.", function(enemy){}, ["unplayable"]));
updateStatLine();
getId("eventDesc").innerHTML = "You search the hut and eventually find some old tongs! But, you prick yourself on their sharp points...";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Scrap Ooze",
                        desc: "As you walk into a room you hear a gurgling and grinding sound. Before you is a slime-like creature that ate too much scrap for its own good. From the center you see glints of strange light, as though you could find something valuable. However, the acid and sharp objects may <span style='color: #f77'>hurt</span>.",
                        choices: [
                            ["Reach Inside", "Lose <span id=hploss>3</span> HP. <span id=relicchance>25</span>% chance to find a relic.", `
let hpLoss = parseInt(getId("hploss").textContent);
let relicChance = parseInt(getId("relicchance").textContent);
hp -= hpLoss;
let red = hpLoss * 0.02 + 0.24;
let i = 0;
while(red > 0) {
    setTimeout(function(r){getId("damage").style.opacity = r;}, i * 10, red);
    i++;
    red -= 0.012;
    if(red < 0) {setTimeout(function(){getId("damage").style.opacity = 0;}, i * 10);}
}
if(Math.random() < relicChance * 0.01) {
    let r = choice(choice(relicPool), choice(relicPool), choice(rareRelicPool));
    relics.push(r);
    if(r.name == "Strawberry"){maxHp += 7; hp += 7;}
    if(r.name == "Pear"){maxHp += 10; hp += 10;}
    if(r.name == "Mango"){maxHp += 14; hp += 14;}
    if(r.name == "Old Coin"){gold += 300;}
    getId("eventDesc").innerHTML = "Success! You found a relic inside the slime!";
    getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
    getId("woogleButton").onclick = function() {showMap();};
} else {
    hpLoss += 1;
    relicChance += 10;
    getId("eventDesc").innerHTML = "Ouch! You didn’t find a relic, but you’re convinced that there is one...";
    getId("hploss").innerHTML = hpLoss;
    getId("relicchance").innerHTML = relicChance;
}
updateStatLine();
                            `],
                            ["Leave", "No effect.", `
getId("eventDesc").innerHTML = "You decide to leave the area. The slime ignores you, content with its meal.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "The Cleric",
                        desc: "A strange blue humanoid with a golden helm(?) approaches you with a huge smile. “<b>Hello friend! I am Cleric! Are you interested in my services!?</b>” the creature shouts loudly.",
                        choices: [
                            ["Heal", "Pay $20 to heal 20 HP.", `
if(gold < 20) return;
gold -= 20;
hp = Math.min(maxHp, hp + 20);
updateStatLine();
getId("eventDesc").innerHTML = "A warm gold flame envelops your body and dissipates. The creature grins. “Cleric best healer. Have a good day!”";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Purify", "Pay $50 to remove a card.", `let fun = async function() {
if(gold < 50) return;
gold -= 50;
let c = await choose(deck, "Choose a card to remove.");
deck.splice(deck.indexOf(c), 1);
updateStatLine();
getId("eventDesc").innerHTML = "A cold blue flame envelops your body and dissipates. The creature grins. “Cleric talented. Have a good day!”";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Leave", "No effect.", `
getId("eventDesc").innerHTML = "You don’t trust this Cleric, so you leave.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Living Wall",
                        desc: "As you come to a dead end and begin to turn around, three walls slam down from the ceiling, trapping you! Faces materialize from the walls and speak:<br/><span style='color: #7ff'>“Forget what you know, and I'll let you go.”</span><br/><span style='color: #f7f'>“I require change to see a new space.”</span><br/><span style='color: #ff7'>“If you want to pass me, then you must grow.”</span>",
                        choices: [
                            ["Forget", "Remove a card from your deck.", `let fun = async function() {
let c = await choose(deck, "Choose a card to remove.");
deck.splice(deck.indexOf(c), 1);
updateStatLine();
getId("eventDesc").innerHTML = "Satisfied, the walls merge back into the ceiling, leaving a path forward.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Change", "Transform + Upgrade a card from your deck.", `let fun = async function() {
let c = await choose(deck, "Choose a card to transform.");
deck.splice(deck.indexOf(c), 1);
deck.push(upgradedCards[randCard(upg=false).name]());
getId("eventDesc").innerHTML = "Satisfied, the walls merge back into the ceiling, leaving a path forward.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Grow", "Upgrade a card from your deck.", `let fun = async function() {
let c = await choose(deck.filter(x=>!x.name.includes("+")), "Choose a card to upgrade.", false, true);
upgradeCard(c);
getId("eventDesc").innerHTML = "Satisfied, the walls merge back into the ceiling, leaving a path forward.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`]
                        ]
                    },
                    {
                        title: "Wing Statue",
                        desc: "Among the stone and boulders, you notice an intricate blue statue resembling a wing. You find gold spilling from its cracks. Maybe there is more inside...",
                        choices: [
                            ["Pray", "Remove a card from your deck. Lose 7 HP.", `let fun = async function() {
let c = await choose(deck, "Choose a card to remove.");
deck.splice(deck.indexOf(c), 1);
hp -= 7;
let red = 0.38;
let i = 0;
while(red > 0) {
    setTimeout(function(r){getId("damage").style.opacity = r;}, i * 10, red);
    i++;
    red -= 0.012;
    if(red < 0) {setTimeout(function(){getId("damage").style.opacity = 0;}, i * 10);}
}
updateStatLine();
getId("eventDesc").innerHTML = "Someone once told you of a cult that worshipped a giant bird. As you kneel in prayer, you feel a bit lightheaded.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Destroy", "Gain 50 gold.", `
gold += 50;
updateStatLine();
getId("eventDesc").innerHTML = "You hack away at the statue until you can reach all the gold inside. You grab it and continue on.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Shining Light",
                        desc: "You find a shimmering <span style='color: bb3'>mass of light</span> in the center of a room. Its warm glow and enchanting patterns invite you in.",
                        choices:
                        [
                            ["Enter", "Upgrade 2 cards. Lose 15 HP.", `
let c = choice(deck.filter(x=>!x.name.includes("+")));
upgradeCard(c);
let d = choice(deck.filter(x=>!x.name.includes("+")));
upgradeCard(c);
hp -= 15;
let red = 0.54;
let i = 0;
while(red > 0) {
    setTimeout(function(r){getId("damage").style.opacity = r;}, i * 10, red);
    i++;
    red -= 0.012;
    if(red < 0) {setTimeout(function(){getId("damage").style.opacity = 0;}, i * 10);}
}
getId("eventDesc").innerHTML = "The light is absorbed into your skin. It’s scorching hot, but the pain quickly recedes.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Leave", "No effect.", `
getId("eventDesc").innerHTML = "You walk around it, wondering what could have been.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    }
                ],
                "Act 2": [
                    {
                        title: "Council of Ghosts",
                        desc: "As you continue your ascent, <span style='color: f7f'>thick smoke</span> begins to billow out of the ground and walls, coalescing into three forms that start to speak. “AnoThEr pUpPEt oF NeOW I tHiNK.”  <span style='color: #f33'>“AGREED! SHE ALWAYS MAKES THE FUNNIEST TOYS!”</span> ”Ignore the others... would you like a taste of our power?“",
                        choices:
                        [
                            ["Yes", "Receive 5 Apparition. Lose 50% of Max HP.<br/><i>(Apparition: Ethereal. Reduce damage and HP loss to 1 this turn. Exhaust.)</i>", `
maxHp = Math.round(0.5 * maxHp);
hp = Math.min(hp, maxHp);
for(let i=0; i<5; i++) {
    deck.push(new Card("Apparition", 1, "Skill", "Ethereal. Reduce damage and HP loss to 1 this turn. Exhaust.", function(enemy){gainBuff("Intangible", 1);}, ["ethereal", "exhausted"]));
}
let red = 0.24 + 0.01 * maxHp;
let i = 0;
while(red > 0) {
    setTimeout(function(r){getId("damage").style.opacity = r;}, i * 10, red);
    i++;
    red -= 0.012;
    if(red < 0) {setTimeout(function(){getId("damage").style.opacity = 0;}, i * 10);}
}
getId("eventDesc").innerHTML = "Smoke spews from the ghostly form as it speaks, enveloping you in darkness. As the sensation stops, you continue on, feeling rather hollow.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["No", "No effect.", `
getId("eventDesc").innerHTML = "“How disappointing...” “YOu wILl jOIn uS sOoNEr oR LaTEr.” “HA HA HA HAHAHAHA!”";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "The Library",
                        desc: "You come across an ornate building which appears abandoned. A plaque that reads “THE LIBRARY” has been torn from a wall. Inside you find countless rows of manuscripts, scrolls, and books.",
                        choices:
                        [
                            ["Read", "Choose 1 of 20 cards to add to your deck.", `let fun = async function(){
let possibilities = [];
for(let i=0; i<17; i++) {
    possibilities.push(randCard());
}
for(let i=0; i<3; i++) {
    possibilities.push(randRareCard());
}
deck.push( await choose(possibilities, "Choose a card to add to your deck.") );
getId("eventDesc").innerHTML = "You pick up a stack of books and spend hours reading through them.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Sleep", "Heal 24 HP.", `
hp = Math.min(hp + 24, maxHp);
getId("eventDesc").innerHTML = "Reading is for chumps. You doze off in a comfy chair instead. ...zZz.. .zzZz.. ..zzz..";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Pleading Vagrant",
                        desc: "While sneaking past a group of shrouded figures, one of them approaches you. “Got anything for me friend? Maybe some gold? I just need somewhere to stay, I have things I can trade...”",
                        choices:
                        [
                            ["Give", "Obtain a random relic. Give 85 gold.", `let fun = async function(){
if(gold < 85) {return;}
gold -= 85;
let r = choice(choice(relicPool), choice(relicPool), choice(rareRelicPool));
relics.push(r);
if(r.name == "Strawberry"){maxHp += 7; hp += 7;}
if(r.name == "Pear"){maxHp += 10; hp += 10;}
if(r.name == "Mango"){maxHp += 14; hp += 14;}
if(r.name == "Old Coin"){gold += 300;}
getId("eventDesc").innerHTML = "“Oh yes! Here here, a fair trade!”";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Rob", "Obtain a random relic, but gain Shame.<br/><i>(Shame: Unplayable. When drawn, gain 1 Weak.)</i>", `
let r = choice(choice(relicPool), choice(relicPool), choice(rareRelicPool));
relics.push(r);
if(r.name == "Strawberry"){maxHp += 7; hp += 7;}
if(r.name == "Pear"){maxHp += 10; hp += 10;}
if(r.name == "Mango"){maxHp += 14; hp += 14;}
if(r.name == "Old Coin"){gold += 300;}
deck.push(new Card("Shame", 0, "Curse", "Unplayable. When drawn, gain 1 Weak.", function(enemy){}, ["unplayable"]));
getId("eventDesc").innerHTML = "You snatch the relic from him and run away. From behind, you hear, “Have you no shame? HAVE YOU NO SHAAAME!?” You have some shame.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Leave", "No effect.", `
getId("eventDesc").innerHTML = "...";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Ancient Writing",
                        desc: "Scaling the city, you notice a wall covered in the writing of <span style='color: bb3'>Ancients</span>. As you try to wrap your head around what the puzzling symbols mean, they start to glow. Suddenly the message becomes clear...",
                        choices: [
                            ["Elegance", "Remove a card from your deck.", `let fun = async function(){
let c = await choose(deck, "Choose a card to remove.");
deck.splice(deck.indexOf(c), 1);
updateStatLine();
getId("eventDesc").innerHTML = "The answer was elegance. Of course.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Simplicity", "Upgrade all Strikes and Defends.", `
for(let i of deck) {
    if(i.name == "Strike" || i.name == "Defend") {
        upgradeCard(i);
    }
}
getId("eventDesc").innerHTML = "The truth is always simple.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Old Beggar",
                        desc: "An old beggar reaches toward you as you pass.",
                        choices: [
                            ["Give Gold", "Pay 50 gold. Effect: ???", `let fun = async function() {
if(gold < 50) return;
gold -= 50;
let c = await choose(deck, "Choose a card to remove.");
deck.splice(deck.indexOf(c), 1);
updateStatLine();
getId("eventDesc").innerHTML = "He removes his cloak to reveal that he is Cleric! “You are a kind soul. Receive my purification!” he yells. You are unsure if he is grateful or mad.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Leave", "No effect.", `
getId("eventDesc").innerHTML = "“You will never make a difference... You never do.” they say.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    }
                ],
                "Act 3": [
                    {
                        title: "Winding Halls",
                        desc: "As you make your way up the twisting passageways, the ground and walls seem to shift before your eyes. The constant <span style='color: #f7f'>whispering voices</span> in the back of your head aren't helping either. You start to question if you are going insane, or if the impossible geography of this place is starting to get to you. You need to change something, and soon.",
                        choices:
                        [
                            ["Embrace Madness", "Obtain 2 Madness. Lose 10 HP.<br/><i>(Madness: 0 energy. Reduce the cost of a random card in your hand to 0 this turn. Exhaust.)</i>", `let fun = async function(){
hp -= 10;
let red = 0.44;
let i = 0;
while(red > 0) {
    setTimeout(function(r){getId("damage").style.opacity = r;}, i * 10, red);
    i++;
    red -= 0.012;
    if(red < 0) {setTimeout(function(){getId("damage").style.opacity = 0;}, i * 10);}
}
deck.push(new Card("Madness", 0, "Skill", "Reduce the cost of a random card in your hand to 0 this turn. Exhaust.", function(enemy){
    let eligible = hand.filter(x=>x.cost > 0);
    if(eligible.length == 0) return;
    let c = eligible[Math.floor(Math.random()*eligible.length)];
    c.flags.push("nextcost "+c.cost);
    c.cost = 0;
}, ["exhausted"]));
deck.push(new Card("Madness", 0, "Skill", "Reduce the cost of a random card in your hand to 0 this turn. Exhaust.", function(enemy){
    let eligible = hand.filter(x=>x.cost > 0);
    if(eligible.length == 0) return;
    let c = eligible[Math.floor(Math.random()*eligible.length)];
    c.flags.push("nextcost "+c.cost);
    c.cost = 0;
}, ["exhausted"]));
getId("eventDesc").innerHTML = "Something in you cracks. You give in to the chattering voices and continue with a new perspective.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Press On", "Heal 18 HP, but gain Writhe.<br/><i>(Writhe: Unplayable. Innate.)</i>", `
hp = Math.min(hp + 18, maxHp);
deck.push(new Card("Writhe", 0, "Curse", "Unplayable. Innate.", function(enemy){}, ["unplayable", "innate"]));
getId("eventDesc").innerHTML = "You take a moment to carefully observe the landscape around you. Slowly, the hint of a pattern emerges from the randomness. You struggle through the mental pain to map out a path forward.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Retrace Your Steps", "Lose 4 Max HP.", `
maxHp -= 4;
hp = Math.min(hp, maxHp);
getId("eventDesc").innerHTML = "Slowly but surely, you reorient yourself and make it out from the twisting passages. You feel drained from the experience.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Augmenter",
                        desc: "A man with an eyepatch and a devilish grin strides up to you. “Hey there! Interested in advancing science? I can make you stronger than any training or blessing. You'll need it if you're one of those heroes with a death wish.”",
                        choices:
                        [
                            ["Test JAX", "Obtain a JAX.<br/><i>(JAX: 0 energy. Lose 3 HP. Gain 2 Strength.)</i>", `let fun = async function(){
deck.push(new Card("JAX", 0, "Skill", "Lose 3 HP. Gain 2 Strength.", function(enemy){
    hp -= 3; gainBuff("Strength", 2);
}, ["exhausted"]));
getId("eventDesc").innerHTML = "The man hands you a dangerous-looking syringe filled with a glowing liquid before skulking off.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            }; fun();`],
                            ["Become Test Subject", "Transform 2 cards.", `
let c = await choose(deck, "Choose a card to transform.");
deck.splice(deck.indexOf(c), 1);
let d = await choose(deck, "Choose another card to transform.");
deck.splice(deck.indexOf(d), 1);
deck.push(randCard());
deck.push(randCard());
getId("eventDesc").innerHTML = "The man injects you with two unknown substances and frantically writes down notes as you start to feel lightheaded.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Ingest Mutagens", "Obtain a special relic.", `
relics.push({name: "Mutagenic Strength", desc: "You have 3 Strength on the first turn."});
getId("eventDesc").innerHTML = "You quaff the mysterious substance. Immediately, you are invigorated and you feel your muscle fibers twitch.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    },
                    {
                        title: "Tomb of Lord Red Mask",
                        desc: "You notice a highly ornamental tomb on the other side of a path. You notice a slot for gold coins with a scratched out inscription above it.",
                        choices: [
                            ["Offer", "Lose ALL gold. Obtain a special relic.", `
gold = 0;
relics.push({name: "Red Mask", desc: "ALL enemies start combat with 1 Weak."});
getId("eventDesc").innerHTML = "An opening appears in the tomb and out slides a red mask with a note attached: “Take from others as I have taken from you!”";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `],
                            ["Leave", "No effect.", `
getId("eventDesc").innerHTML = "You ignore the suspicious looking tomb.";
getId("eventChoices").innerHTML = "<button id=woogleButton>Leave</button>";
getId("woogleButton").onclick = function() {showMap();}
                            `]
                        ]
                    }
                ]
            };
            
            // Starting deck, relics, etc...
            let deck = [bash(), strike(), strike(), strike(), neutralize(), defend(), defend(), defend(), eruption(), vigilance()];
            let relics = [{name: "Snake Ring", desc: "At the start of each combat, draw 2 more cards."}];
            let potions = [];
            let drawPile = shuffle(deck.slice(0)); // no shallow copy //
            let discardPile = [];
            let exhaustPile = [];
            let hand = [];
            let energy = 0;
            let maxEnergy = 3;
            let hp = 70;
            let maxHp = 70;
            let buffs = [];
            let stats = {timesLostHp: 0, attacksThisTurn: 999, skillsThisTurn: 999, rested: false, lastType: "None", pers: 0, windmill: 0, mantraGain: 0, cardsThisTurn: 999};
            let gold = 0;
            let mapX = 2;
            let mapY = 0;
            let actNum = 1;
            let turn = 0;
            let crCost = 75;
            let randomThing = () => choice(["❓","💀","💀","💀","💀","💲","😈","🏕️"]);
            let topThing = () => choice(["❓", "💀", choice(["💀","💀","💲","🏕️"])]);
            function maybeThing() {if(Math.random()<0.6){return randomThing();}else{return "";}}
            let map; //❓
            function mapGen() {
                map = [
                    ["","",   "🐋",  "",  ""],
                    ["","💀", "💀",  "💀",""]
                ];
                
                let middleFloors = [];
                middleFloors.push([maybeThing(), topThing(),    topThing(),    topThing(),    maybeThing()]);
                middleFloors.push([maybeThing(), topThing(),    topThing(),    topThing(),    maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), randomThing(), randomThing(), maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), "🏕️",          randomThing(), maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), randomThing(), randomThing(), maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), randomThing(), randomThing(), maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), randomThing(), "🏕️",          maybeThing()]);
                middleFloors.push([maybeThing(), "🏕️",          randomThing(), randomThing(), maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), randomThing(), randomThing(), maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), randomThing(), randomThing(), maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), randomThing(), randomThing(), maybeThing()]);
                middleFloors.push([maybeThing(), randomThing(), randomThing(), randomThing(), maybeThing()]);
                
                let numRests = middleFloors.flat().filter(x=>x=="🏕️").length;
                while(numRests > (getId("ascensionLevel").value >= 15 ? 5 : 7)) {
                    let rowsWithRests = middleFloors.filter(x=>x.includes("🏕️"));
                    let rowWithRest = choice(rowsWithRests);
                    let restSites = rowWithRest.filter(x=>x=="🏕️");
                    let restSite = choice(restSites.map(x=>rowWithRest.indexOf(x)));
                    let newNode = randomThing();
                    let rowIndex = middleFloors.indexOf(rowWithRest);
                    middleFloors[rowIndex][restSite] = newNode;
                    numRests = middleFloors.flat().filter(x=>x=="🏕️").length;
                }
                while(numRests < (getId("ascensionLevel").value >= 15 ? 4 : 6)) {
                    let row = Math.floor(Math.random()*12);
                    let col = Math.floor(Math.random()*5);
                    while(middleFloors[row][col] == "" || !middleFloors[row][col]) {col = Math.floor(Math.random()*5);}
                    middleFloors[row][col] = "🏕️";
                    numRests = middleFloors.flat().filter(x=>x=="🏕️").length;
                }
                let numElites = middleFloors.flat().filter(x=>x=="😈").length;
                while(numElites < 4) {
                    let row = Math.floor(Math.random()*12);
                    let col = Math.floor(Math.random()*5);
                    while(middleFloors[row][col] == "" || !middleFloors[row][col]) {col = Math.floor(Math.random()*5);}
                    middleFloors[row][col] = "😈";
                    numElites = middleFloors.flat().filter(x=>x=="😈").length;
                }
                for(let i of middleFloors) {map.push(i);}
                map.push(["","🏕️","🏕️","🏕️",""]);
                map.push(["","",  "👺","",  ""]);
            }
            
            // These make writing attacks *much* easier.
            function addStatus(name, amt) {
                for(let x=0; x<amt; x++) {discardPile.push(statusCards[name]());}
            }
            let attack = amt => function(me){ me.dealDamage(amt); }
            let block = amt => function(me){ me.gainBuff("Block", amt); }
            let block_other = (blk) => function(me){ let x=choice(enemies.filter(x=>!x.number==me.number)); if(x) x.gainBuff("Block", blk); }
            let buff = (what, amt) => function(me){ me.gainBuff(what, amt); }
            let all_buff = (what, amt) => function(me){ for(let e of enemies){e.gainBuff(what, amt);}}
            let apply = (what, amt) => function(me){ gainBuff(what, amt); }
            let status = (what, amt) => function(me){ addStatus(what, amt); }
            let multi_apply = (lst) => function(me){ for(let x of lst){gainBuff(x[0], x[1]);} }
            let attack_multinerf = (atk, lst) => function(me){ me.dealDamage(atk); for(let x of lst){gainBuff(x[0], x[1]);} }
            let attack_multibuff = (atk, lst) => function(me){ me.dealDamage(atk); for(let x of lst){me.gainBuff(x[0], x[1]);} }
            let multi_buff = (lst) => function(me){ for(let x of lst){me.gainBuff(x[0], x[1]);} }
            let attack_block = (atk, blk) => function(me){ me.dealDamage(atk); me.gainBuff("Block", blk); }
            let attack_apply = (atk, what, amt) => function(me){ me.dealDamage(atk); gainBuff(what, amt); }
            let attack_buff = (atk, what, amt) => function(me){ me.dealDamage(atk); me.gainBuff(what, amt); }
            let block_buff = (blk, what, amt) => function(me){ me.gainBuff("Block", blk); me.gainBuff(what, amt); }
            let block_multinerf = (blk, lst) => function(me){ me.gainBuff("Block", blk); for(let x of lst){gainBuff(x[0], x[1]);}}
            let attack_status = (atk, what, amt) => function(me){ addStatus(what, amt); me.dealDamage(atk); }
            let buff_apply = (b, bamt, n, namt) => function(me){ me.gainBuff(b, bamt); gainBuff(n, namt); }
            let passTurn = () => function(me){}
            
            let cultist = () => new Enemy("Cultist", "n", 50, 55, [
                {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                {intent: "attacking 3", desc: "deal [DAM3] damage", effect: attack(3)}
            ], [
                {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 4)},
                {intent: "attacking 3", desc: "deal [DAM3] damage", effect: attack(3)}
            ], [
                {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 5)},
                {intent: "attacking 3", desc: "deal [DAM3] damage", effect: attack(3)}
            ], ["no-repeat"]);
            let jawWorm = () => new Enemy("Jaw Worm", "n", 42, 44, [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 5)},
                {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 3)}
            ], [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(12)},
                {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 5)},
                {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 4)}
            ], [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(12)},
                {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 5)},
                {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(9, "Strength", 5)}
            ], ["randomize"]);
            let hardJawWorm = () => new Enemy("Jaw Worm", "n", 47, 49, [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 5)},
                {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 3)}
            ], [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(12)},
                {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 5)},
                {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 4)}
            ], [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(12)},
                {intent: "attack-block 7", desc: "deal [DAM7] damage and block", effect: attack_block(7, 5)},
                {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(9, "Strength", 5)}
            ], ["randomize"], {"Strength": 2}, {"Strength": 4});
            let rLouse = () => new Enemy("Red Louse", "n", 12, 14, [
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 3)}
            ], [
                {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 3)}
            ], [
                {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 4)}
            ], ["randomize", "repeatable"], {"Curl Up": 4 + Math.floor(Math.random()*4)}, {"Curl Up": 9 + Math.floor(Math.random()*4)});
            let gLouse = () => new Enemy("Green Louse", "n", 14, 16, [
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
            ], [
                {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
            ], [
                {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
            ], ["randomize", "repeatable"], {"Curl Up": 4 + Math.floor(Math.random()*4)}, {"Curl Up": 9 + Math.floor(Math.random()*4)});
            let looter = () => new Enemy("Looter", "n", 46, 48, [
                {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Thievery", 15)},
                {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Thievery", 15)},
                {intent: "attack-buff 12", desc: "deal [DAM12] damage and gain a buff", effect: attack_buff(12, "Thievery", 15)},
                {intent: "blocking", desc: "block", effect: block(6)},
                {intent: "unknown", desc: "escape with your gold", effect: function(me){enemies.splice(enemies.indexOf(me), 1); gold -= me.hasBuff("Thievery");}}
            ], [
                {intent: "attack-buff 11", desc: "deal [DAM11] damage and gain a buff", effect: attack_buff(11, "Thievery", 15)},
                {intent: "attack-buff 11", desc: "deal [DAM11] damage and gain a buff", effect: attack_buff(11, "Thievery", 15)},
                {intent: "attack-buff 14", desc: "deal [DAM14] damage and gain a buff", effect: attack_buff(14, "Thievery", 15)},
                {intent: "blocking", desc: "block", effect: block(6)},
                {intent: "unknown", desc: "escape with your gold", effect: function(me){enemies.splice(enemies.indexOf(me), 1); gold -= me.hasBuff("Thievery");}}
            ], [
                {intent: "attack-buff 11", desc: "deal [DAM11] damage and gain a buff", effect: attack_buff(11, "Thievery", 20)},
                {intent: "attack-buff 11", desc: "deal [DAM11] damage and gain a buff", effect: attack_buff(11, "Thievery", 20)},
                {intent: "attack-buff 14", desc: "deal [DAM14] damage and gain a buff", effect: attack_buff(14, "Thievery", 20)},
                {intent: "blocking", desc: "block", effect: block(6)},
                {intent: "unknown", desc: "escape with your gold", effect: function(me){enemies.splice(enemies.indexOf(me), 1); gold -= me.hasBuff("Thievery");}}
            ]);
            let mugger = () => new Enemy("Mugger", "n", 50, 52, [
                {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Thievery", 15)},
                {intent: "attack-buff 10", desc: "deal [DAM10] damage and gain a buff", effect: attack_buff(10, "Thievery", 15)},
                {intent: "attack-buff 16", desc: "deal [DAM16] damage and gain a buff", effect: attack_buff(16, "Thievery", 15)},
                {intent: "blocking", desc: "block", effect: block(11)},
                {intent: "unknown", desc: "escape with your gold", effect: function(me){enemies.splice(enemies.indexOf(me), 1); gold -= me.hasBuff("Thievery");}}
            ], [
                {intent: "attack-buff 11", desc: "deal [DAM11] damage and gain a buff", effect: attack_buff(11, "Thievery", 15)},
                {intent: "attack-buff 11", desc: "deal [DAM11] damage and gain a buff", effect: attack_buff(11, "Thievery", 15)},
                {intent: "attack-buff 18", desc: "deal [DAM18] damage and gain a buff", effect: attack_buff(18, "Thievery", 15)},
                {intent: "blocking", desc: "block", effect: block(11)},
                {intent: "unknown", desc: "escape with your gold", effect: function(me){enemies.splice(enemies.indexOf(me), 1); gold -= me.hasBuff("Thievery");}}
            ], [
                {intent: "attack-buff 11", desc: "deal [DAM11] damage and gain a buff", effect: attack_buff(11, "Thievery", 20)},
                {intent: "attack-buff 11", desc: "deal [DAM11] damage and gain a buff", effect: attack_buff(11, "Thievery", 20)},
                {intent: "attack-buff 18", desc: "deal [DAM18] damage and gain a buff", effect: attack_buff(18, "Thievery", 20)},
                {intent: "blocking", desc: "block", effect: block(17)},
                {intent: "unknown", desc: "escape with your gold", effect: function(me){enemies.splice(enemies.indexOf(me), 1); gold -= me.hasBuff("Thievery");}}
            ]);
            let bSlaver = () => new Enemy("Blue Slaver", "n", 48, 50, [
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attack-nerf 7", desc: "deal [DAM7] damage & apply a negative effect", effect: attack_apply(7, "Weak", 1)}
            ], [
                {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                {intent: "attack-nerf 8", desc: "deal [DAM8] damage & apply a negative effect", effect: attack_apply(8, "Weak", 1)}
            ], [
                {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                {intent: "attack-nerf 8", desc: "deal [DAM8] damage & apply a negative effect", effect: attack_apply(8, "Weak", 2)}
            ], ["randomize", "repeatable"]);
            let rSlaver = () => new Enemy("Red Slaver", "n", 48, 50, [
                {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                {intent: "attack-nerf 8", desc: "deal [DAM8] damage & apply negative effect", effect: attack_apply(8, "Vulnerable", 1)}
            ], [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attack-nerf 9", desc: "deal [DAM9] damage & apply negative effect", effect: attack_apply(9, "Vulnerable", 1)}
            ], [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attack-nerf 9", desc: "deal [DAM9] damage & apply negative effect", effect: attack_apply(9, "Vulnerable", 2)}
            ], ["randomize", "repeatable"]);
            let fungiBeast = () => new Enemy("Fungi Beast", "n", 25, 26, [
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 3)}
            ], [
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 4)}
            ], [
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 5)}
            ], ["randomize", "repeatable"], {"Spore Cloud": 2}, {"Spore Cloud": 2});
            let spikeSlimeL = () => new Enemy("Large Spike Slime", "n", 67, 70, [
                {intent: "attack-nerf 16", desc: "deal [DAM16] damage & generate Status cards", effect: attack_status(16, "Slimed", 2)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 2)}
            ], [
                {intent: "attack-nerf 18", desc: "deal [DAM18] damage & generate Status cards", effect: attack_status(18, "Slimed", 2)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 2)}
            ], [
                {intent: "attack-nerf 18", desc: "deal [DAM18] damage & generate Status cards", effect: attack_status(18, "Slimed", 2)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 3)}
            ], ["randomize", "repeatable"], {"Split": 1}, {"Split": 1});
            let spikeSlimeM = () => new Enemy("Medium Spike Slime", "n", 30, 32, [
                {intent: "attack-nerf 8", desc: "deal [DAM8] damage & generate Status cards", effect: attack_status(8, "Slimed", 1)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 1)}
            ], [
                {intent: "attack-nerf 10", desc: "deal [DAM10] damage & generate Status cards", effect: attack_status(10, "Slimed", 2)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 1)}
            ], [
                {intent: "attack-nerf 10", desc: "deal [DAM10] damage & generate Status cards", effect: attack_status(10, "Slimed", 2)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 1)}
            ], ["randomize", "repeatable"]);
            let spikeSlimeS = () => new Enemy("Small Spike Slime", "n", 12, 13, [
                {intent: "attacking 5", desc: "deal [DAM5] damage", effect: attack(5)}
            ], [
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}
            ], [
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}
            ], ["randomize", "repeatable"]);
            let acidSlimeL = () => new Enemy("Large Acid Slime", "n", 67, 70, [
                {intent: "attack-nerf 11", desc: "deal [DAM11] damage & generate Status cards", effect: attack_status(11, "Slimed", 2)},
                {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
            ], [
                {intent: "attack-nerf 12", desc: "deal [DAM12] damage & generate Status cards", effect: attack_status(12, "Slimed", 2)},
                {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
            ], [
                {intent: "attack-nerf 12", desc: "deal [DAM12] damage & generate Status cards", effect: attack_status(12, "Slimed", 2)},
                {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
            ], ["randomize", "repeatable"], {"Split": 1}, {"Split": 1});
            let acidSlimeM = () => new Enemy("Medium Acid Slime", "n", 30, 32, [
                {intent: "attack-nerf 7", desc: "deal [DAM7] damage & generate Status cards", effect: attack_status(7, "Slimed", 1)},
                {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)}
            ], [
                {intent: "attack-nerf 8", desc: "deal [DAM8] damage & generate Status cards", effect: attack_status(8, "Slimed", 1)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)}
            ], [
                {intent: "attack-nerf 8", desc: "deal [DAM8] damage & generate Status cards", effect: attack_status(8, "Slimed", 1)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)}
            ], ["randomize", "repeatable"]);
            let acidSlimeS = () => new Enemy("Small Acid Slime", "n", 12, 13, [
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                {intent: "attacking 3", desc: "deal [DAM3] damage", effect: attack(3)}
            ], [
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
            ], [
                {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
            ], ["randomize", "repeatable"]);
            let fatGremlin = () => new Enemy("Fat Gremlin", "n", 15, 16, [
                {intent: "attack-nerf 4", desc: "deal [DAM4] damage and apply a negative effect", effect: attack_apply(4, "Weak", 1)}
            ], [
                {intent: "attack-nerf 5", desc: "deal [DAM5] damage and apply a negative effect", effect: attack_apply(5, "Weak", 1)}
            ], [
                {intent: "attack-nerf 5", desc: "deal [DAM5] damage and apply a negative effect", effect: attack_multinerf(5, [["Weak", 1], ["Frail", 1]])}
            ]);
            let madGremlin = () => new Enemy("Mad Gremlin", "n", 22, 23, [
                {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
            ], [
                {intent: "attacking 5", desc: "deal [DAM5] damage", effect: attack(5)}
            ], [
                {intent: "attacking 5", desc: "deal [DAM5] damage", effect: attack(5)}
            ], [], {"Angry": 1}, {"Angry": 2});
            let shieldGremlin = () => new Enemy("Shield Gremlin", "n", 13, 16, [
                {intent: "blocking", desc: "shield another enemy", effect: block_other(7)}
            ], [
                {intent: "blocking", desc: "shield another enemy", effect: block_other(8)}
            ], [
                {intent: "blocking", desc: "shield another enemy", effect: block_other(11)}
            ]);
            let sneakyGremlin = () => new Enemy("Sneaky Gremlin", "n", 12, 13, [
                {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)}
            ], [
                {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)}
            ], [
                {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)}
            ]);
            let gremlinWizard = () => new Enemy("Gremlin Wizard", "n", 24, 25, [
                {intent: "unknown", desc: "charge up a powerful attack", effect: passTurn()},
                {intent: "unknown", desc: "charge up a powerful attack", effect: passTurn()},
                {intent: "attacking 25", desc: "deal [DAM25] damage", effect: attack(25)}
            ], [
                {intent: "unknown", desc: "charge up a powerful attack", effect: passTurn()},
                {intent: "unknown", desc: "charge up a powerful attack", effect: passTurn()},
                {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
            ], [
                {intent: "unknown", desc: "charge up a powerful attack", effect: passTurn()},
                {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
            ]);
            let allGremlins = [fatGremlin, fatGremlin, sneakyGremlin, sneakyGremlin, madGremlin, madGremlin, shieldGremlin, gremlinWizard];
            
            let possibleElites = [
                () => new Enemy("Gremlin Nob", "e", 84, 88, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Enrage", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and apply a negative effect", effect: attack_apply(6, "Vulnerable", 1)}
                ], [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Enrage", 2)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Vulnerable", 1)}
                ], [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Enrage", 3)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Vulnerable", 1)}
                ], ["skip-first"]),
                () => new Enemy("Lagavulin", "e", 110, 114, [
                    {intent: "unknown", desc: "sleep", effect: passTurn()},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "meganerf", desc: "apply a powerful negative effect", effect: multi_apply([["Minus Strength", 1], ["Minus Dexterity", 1]])}
                ], [
                    {intent: "unknown", desc: "sleep", effect: passTurn()},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "meganerf", desc: "apply a powerful negative effect", effect: multi_apply([["Minus Strength", 1], ["Minus Dexterity", 1]])}
                ], [
                    {intent: "unknown", desc: "sleep", effect: passTurn()},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "meganerf", desc: "apply a powerful negative effect", effect: multi_apply([["Minus Strength", 2], ["Minus Dexterity", 2]])}
                ], ["skip-first"]),
                () => new Enemy("Sentry", "e", 40, 42, [
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
                ], [
                    {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
                ], [
                    {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 3)}
                ], [], {"Artifact": 1}, {"Artifact": 1})
            ];
            let possibleBosses = [
                () => new Enemy("Slime Boss", "b", 140, 150, [
                    {intent: "meganerf", desc: "generate many Status cards", effect: status("Slimed", 3)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: passTurn()},
                    {intent: "attacking 35", desc: "deal [DAM35] damage", effect: attack(35)}
                ], [
                    {intent: "meganerf", desc: "generate many Status cards", effect: status("Slimed", 3)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: passTurn()},
                    {intent: "attacking 38", desc: "deal [DAM38] damage", effect: attack(38)}
                ], [
                    {intent: "meganerf", desc: "generate many Status cards", effect: status("Slimed", 5)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: passTurn()},
                    {intent: "attacking 38", desc: "deal [DAM38] damage", effect: attack(38)}
                ], [], {"Split": 1}, {"Split": 1}),
                () => new Enemy("Hexaghost", "b", 250, 264, [
                    {intent: "unknown", desc: "prepare for a strong attack", effect: passTurn()},
                    {intent: "attacking hex", desc: "deal [HEX] damage", effect: function(me){me.dealDamage(6*(1+Math.floor(hp/12)))}},
                    {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and generate Status cards", effect: attack_status(6, "Burn", 1)},
                    {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(12, "Strength", 2)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and generate Status cards", effect: attack_status(6, "Burn", 1)},
                    {intent: "attack-nerf 12", desc: "deal [DAM12] damage and generate Status cards", effect: attack_status(12, "Burn+", 4)}
                ], [
                    {intent: "unknown", desc: "prepare for a strong attack", effect: passTurn()},
                    {intent: "attacking hex", desc: "deal [HEX] damage", effect: function(me){me.dealDamage(6*(1+Math.floor(hp/12)))}},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and generate Status cards", effect: attack_status(6, "Burn", 1)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(12, "Strength", 2)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and generate Status cards", effect: attack_status(6, "Burn", 1)},
                    {intent: "attack-nerf 18", desc: "deal [DAM18] damage and generate Status cards", effect: attack_status(18, "Burn+", 4)}
                ], [
                    {intent: "unknown", desc: "prepare for a strong attack", effect: passTurn()},
                    {intent: "attacking hex", desc: "deal [HEX] damage", effect: function(me){me.dealDamage(6*(1+Math.floor(hp/12)))}},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and generate Status cards", effect: attack_status(6, "Burn", 2)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(12, "Strength", 3)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and generate Status cards", effect: attack_status(6, "Burn", 2)},
                    {intent: "attack-nerf 18", desc: "deal [DAM18] damage and generate Status cards", effect: attack_status(18, "Burn+", 4)}
                ]),
                () => new Enemy("Guardian", "b", 240, 254, [
                    {intent: "unknown", desc: "charge up for an attack", effect: passTurn()},
                    {intent: "attacking 32", desc: "deal [DAM32] damage", effect: attack(32)},
                    {intent: "meganerf", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(20, "Thorns", 1)},
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)}
                ], [
                    {intent: "unknown", desc: "charge up for an attack", effect: passTurn()},
                    {intent: "attacking 32", desc: "deal [DAM32] damage", effect: attack(36)},
                    {intent: "meganerf", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(20, "Thorns", 1)},
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)}
                ], [
                    {intent: "unknown", desc: "charge up for an attack", effect: passTurn()},
                    {intent: "attacking 32", desc: "deal [DAM32] damage", effect: attack(36)},
                    {intent: "meganerf", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(20, "Thorns", 2)},
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)}
                ])
            ];
            
            let sphericGuardian = () => new Enemy("Spheric Guardian", "n", 20, 20, [
                {intent: "blocking", desc: "block", effect: block(25)},
                {intent: "attack-nerf 10", desc: "deal [DAM10] damage and apply a negative effect", effect: attack_apply(10, "Frail", 5)},
                {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 15)}
            ], [
                {intent: "blocking", desc: "block", effect: block(25)},
                {intent: "attack-nerf 11", desc: "deal [DAM11] damage and apply a negative effect", effect: attack_apply(11, "Frail", 5)},
                {intent: "attack-block 11", desc: "deal [DAM11] damage and block", effect: attack_block(11, 15)}
            ], [
                {intent: "blocking", desc: "block", effect: block(40)},
                {intent: "attack-nerf 11", desc: "deal [DAM11] damage and apply a negative effect", effect: attack_apply(11, "Frail", 5)},
                {intent: "attack-block 11", desc: "deal [DAM11] damage and block", effect: attack_block(11, 15)}
            ], ["no-repeat"], {"Barricade": 1, "Block": 40, "Artifact": 3}, {"Barricade": 1, "Block": 40, "Artifact": 3});
            let theChosen = () => new Enemy("The Chosen", "n", 97, 101, [
                {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                {intent: "meganerf", desc: "apply a powerful negative effect", effect: apply("Hex", 1)},
                {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                {intent: "attack-nerf 10", desc: "deal [DAM10] damage and apply a negative effect", effect: attack_apply(10, "Vulnerable", 2)}
            ], [
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "meganerf", desc: "apply a powerful negative effect", effect: apply("Hex", 1)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply a negative effect", effect: attack_apply(12, "Vulnerable", 2)}
            ], [
                {intent: "meganerf", desc: "apply a powerful negative effect", effect: apply("Hex", 1)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply a negative effect", effect: attack_apply(12, "Vulnerable", 2)}
            ]);
            let shelledParasite = () => new Enemy("Shelled Parasite", "n", 70, 73, [
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                {intent: "attacking 18", desc: "deal [DAM18] damage and apply a negative effect", effect: attack_apply(18, "Frail", 2)}
            ], [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attacking 21", desc: "deal [DAM21] damage and apply a negative effect", effect: attack_apply(21, "Frail", 2)}
            ], [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attacking 21", desc: "deal [DAM21] damage and apply a negative effect", effect: attack_apply(21, "Frail", 2)}
            ], ["randomize", "repeatable"], {"Plated Armor": 14}, {"Plated Armor": 14});
            let centurion = () => new Enemy("Centurion", "n", 78, 81, [
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                {intent: "blocking", desc: "shield another enemy", effect: block_other(15)}
            ], [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "blocking", desc: "shield another enemy", effect: block_other(15)}
            ], [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "blocking", desc: "shield another enemy", effect: block_other(20)}
            ], ["randomize"]);
            let mystic = () => new Enemy("Mystic", "n", 52, 54, [
                {intent: "buffing", desc: "buff ALL enemies", effect: function(me){for(let i of enemies){i.gainBuff("Strength", 2)}}},
                {intent: "buffing", desc: "heal ALL enemies", effect: function(me){for(let i of enemies){i.hp=Math.min(i.maxHp,i.hp+16)}}},
                {intent: "attack-nerf 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack_apply(8, "Frail", 2)}
            ], [
                {intent: "buffing", desc: "buff ALL enemies", effect: function(me){for(let i of enemies){i.gainBuff("Strength", 3)}}},
                {intent: "buffing", desc: "heal ALL enemies", effect: function(me){for(let i of enemies){i.hp=Math.min(i.maxHp,i.hp+16)}}},
                {intent: "attack-nerf 9", desc: "deal [DAM9] damage and apply a negative effect", effect: attack_apply(9, "Frail", 2)}
            ], [
                {intent: "buffing", desc: "buff ALL enemies", effect: function(me){for(let i of enemies){i.gainBuff("Strength", 4)}}},
                {intent: "buffing", desc: "heal ALL enemies", effect: function(me){for(let i of enemies){i.hp=Math.min(i.maxHp,i.hp+20)}}},
                {intent: "attack-nerf 9", desc: "deal [DAM9] damage and apply a negative effect", effect: attack_apply(9, "Frail", 2)}
            ], ["randomize"]);
            let snecko = () => new Enemy("Snecko", "n", 117, 123, [
                {intent: "meganerf", desc: "apply a negative(?) effect", effect: apply("Confused", 1)},
                {intent: "attack-nerf 8", desc: "deal [DAM8] damage & apply a negative effect", effect: attack_apply(8, "Vulnerable", 2)},
                {intent: "attacking 15", desc: "deal [DAM15] damage", effect: attack(15)}
            ], [
                {intent: "meganerf", desc: "apply a negative(?) effect", effect: apply("Confused", 1)},
                {intent: "attack-nerf 10", desc: "deal [DAM10] damage & apply a negative effect", effect: attack_apply(10, "Vulnerable", 2)},
                {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)}
            ], [
                {intent: "meganerf", desc: "apply a negative(?) effect", effect: apply("Confused", 1)},
                {intent: "attack-nerf 10", desc: "deal [DAM10] damage & apply a negative effect", effect: attack_multinerf(10, [["Vulnerable", 2], ["Weak", 2]])},
                {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)}
            ], ["skip-first"]);
            let byrd = () => new Enemy("Byrd", "n", 28, 30, [
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 5)},
                {intent: "attacking 5", desc: "deal [DAM5] damage", effect: attack(5)}
            ], [
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 6)},
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}
            ], [
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 6)},
                {intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}
            ], ["randomize"], {"Flight": 3}, {"Flight": 4});
            let snakePlant = () => new Enemy("Snake Plant", 77, 80, [
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "meganerf", desc: "apply negative effects", effect: multi_apply([["Frail", 2], ["Weak", 2]])}
            ], [
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(24)},
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(24)},
                {intent: "meganerf", desc: "apply negative effects", effect: multi_apply([["Frail", 2], ["Weak", 2]])}
            ], [
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "meganerf", desc: "apply negative effects", effect: multi_apply([["Frail", 2], ["Weak", 2]])}
            ], ["randomize"], {"Malleable": 3}, {"Malleable": 3});
            let reptoDagger = () => new Enemy("Dagger", "e", 23, 23,
                [{intent: "attack-nerf 9", desc: "deal [DAM9] damage and generate Status cards", effect: attack_status(9, "Wound", 1)}],
                [{intent: "attack-nerf 9", desc: "deal [DAM9] damage and generate Status cards", effect: attack_status(9, "Wound", 1)}],
                [{intent: "attack-nerf 9", desc: "deal [DAM9] damage and generate Status cards", effect: attack_status(9, "Wound", 1)}]
            );
            
            let possibleElites_act2 = [
                () => new Enemy("Book of Stabbing", "e", 161, 170, [
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "attack-buff 12", desc: "deal [DAM12] damage and gain a buff", effect: attack_buff(12, "Strength", 6)},
                    {intent: "attack-buff 12", desc: "deal [DAM12] damage and gain a buff", effect: attack_multibuff(12, [["Painful Stabs", 1], ["Strength", 6]])}
                ], [
                    {intent: "attacking 24", desc: "deal [DAM24] damage", effect: attack(24)},
                    {intent: "attack-buff 14", desc: "deal [DAM14] damage and gain a buff", effect: attack_buff(14, "Strength", 7)},
                    {intent: "attack-buff 14", desc: "deal [DAM14] damage and gain a buff", effect: attack_multibuff(14, [["Painful Stabs", 1], ["Strength", 7]])}
                ], [
                    {intent: "attack-buff 24", desc: "deal [DAM24] damage and gain a buff", effect: attack_buff(24, "Strength", 7)},
                    {intent: "attack-buff 14", desc: "deal [DAM14] damage and gain a buff", effect: attack_multibuff(14, [["Painful Stabs", 1], ["Strength", 7]])},
                    {intent: "attack-buff 14", desc: "deal [DAM14] damage and gain a buff", effect: attack_multibuff(14, [["Painful Stabs", 1], ["Strength", 7]])}
                ], ["randomize"], {"Painful Stabs": 1}, {"Painful Stabs": 1}),
                () => new Enemy("Gremlin Leader", "e", 144, 151, [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 3)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        enemies.unshift(choice(allGremlins)());
                        enemies.unshift(choice(allGremlins)());
                    }}
                ], [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 4)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        enemies.unshift(choice(allGremlins)()); enemies.unshift(choice(allGremlins)());
                    }}
                ], [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 5)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        enemies.unshift(choice(allGremlins)()); enemies.unshift(choice(allGremlins)());
                    }}
                ], ["randomize"]),
                () => new Enemy("Reptomancer", "e", 185, 195, [
                    {intent: "unknown", desc: "summon a dagger", effect: function(me){
                        enemies.unshift(reptoDagger());
                    }},
                    {intent: "attack-nerf 26", desc: "deal [DAM26] damage and apply a negative effect", effect: attack_apply(26, "Weak", 1)},
                    {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
                ], [
                    {intent: "unknown", desc: "summon a dagger", effect: function(me){
                        enemies.unshift(reptoDagger());
                    }},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Weak", 1)},
                    {intent: "attacking 34", desc: "deal [DAM34] damage", effect: attack(34)}
                ], [
                    {intent: "unknown", desc: "summon 2 daggers", effect: function(me){
                        enemies.unshift(reptoDagger()); enemies.unshift(reptoDagger());
                    }},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Weak", 1)},
                    {intent: "attacking 34", desc: "deal [DAM34] damage", effect: attack(34)}
                ])
            ];
            let possibleBosses_act2 = [
                () => new Enemy("The Champ", "b", 420, 440, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 2)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(15, "Metallicize", 4)},
                    {intent: "nerfing", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply negative effects", effect: attack_multinerf(12, [["Frail", 2], ["Vulnerable", 2]])},
                    {intent: "nerfing", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply negative effects", effect: attack_multinerf(12, [["Frail", 2], ["Vulnerable", 2]])},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)}
                ], [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 3)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(18, "Metallicize", 4)},
                    {intent: "nerfing", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "attack-nerf 14", desc: "deal [DAM14] damage and apply negative effects", effect: attack_multinerf(14, [["Frail", 2], ["Vulnerable", 2]])},
                    {intent: "nerfing", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "attack-nerf 14", desc: "deal [DAM14] damage and apply negative effects", effect: attack_multinerf(14, [["Frail", 2], ["Vulnerable", 2]])},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)}
                ], [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 4)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(20, "Metallicize", 5)},
                    {intent: "nerfing", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "attack-nerf 14", desc: "deal [DAM14] damage and apply negative effects", effect: attack_multinerf(14, [["Frail", 2], ["Vulnerable", 2]])},
                    {intent: "nerfing", desc: "apply negative effects", effect: multi_apply([["Vulnerable", 2], ["Weak", 2]])},
                    {intent: "attack-nerf 14", desc: "deal [DAM14] damage and apply negative effects", effect: attack_multinerf(14, [["Frail", 2], ["Vulnerable", 2]])},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)}
                ], ["randomize"]),
                () => new Enemy("Bronze Automaton", "b", 300, 320, [
                    {intent: "unknown", desc: "summon orbs", effect: function(me){
                        let orb = () => new Enemy("Bronze Orb", "b", 30, 30, [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], ["randomize"]);
                        enemies.unshift(orb()); enemies.unshift(orb());
                    }},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(9, "Strength", 3)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(9, "Strength", 3)},
                    {intent: "attacking 45", desc: "deal [DAM45] damage", effect: attack(45)},
                    {intent: "stunned", desc: "do nothing (stunned)", effect: passTurn()}
                ], [
                    {intent: "unknown", desc: "summon orbs", effect: function(me){
                        let orb = () => new Enemy("Bronze Orb", "b", 30, 30, [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], ["randomize"]);
                        enemies.unshift(orb()); enemies.unshift(orb());
                    }},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(9, "Strength", 4)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(9, "Strength", 4)},
                    {intent: "attacking 50", desc: "deal [DAM50] damage", effect: attack(50)},
                    {intent: "stunned", desc: "do nothing (stunned)", effect: passTurn()}
                ], [
                    {intent: "unknown", desc: "summon orbs", effect: function(me){
                        let orb = () => new Enemy("Bronze Orb", "b", 30, 30, [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], [
                            {intent: "blocking", desc: "shield another enemy", effect: block_other(12)},
                            {intent: "attacking 8", desc: "deal [DAM8] damage", effect: attack(8)}
                        ], ["randomize"]);
                        enemies.unshift(orb()); enemies.unshift(orb());
                    }},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(12, "Strength", 4)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(12, "Strength", 4)},
                    {intent: "attacking 50", desc: "deal [DAM50] damage", effect: attack(50)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(12, "Strength", 4)}
                ], ["skip-first"]),
                () => new Enemy("The Collector", 280, 300, [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                            let th = () => new Enemy("Torch Head", "b", 39, 43, [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}], [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}], [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}]); enemies.unshift(th()); enemies.unshift(th());
                    }},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "block-buff", desc: "block and buff ALL enemies", effect: function(me){me.gainBuff("Block", 15); for(let e of enemies) {e.gainBuff("Strength", 3);}}},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "meganerf", desc: "apply powerful negative effects", effect: multi_apply([["Weak", 3], ["Vulnerable", 3], ["Frail", 3]])}
                ], [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                            let th = () => new Enemy("Torch Head", "b", 39, 43, [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}], [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}], [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}]); enemies.unshift(th()); enemies.unshift(th());
                    }},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "block-buff", desc: "block and buff ALL enemies", effect: function(me){me.gainBuff("Block", 18); for(let e of enemies) {e.gainBuff("Strength", 4);}}},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "meganerf", desc: "apply powerful negative effects", effect: multi_apply([["Weak", 3], ["Vulnerable", 3], ["Frail", 3]])}
                ], [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                            let th = () => new Enemy("Torch Head", "b", 39, 43, [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}], [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}], [{intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)}]); enemies.unshift(th()); enemies.unshift(th());
                    }},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "block-buff", desc: "block and buff ALL enemies", effect: function(me){me.gainBuff("Block", 23); for(let e of enemies) {e.gainBuff("Strength", 5);}}},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "meganerf", desc: "apply powerful negative effects", effect: multi_apply([["Weak", 5], ["Vulnerable", 5], ["Frail", 5]])}
                ], ["skip-first"])
            ];
            
            let darkling = () => new Enemy("Darkling", "n", 78, 83, [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "blocking", desc: "block", effect: block(9)}
            ], [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "blocking", desc: "block", effect: block(9)}
            ], [
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                {intent: "blocking", desc: "block", effect: block(9)}
            ], ["randomize"], {"Lifelink": 1}, {"Lifelink": 1});
            let transient = () => new Enemy("Transient", "n", 999, 999, [
                {intent: "attack-buff 30", desc: "deal [DAM30] damage and gain a buff", effect: attack_buff(30, "Strength", 10)}
            ], [
                {intent: "attack-buff 40", desc: "deal [DAM40] damage and gain a buff", effect: attack_buff(40, "Strength", 10)}
            ], [
                {intent: "attack-buff 40", desc: "deal [DAM40] damage and gain a buff", effect: attack_buff(40, "Strength", 10)}
            ], [], {"Fading": 5, "Shifting": 1}, {"Fading": 6, "Shifting": 1});
            let spiker = () => new Enemy("Spiker", "n", 48, 51, [
                {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 2)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 2)}
            ], [
                {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 2)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 2)}
            ], [
                {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 2)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 2)}
            ], ["randomize"], {"Thorns": 3}, {"Thorns": 7});
            let repulsor = () => new Enemy("Repulsor", "n", 32, 35, [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
            ], [
                {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
            ], [
                {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)},
                {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
            ], ["randomize"]);
            let exploder = () => new Enemy("Exploder", "n", 30, 33, [
                {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
            ], [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
            ], [
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                {intent: "attacking 11", desc: "deal [DAM11] damage", effect: attack(11)},
                {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
            ], [], {"Fading": 3}, {"Fading": 3});
            let maw = () => new Enemy("The Maw", "n", 295, 305, [
                {intent: "meganerf", desc: "apply negative effects", effect: multinerf([["Weak", 3], ["Frail", 3]])},
                {intent: "attacking 25", desc: "deal [DAM25] damage", effect: attack(25)},
                {intent: "attacking maw", desc: "deal [MAW] damage", effect: attack(Math.ceil(turn/2) * 5)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 3)}
            ], [
                {intent: "meganerf", desc: "apply negative effects", effect: multinerf([["Weak", 3], ["Frail", 3]])},
                {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)},
                {intent: "attacking maw", desc: "deal [MAW] damage", effect: attack(Math.ceil(turn/2) * 5)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 3)}
            ], [
                {intent: "meganerf", desc: "apply negative effects", effect: multinerf([["Weak", 5], ["Frail", 5]])},
                {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)},
                {intent: "attacking maw", desc: "deal [MAW] damage", effect: attack(Math.ceil(turn/2) * 5)},
                {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 5)}
            ], ["skip-first"]);
            let orbWalker = () => new Enemy("Orb Walker", "n", 93, 97, [
                {intent: "attack-nerf 10", desc: "deal [DAM10] damage and generate Status cards", effect: attack_status(10, "Burn", 2)},
                {intent: "attacking 15", desc: "deal [DAM15] damage", effect: attack(15)}
            ], [
                {intent: "attack-nerf 11", desc: "deal [DAM11] damage and generate Status cards", effect: attack_status(11, "Burn", 2)},
                {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)}
            ], [
                {intent: "attack-nerf 11", desc: "deal [DAM11] damage and generate Status cards", effect: attack_status(11, "Burn", 2)},
                {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)}
            ], ["randomize", "repeatable"], {"Ritual": 3}, {"Ritual": 5});
            let spireGrowth = () => new Enemy("Spire Growth", "n", 170, 190, [
                {intent: "meganerf", desc: "apply a negative effect", effect: buff("Constricting", 10)},
                {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                {intent: "attacking 28", desc: "deal [DAM28] damage", effect: attack(28)}
            ], [
                {intent: "meganerf", desc: "apply a negative effect", effect: buff("Constricting", 10)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attacking 31", desc: "deal [DAM31] damage", effect: attack(31)}
            ], [
                {intent: "meganerf", desc: "apply a negative effect", effect: buff("Constricting", 14)},
                {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                {intent: "attacking 31", desc: "deal [DAM31] damage", effect: attack(31)}
            ], ["skip-first"]);
            let writhingMass = () => new Enemy("Writhing Mass", "n", 160, 175, [
                {intent: "unknown", desc: "permanently curse you", effect: function(me){deck.push(new Card("Parasite", 0, "Curse", "Unplayable.", function(){}, ["unplayable"]))}},
                {intent: "attack-block 15", desc: "deal [DAM15] damage and block", effect: attack_block(15, 15)},
                {intent: "attack-block 15", desc: "deal [DAM15] damage and block", effect: attack_block(15, 15)},
                {intent: "attack-nerf 10", desc: "deal [DAM10] damage and apply negative effects", effect: attack_multinerf(10, [["Weak", 2], ["Vulnerable", 2]])},
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                {intent: "attacking 32", desc: "deal [DAM32] damage", effect: attack(32)},
            ], [
                {intent: "unknown", desc: "permanently curse you", effect: function(me){deck.push(new Card("Parasite", 0, "Curse", "Unplayable.", function(){}, ["unplayable"]))}},
                {intent: "attack-block 17", desc: "deal [DAM17] damage and block", effect: attack_block(17, 17)},
                {intent: "attack-block 17", desc: "deal [DAM17] damage and block", effect: attack_block(17, 17)},
                {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply negative effects", effect: attack_multinerf(12, [["Weak", 2], ["Vulnerable", 2]])},
                {intent: "attacking 27", desc: "deal [DAM27] damage", effect: attack(27)},
                {intent: "attacking 27", desc: "deal [DAM27] damage", effect: attack(27)},
                {intent: "attacking 38", desc: "deal [DAM38] damage", effect: attack(38)},
            ], [
                {intent: "unknown", desc: "permanently curse you", effect: function(me){deck.push(new Card("Parasite", 0, "Curse", "Unplayable.", function(){}, ["unplayable"]))}},
                {intent: "attack-block 17", desc: "deal [DAM17] damage and block", effect: attack_block(17, 17)},
                {intent: "attack-block 17", desc: "deal [DAM17] damage and block", effect: attack_block(17, 17)},
                {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply negative effects", effect: attack_multinerf(12, [["Weak", 2], ["Vulnerable", 2]])},
                {intent: "attacking 27", desc: "deal [DAM27] damage", effect: attack(27)},
                {intent: "attacking 27", desc: "deal [DAM27] damage", effect: attack(27)},
                {intent: "attacking 38", desc: "deal [DAM38] damage", effect: attack(38)},
            ], ["randomize"], {"Reactive": 1, "Malleable": 3}, {"Reactive": 1, "Malleable": 3});
            
            let possibleElites_act3 = [
                () => new Enemy("Nemesis", "e", 185, 200, [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 3)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "attacking 18", desc: "deal [DAM18] damage", effect: attack(18)},
                    {intent: "attacking 45", desc: "deal [DAM45] damage", effect: attack(45)}
                ], [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 3)},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "attacking 45", desc: "deal [DAM45] damage", effect: attack(45)}
                ], [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 5)},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "attacking 45", desc: "deal [DAM45] damage", effect: attack(45)}
                ], ["randomize"], {"Phasing": 1}, {"Phasing": 1}),
                () => new Enemy("Giant Head", "e", 500, 520, [
                    {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attack-buff 30", desc: "deal [DAM30] damage and gain a buff", effect: attack_buff(30, "Strength", 5)}
                ], [
                    {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attack-buff 40", desc: "deal [DAM40] damage and gain a buff", effect: attack_buff(40, "Strength", 5)}
                ], [
                    {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attacking 13", desc: "deal [DAM13] damage", effect: attack(13)},
                    {intent: "attack-buff 40", desc: "deal [DAM40] damage and gain a buff", effect: attack_buff(40, "Strength", 5)}
                ], ["no-repeat"]),
                () => new Enemy("Taskmaster", "e", 57, 61, [
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and generate Status cards", effect: attack_status(7, "Wound", 1)}
                ], [
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and generate Status cards", effect: attack_status(7, "Wound", 2)}
                ], [
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and generate Status cards", effect: attack_status(7, "Wound", 3)}
                ])
            ];
            let possibleBosses_act3 = [
                () => new Enemy("Time Eater", "b", 456, 480, [
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(20, [["Vulnerable", 1], ["Weak", 1]])},
                    {intent: "attack-nerf 26", desc: "deal [DAM26] damage and apply a negative effect", effect: attack_apply(26, "Draw Reduction", 2)},
                    {intent: "attacking 21", desc: "deal [DAM21] damage", effect: attack(21)},
                    {intent: "attack-nerf 26", desc: "deal [DAM26] damage and apply a negative effect", effect: attack_apply(26, "Draw Reduction", 2)}
                ], [
                    {intent: "attacking 24", desc: "deal [DAM24] damage", effect: attack(24)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(20, [["Vulnerable", 1], ["Weak", 1]])},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 2)},
                    {intent: "attacking 24", desc: "deal [DAM24] damage", effect: attack(24)},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 2)}
                ], [
                    {intent: "attacking 24", desc: "deal [DAM24] damage", effect: attack(24)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(20, [["Vulnerable", 1], ["Weak", 1], ["Frail", 1]])},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 3)},
                    {intent: "attacking 24", desc: "deal [DAM24] damage", effect: attack(24)},
                    {intent: "attack-nerf 32", desc: "deal [DAM32] damage and apply a negative effect", effect: attack_apply(32, "Draw Reduction", 3)}
                ], ["randomize"], {"Healer": 1}, {"Healer": 1}),
                () => new Enemy("Donu", "b", 250, 265, [
                    {intent: "buffing", desc: "gain a buff", effect: all_buff("Strength", 6)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)}
                ], [
                    {intent: "buffing", desc: "gain a buff", effect: all_buff("Strength", 6)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(24)}
                ], [
                    {intent: "buffing", desc: "gain a buff", effect: all_buff("Strength", 6)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(24)}
                ], [], {"Artifact": 2}, {"Artifact": 3}),
                () => new Enemy("Awakened One", "b", 300, 320, [
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 24", desc: "deal [DAM24] damage", effect: attack(24)}
                ], [
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 24", desc: "deal [DAM24] damage", effect: attack(24)}
                ], [
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 20", desc: "deal [DAM20] damage", effect: attack(20)},
                    {intent: "attacking 24", desc: "deal [DAM24] damage", effect: attack(24)}
                ], ["randomize"], {"Unawakened": 1, "Regen": 10, "Curiosity": 1}, {"Unawakened": 1, "Regen": 15, "Curiosity": 2})
            ];
            let runBosses = [choice(possibleBosses)()];
            runBosses.push(choice(possibleBosses_act2)());
            runBosses.push(choice(possibleBosses_act3)());
            let easyPools = [
                ["The easier enemy pools, used for the first part of the Act."],
                [
                    [[cultist]],
                    [[jawWorm]],
                    [[rLouse, gLouse], [rLouse, gLouse]],
                    [[acidSlimeM, spikeSlimeM], [acidSlimeS, spikeSlimeS]]
                ],
                [
                    [[sphericGuardian]],
                    [[theChosen]],
                    [[shelledParasite]],
                    [[byrd], [byrd], [byrd]],
                    [[looter], [mugger]]
                ],
                [
                    [[orbWalker]],
                    [[darkling], [darkling]],
                    [[repulsor, spiker, exploder], [repulsor, spiker, exploder], [repulsor, spiker, exploder]]
                ]
            ];
            let hardPools = [
                ["The harder enemy pools, used for the later part of the Act."],
                [
                    [allGremlins, allGremlins, allGremlins, allGremlins]
                    [[acidSlimeL, spikeSlimeL]],
                    [[acidSlimeS, spikeSlimeS], [acidSlimeS, spikeSlimeS], [acidSlimeS, spikeSlimeS], [acidSlimeS, spikeSlimeS], [acidSlimeS, spikeSlimeS]],
                    [[bSlaver]], [[rSlaver]],
                    [[rLouse, gLouse], [rLouse, gLouse], [rLouse, gLouse]],
                    [[fungiBeast], [fungiBeast]],
                    [[rLouse, gLouse, acidSlimeM, spikeSlimeM], [looter, cultist, rSlaver, bSlaver]],
                    [[rLouse, gLouse, acidSlimeM, spikeSlimeM], [fungiBeast, jawWorm]],
                    [[looter]]
                ],
                [
                    [[theChosen], [byrd]],
                    [[cultist], [theChosen]],
                    [[() => new Enemy("Sentry", "e", 40, 42, [{intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)}, {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}], [{intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)}, {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}], [{intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)}, {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 3)}], [], {"Artifact": 1}, {"Artifact": 1})], [sphericGuardian]],
                    [[snakePlant]],
                    [[snecko]],
                    [[centurion], [mystic]],
                    [[cultist], [cultist], [cultist]],
                    [[shelledParasite], [fungiBeast]]
                ],
                [
                    [[repulsor, spiker, exploder], [repulsor, spiker, exploder], [repulsor, spiker, exploder] [repulsor, spiker, exploder]],
                    [[maw]],
                    [[sphericGuardian], [repulsor, spiker, exploder], [repulsor, spiker, exploder]],
                    [[darkling], [darkling], [darkling]],
                    [[writhingMass]],
                    [[hardJawWorm], [hardJawWorm], [hardJawWorm]],
                    [[spireGrowth]],
                    [[transient]]
                ]
            ];
            
            let enemies = [];
            let eliteBattle = false;
            let bossBattle = false;
            let target;
            
            let potionDrop;
            function getPotion() {potions.push(potionDrop);}
            
            let timerRunning = false;
            let currentTimer = 0;
            let hasPaused = false;
            let beforeTime = Date.now();
            
            function updateStatLine() {
                //alert("Updating Stat Line");
                let statusElemB4 = getId("statusLineB4");
                let deckNumber = getId("deckSize");
                let statusElem = getId("statusLine");
                if(gold < 0) gold = 0;
                statusElemB4.innerHTML=(hp<=0.25*maxHp ? "<span style='color: red'>HP: "+hp+"/"+maxHp+"</span>" : "HP: "+hp+"/"+maxHp);
                statusElemB4.innerHTML+=" | "+gold+" gold | Act "+"I".repeat(actNum)+", Floor "+mapY+", Asc "+getId("ascensionLevel").value;
                deckNumber.innerHTML=deck.length;
                statusElem.innerHTML="<span id='relics'><b>Relics: </b></span>";
                for(let relic of relics) {
                    let relicElem = document.createElement("span");
                    relicElem.setAttribute("class", "tt");
                    relicElem.innerHTML = " | "+relic.name;
                    let relicTooltip = document.createElement("span");
                    relicTooltip.setAttribute("class", "txt");
                    relicTooltip.innerHTML = relic.desc;
                    relicElem.appendChild(relicTooltip);
                    getId("relics").appendChild(relicElem);
                }
                //alert("Relics done");
                statusElem.innerHTML+= "<br/><br/><span id='potions'><b>Potions: </b></span>";
                for(let potion of potions) {
                    let potionElem = document.createElement("button");
                    potionElem.setAttribute("class", "tt");
                    potionElem.setAttribute("onclick", `let x = function(tgt){${potion.effect}}; if(getId("gameScreen").style.display != "none" || ${(["Fruit Juice", "Blood"].includes(potion.name) ? "true" : "false")}) {x(target); ifRelic("Sacred Bark", function(){x(target);});} potions.splice(${potions.indexOf(potion)}, 1); ifRelic("Toy Ornithopter", function(){hp = Math.min(maxHp, hp + 5)}); if(getId("gameScreen").style.display != "none"){updateHtml();}`);
                    potionElem.innerHTML = potion.name+" Potion";
                    let potionTooltip = document.createElement("span");
                    potionTooltip.setAttribute("class", "txt");
                    potionTooltip.innerHTML = potion.desc;
                    potionElem.appendChild(potionTooltip);
                    getId("potions").appendChild(potionElem);
                }
                for(let i=0; i<((getId("ascensionLevel").value >= 11 ? 2 : 3)-potions.length); i++) {
                    let potionElem = document.createElement("button");
                    potionElem.classList.add("nonbutton");
                    potionElem.innerHTML = "Empty Slot";
                    getId("potions").appendChild(potionElem);
                }
                //alert("Potions done");
                if(timerRunning) {/*alert("Timer is running"); */currentTimer += Date.now() - beforeTime;}
                //alert("Timer increment done");
                beforeTime = Date.now();
                //alert("Before Time done");
                let min = Math.floor(currentTimer/6e4).toString();
                let sec = Math.floor(currentTimer%6e4/1e3).toString();
                let sec_100ths = Math.floor(currentTimer%1e3/10).toString();
                statusElem.innerHTML += "&nbsp;&nbsp;&nbsp;<button id=\"timer\" class=\""+(timerRunning?"Skill":"Attack")+"\" onclick=\"if(timerRunning){timerRunning=false;hasPaused=true;getId('timer').setAttribute('class','Attack');updateStatLine();}else{timerRunning=true;getId('timer').setAttribute('class','Skill');updateStatLine();}\"><span style='text-decoration:underline'>T</span>ime: "+min+":"+sec.padStart(2, "0")+"."+sec_100ths.padStart(2, "0")+"</button>"+(hasPaused ? " (paused)" : "");
                //alert("Timer done");
                getId("drawPile").innerHTML = "View Draw <span style='text-decoration:underline'>P</span>ile | <span style='color:white'>"+drawPile.length+"</span>";
                getId("discardPile").innerHTML = "View D<span style='text-decoration:underline'>i</span>scard Pile | <span style='color:white'>"+discardPile.length+"</span>";
                getId("exhaustPile").innerHTML = "View E<span style='text-decoration:underline'>x</span>haust Pile | <span style='color:white'>"+exhaustPile.length+"</span>";
                //alert("Finished!");
            }
            
            function updateHtml() {
                timerRunning = true;
                updateStatLine();
                if(hasBuff("Strength") && hasBuff("Minus Strength")) {
                    if(hasBuff("Strength") >= hasBuff("Minus Strength")) {
                        loseBuff("Strength", hasBuff("Minus Strength"));
                        loseBuff("Minus Strength");
                    } else {
                        loseBuff("Minus Strength", hasBuff("Strength"));
                        loseBuff("Strength");
                    }
                }
                if(hasBuff("Dexterity") && hasBuff("Minus Dexterity")) {
                    if(hasBuff("Dexterity") >= hasBuff("Minus Dexterity")) {
                        loseBuff("Dexterity", hasBuff("Minus Dexterity"));
                        loseBuff("Minus Dexterity");
                    } else {
                        loseBuff("Minus Dexterity", hasBuff("Dexterity"));
                        loseBuff("Dexterity");
                    }
                }
                let energyElem = getId("energy");
                energyElem.innerHTML = energy+"/"+maxEnergy+"<span class='txt'>Energy is used to play cards from your hand.</span>";
                if(energy == 0) {energyElem.style.background = "#884";}
                else {energyElem.style.background = "yellow";}
                
                let playerElem = getId("player");
                playerElem.innerHTML = "<span style='font-size:28px;opacity:0;'>0</span>Your Hand ("+hand.length+"/10 cards):";
                if(buffs.length) {
                    playerElem.innerHTML += " |";
                    for(let x of buffs) {
                        let buffStuff = "";
                        if(["Block", "Vulnerable", "Weak", "Strength", "Dexterity", "Strength Down", "No Draw", "Combust", "Dark Embrace", "Thorns", "Ritual", "Frail", "Minus Strength", "Minus Dexterity", "Evolve", "Pen Nib", "Feel No Pain", "Fire Breathing", "Metallicize", "Rage", "Rampage", "Barricade", "Berserk", "Brutality", "Double Tap", "Juggernaut", "Regen", "Dexterity Down", "Artifact", "Hex", "Draw Reduction", "Buffer", "Next Turn Block", "Vigor", "Next Turn Energy", "Poison", "Accuracy", "Blur", "Infinite Blades", "Noxious Fumes", "Next Turn Cards", "Enrage", "Tools of the Trade", "After Image", "Envenom", "Burst", "Thousand Cuts", "Corruption", "Confused", "Calm", "Wrath", "Divinity", "Mark", "Precision", "Battle Hymn", "Fasting", "Collect", "Mantra", "Foresight", "Like Water", "Mental Fortress", "Nirvana", "Rushdown", "Study", "Deva Form", "Establishment", "Simmering Fury", "Swivel", "Wave of the Hand", "Vault", "Blasphemy", "Omega", "Intangible", "Plated Armor"].includes(x.name)) {
                            buffStuff += "<img src='StS/"+x.name.toLowerCase().replaceAll(" ","_")+".png'>";
                        } else {
                            buffStuff += x.name+" ";
                        }
                        let adjustedDamage = function(n) {
                            let newI = calcYourDamage(target, n);
                            if(newI > n) {return "<span style='color:lime'>"+newI+"</span>";}
                            else if(newI < n) {return "<span style='color:#f00'>"+newI+"</span>";}
                            else {return newI;}
                        }
                        let adjustedBlock = function(n) {
                            let blockI = calcYourBlock(n);
                            if(blockI > n) {return "<span style='color:lime'>"+blockI+"</span>";}
                            else if(blockI < n) {return "<span style='color:#f00'>"+blockI+"</span>";}
                            else {return blockI;}
                        }
                        if(["No Draw", "Barricade", "Confused", "Corruption", "Calm", "Wrath", "Divinity", "Simmering Fury", "Blasphemy"].includes(x.name)) {
                            playerElem.innerHTML += "<span class='tt'>"+buffStuff+(x.name.includes("Minus")?"-":"")+"<span class='txt'>"+x.name+": "+buffDesc[x.name]
                                .replaceAll("[DAMT]", adjustedDamage(x.amt))
                                .replaceAll("[BAMT]", adjustedBlock(x.amt))
                                .replaceAll("[AMT]", x.amt)
                                .replaceAll("[PREC]", Math.floor(target.hasBuff("Mark") * x.amt / 5))
                                .replaceAll("[s]", (x.amt==1 ? "" : "s"))
                                .replaceAll("[es]", (x.amt==1 ? "" : "es"))
                                .replaceAll("[are]", (x.amt==1 ? "is" : "are"))
                                    +"</span></span> ";
                        } else {
                            playerElem.innerHTML += "<span class='tt'>"+buffStuff+(x.name.includes("Minus")?"-":"")+x.amt+"<span class='txt'>"+x.name+": "+buffDesc[x.name]
                                .replaceAll("[DAMT]", adjustedDamage(x.amt))
                                .replaceAll("[BAMT]", adjustedBlock(x.amt))
                                .replaceAll("[AMT]", x.amt)
                                .replaceAll("[PREC]", Math.floor(target.hasBuff("Mark") * x.amt / 5))
                                .replaceAll("[s]", (x.amt==1 ? "" : "s"))
                                .replaceAll("[es]", (x.amt==1 ? "" : "es"))
                                .replaceAll("[are]", (x.amt==1 ? "is" : "are"))
                                    +"</span></span> ";
                        }
                    }
                }
                let handElem = getId("hand");
                handElem.innerHTML = "";
                for(let c of hand) {
                    let cardElem = document.createElement("button");
                    let playcard = () => { c.play(); }
                    cardElem.onclick = playcard;
                    if(
                        c.flags.includes("unplayable") ||
                        energy < c.cost ||
                        (c.name.includes("Signature Move") && hand.filter(x=>x.type=="Attack"&&!x.name.includes("Signature Move")).length) ||
                        (c.name.includes("Clash") && hand.map(x=>x.type=="Attack").includes(false))
                    ){cardElem.setAttribute("class", "tt unplayable "+c.type);}
                    else {cardElem.setAttribute("class", "tt "+c.type);}
                    cardElem.innerHTML = makeTooltip(c);
                    handElem.appendChild(cardElem);
                    
                    let helpNumber = document.createElement("span");
                    helpNumber.style.position = "absolute";
                    let coords = cardElem.getBoundingClientRect()
                    helpNumber.style.top = coords.bottom;
                    helpNumber.style.left = coords.left + 0.5 * (coords.right - coords.left) - 5;
                    let ind = hand.indexOf(c) + 1;
                    helpNumber.innerHTML = (ind > 10 ? "" : (ind == 10 ? "0" : ind));
                    handElem.appendChild(helpNumber);
                }
                
                let enemiesElem = getId("enemies");
                enemiesElem.innerHTML = "";
                for(let eIndex in enemies) {
                    let e = enemies[eIndex];
                    if(e.hasBuff("Strength") && e.hasBuff("Minus Strength")) {
                        if(e.hasBuff("Strength") >= e.hasBuff("Minus Strength")) {
                            e.loseBuff("Strength", e.hasBuff("Minus Strength"));
                            e.loseBuff("Minus Strength");
                        } else {
                            e.loseBuff("Minus Strength", e.hasBuff("Strength"));
                            e.loseBuff("Strength");
                        }
                    }
                    let enemyElem = document.createElement("span");
                    enemyElem.setAttribute("class", "tt");
                    let enemyButton = document.createElement("button");
                    enemyButton.setAttribute("id", "enemy_"+eIndex);
                    enemyButton.setAttribute("onclick", `target = enemies[${eIndex}]; updateHtml();`);
                    let intentType = e.intent.intent.split(" ")[0];
                    let intentNumber = "";
                    if(e.intent.intent.split(" ")[1]) {
                        if(parseInt(e.intent.intent.split(" ")[1])) {
                            intentNumber = parseInt(e.intent.intent.split(" ")[1]);
                            intentNumber = e.calcDamage(intentNumber);
                            if(intentNumber >= 20 && e.intent.intent.includes("attacking")) {
                                intentType = "bigattack";
                            }
                        } else if(e.intent.intent.split(" ")[1] == "hex") {
                            intentNumber = e.calcDamage(6*(1+Math.floor(hp/12)));
                            if(intentNumber >= 20 && e.intent.intent.includes("attacking")) {
                                intentType = "bigattack";
                            }
                        } else if(e.intent.intent.split(" ")[1] == "maw") {
                            intentNumber = e.calcDamage(Math.ceil(turn/2) * 5);
                            if(intentNumber >= 20 && e.intent.intent.includes("attacking")) {
                                intentType = "bigattack";
                            }
                        } else {
                            intentNumber = e.intent.intent.split(" ")[1];
                        }
                    }
                    if((e.hasBuff("Split") && e.hp <= 0.5 * e.maxHp) || (e.name == "Time Eater" && e.hp < 0.5 * e.maxHp)) {
                        intentType = "unknown";
                        intentNumber = "";
                    }
                    if(e.hasBuff("Stunned")) {
                        intentType = "stunned";
                        intentNumber = "";
                    }
                    if(relics.map(x=>x.name).includes("Runic Dome")) {
                        if(e.number == target.number) {
                            enemyButton.removeAttribute("class");
                        } else {
                            enemyButton.setAttribute("class", " nonbutton");
                        }
                        enemyButton.innerHTML = e.name;
                    } else {
                        if(e.number == target.number) {
                            enemyButton.setAttribute("class", intentType);
                        } else {
                            enemyButton.setAttribute("class", intentType+" nonbutton");
                        }
                        enemyButton.innerHTML = "<span style='color:white'>"+intentNumber+"</span>&nbsp;"+e.name;
                    }
                    enemyElem.appendChild(enemyButton);
                    enemyElem.innerHTML += " HP:<span"+(e.hasBuff("Poison") >= e.hp ? " style='color: lime'" : "")+">"+(e.hasBuff("Block") ? "<span style='color: black; background-image: url(StS/block"+"_".repeat(Math.min(2, e.hasBuff("Block").toString().length))+".png); display: inline-block; height: 17px;'>&nbsp;"+(e.hasBuff("Block"))+"&nbsp;</span>&nbsp;"+e.hp : " "+e.hp)+" / "+e.maxHp+"</span>";
                    if(e.buffs.filter(x=>x.name!="Block").length) {
                        enemyElem.innerHTML += " |";
                        for(let x of e.buffs.filter(x=>x.name!="Block")) {
                            let buffStuff = "";
                            if(["Block", "Vulnerable", "Weak", "Strength", "Dexterity", "Thorns", "Ritual", "Frail", "Minus Strength", "Minus Dexterity", "Metallicize", "Regen", "Dexterity Down", "Artifact", "Buffer", "Poison", "Enrage", "Mark", "Talk to the Hand", "Barricade", "Flight", "Time Warp", "Angry", "Plated Armor", "Curl Up", "Stunned", "Lifelink", "Painful Stabs", "Shifting", "Fading", "Strength Up", "Malleable", "Constricting", "Reactive", "Thievery", "Spore Cloud", "Slow", "Healer", "Unawakened", "Stunned", "Split", "Phasing"].includes(x.name)) {
                                buffStuff += "<img src='StS/"+x.name.toLowerCase().replaceAll(" ","_")+".png'>";
                            } else {
                                buffStuff += x.name+" ";
                            }
                            let adjustedDamage = function(n) {
                                let newI = e.calcDamage(n);
                                if(newI > n) {return "<span style='color:lime'>"+newI+"</span>";}
                                else if(newI < n) {return "<span style='color:#f00'>"+newI+"</span>";}
                                else {return newI;}
                            }
                            let adjustedBlock = function(n) {
                                let blockI = e.calcBlock(n);
                                if(blockI > n) {return "<span style='color:lime'>"+blockI+"</span>";}
                                else if(blockI < n) {return "<span style='color:#f00'>"+blockI+"</span>";}
                                else {return blockI;}
                            }
                            enemyElem.innerHTML += "<span class='tt'>"+buffStuff+(x.name.includes("Minus")?"-":"")+(["Barricade", "Split", "Lifelink", "Shifting", "Reactive"].includes(x.name)?"":x.amt)+"<span class='txt'>"+buffDesc[x.name].replace("[DAMT]", adjustedDamage(x.amt)).replace("[BAMT]", adjustedBlock(x.amt)).replace("[AMT]", x.amt).replaceAll("[PREC]", Math.floor(target.hasBuff("Mark") * x.amt / 5)).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es")).replaceAll("[are]", (x.amt==1 ? "is" : "are"))+"</span></span> ";
                        }
                        if(e.hasBuff("Time Warp") == 0 && e.name == "Time Eater") {
                            enemyElem.innerHTML += "<span class='tt'><img src='StS/time_warp.png'><span class='txt'>Time Warp: Whenever you play 12 cards, ends your turn and gains 2 Strength.</span></span> ";
                        }
                        if(e.hasBuff("Slow") == 0 && e.name == "Giant Head") {
                            enemyElem.innerHTML += "<br/>Slow (Whenever you play a card, takes 10% more damage this turn.)";
                        }
                    }
                    let enemyTooltip = document.createElement("span");
                    enemyTooltip.setAttribute("class", "txt");
                    let newDesc = e.intent.desc
                        .replace("[HEX]", "[DAM"+(6*(1+Math.floor(hp/12)))+"]")
                        .replace("[MAW]", "[DAM"+(Math.ceil(turn/2) * 5)+"]");
                    if((e.hasBuff("Split") && e.hp <= 0.5 * e.maxHp) || (e.name == "Time Eater" && e.hp < 0.5 * e.maxHp)) {
                        newDesc = "use a special ability";
                    }
                    for(let i=0; i<300; i++) {
                        let newI = e.calcDamage(i);
                        if(newI > i) {newI = "<span style='color:lime'>"+newI+"</span>";}
                        else if(newI < i) {newI = "<span style='color:#f00'>"+newI+"</span>";}
                        newDesc = newDesc.replace("[DAM"+i+"]", newI);
                    }
                    if(relics.map(x=>x.name).includes("Runic Dome")) {
                        enemyTooltip.innerHTML = "";
                    } else {
                        enemyTooltip.innerHTML = e.name+" intends to "+newDesc+".";
                    }
                    enemyTooltip.innerHTML += e.buffs.length ? ("<br/>" + e.buffs.map(x => x.name+" "+x.amt+" ("+buffDesc[x.name].replace("[AMT]", x.amt).replace("[DAMT]", e.calcDamage(x.amt)).replace("[BAMT]", e.calcBlock(x.amt)).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es")).replaceAll("[are]", (x.amt==1 ? "is" : "are"))+")").join("<br/>")) : "";
                    if(e.hasBuff("Time Warp") == 0 && e.name == "Time Eater") {
                        enemyTooltip.innerHTML += "<br/>Time Warp (Whenever you play 12 cards, ends your turn and gains 2 Strength.)";
                    }
                    if(e.hasBuff("Slow") == 0 && e.name == "Giant Head") {
                        enemyTooltip.innerHTML += "<br/>Slow (Whenever you play a card, takes 10% more damage this turn.)";
                    }
                    enemyElem.appendChild(enemyTooltip);
                    enemiesElem.appendChild(enemyElem);
                    enemiesElem.appendChild(document.createElement("br"));
                }
                if(enemies.filter(x => x.hp <= 0).length > 0) {
                    if(enemies.filter(x => x.hp <= 0 && x.hasBuff("Unawakened")).length) {
                        let awakened = enemies.filter(x=>x.hasBuff("Unawakened"))[0];
                        awakened.hp = awakened.maxHp;
                        awakened.gainBuff("Stunned", 1);
                        awakened.clearDebuffs();
                        awakened.loseBuff("Curiosity");
                        awakened.loseBuff("Unawakened");
                    }
                    let livingEnemies = enemies.filter(x => x.hp > 0);
                    let numDead = enemies.length - livingEnemies.length;
                    ifRelic("Gremlin Horn", function(){energy += numDead; drawCard(numDead);});
                    gainBuff("Vulnerable", enemies.filter(x=>!livingEnemies.includes(x)).map(x=>x.hasBuff("Spore Cloud")).reduce((ps, a) => ps + a, 0));
                    loseBuff(".");
                    enemies = livingEnemies;
                    for(let i of enemies) {
                        i.hp = Math.max(0, i.hp);
                    }
                    updateHtml();
                }
                if(!enemies.includes(target) || !target) {target = enemies[0];}
                if(enemies.length == 0 || enemies.filter(x=>x.name=="Darkling"&&x.hp==1).length == enemies.length) {
                    music.boss1.pause(); music.boss2.pause(); music.boss3.pause();
                    music.boss1.currentTime = 0; music.boss2.currentTime = 0; music.boss3.currentTime = 0;
                    if(bossBattle) {music.bossDead.play();}
                    else {
                        for(let i=0; i<50; i++) {
                            setTimeout(function(){music.enemy.volume -= 0.01; music.elite.volume -= 0.01;}, i*50);
                        }
                        setTimeout(function(){
                            music.enemy.pause(); music.elite.pause();
                            music.enemy.currentTime = 0; music.elite.currentTime = 0;
                            music.enemy.volume = 0.5; music.elite.volume = 0.5;
                        }, 2000);
                    }
                    buffs = [];
                    ifRelic("Meat on the Bone", function(){hp = Math.min(Math.round(0.5*maxHp), hp + 12)});
                    ifRelic("Burning Blood", function(){hp = Math.min(maxHp, hp + 6);});
                    getId("rewardsScreen").style.display = "block";
                    getId("goldReward").style.display = "block";
                    getId("cardReward").style.display = "block";
                    getId("gameScreen").style.display = "none";
                    let goldAmt = Math.round(Math.random()*10) + (getId("ascensionLevel").value >= 13 ? 19 : 25);
                    if(bossBattle) goldAmt = Math.round(Math.random()*10) + (getId("ascensionLevel").value >= 13 ? 76 : 100);
                    if(relics.map(x=>x.name).includes("Ectoplasm")) goldAmt = 0;
                    getId("goldReward").innerHTML = goldAmt+" gold";
                    getId("goldReward").setAttribute("onclick", `gold += ${goldAmt}; updateStatLine(); getId('goldReward').style.display = 'none';`);
                    if((Math.random() < 0.5 || relics.map(x=>x.name).includes("White Beast Statue"))
                       && !relics.map(x=>x.name).includes("Sozu")) {
                        getId("potionReward").style.display = "block";
                        potionDrop = choice(potionPool);
                        getId("potionReward").innerHTML = potionDrop.name+" Potion";
                        getId("potionReward").setAttribute("onclick", `if(potions.length < (getId("ascensionLevel").value >= 11 ? 2 : 3)){getPotion(); updateStatLine(); getId('potionReward').style.display = 'none';}`);
                    } else {
                        getId("potionReward").style.display = "none";
                    }
                    if(eliteBattle && !relics.map(x=>x.name).includes("N’loth’s Hungry Face")) {
                        getId("relicReward").style.display = "block";
                        let newRelic = choice(choice(relicPool), choice(relicPool), choice(rareRelicPool));
                        getId("relicReward").innerHTML = newRelic.name+"<span class='txt'>"+newRelic.desc+"</span>";
                        getId("relicReward").setAttribute("onclick", `
let r = ${JSON.stringify(newRelic)};
relics.push(r);
if(r.name == 'Strawberry'){maxHp += 7; hp += 7;}
if(r.name == 'Pear'){maxHp += 10; hp += 10;}
if(r.name == 'Mango'){maxHp += 14; hp += 14;}
if(r.name == 'Old Coin'){gold += 300;}
updateStatLine();
getId('relicReward').style.display = 'none';
                        `);
                    } else {
                        getId("relicReward").style.display = "none";
                        if(eliteBattle) {
                            relics = relics.filter(x=>x.name!="N’loth’s Hungry Face");
                        }
                    }
                    if(bossBattle) {
                        ifRelic("Cursed Key", function(){
                            deck.push(new Card("Curse of the Key", 0, "Curse", "Unplayable.", function(){}, ["unplayable"]));
                        });
                        getId("bossRelicReward").style.display = "block";
                        getId("bossRelicReward").innerHTML = "Choose a Relic";
                        getId("bossRelicReward").setAttribute("onclick", "addBossRelic(); getId('bossRelicReward').style.display = 'none';");
                    } else {
                        getId("bossRelicReward").style.display = "none";
                    }
                    ifRelic("Face of Cleric", function(){maxHp += 1; hp += 1;});
                }
                if(hp <= 0) {
                    hp = 0;
                    alert("You died! D:\nRestarting game...");
                    getId("gameScreen").style.display = "none";
                    music.enemy.pause(); music.elite.pause(); music.boss1.pause(); music.boss2.pause(); music.boss3.pause();
                    music.enemy.currentTime = 0; music.elite.currentTime = 0;
                    music.boss1.currentTime = 0; music.boss2.currentTime = 0; music.boss3.currentTime = 0;
                    music.death.play();
                    timerRunning = false; updateStatLine();
                    resetGame();
                }
                let x = document.getElementsByClassName("txt");
                for (t of x) {
                    t.style.left = (mousex+10) + "px";
                    t.style.top = (mousey+10+window.pageYOffset) + "px";
                }
            }
            
            function addShivs(num=1) {
                for(let i=0; i<num; i++) {
                    if(hand.length < 10) {
                        hand.push(new Card("Shiv", 0, "Attack", "Deal [SHIV] damage. Exhaust.", function(e){dealDamage(e,4,true);}, ["exhausted"]));
                    } else {
                        discardPile.push(new Card("Shiv", 0, "Attack", "Deal [SHIV] damage. Exhaust.", function(e){dealDamage(e,4,true);}, ["exhausted"]));
                    }
                }
            }
            function addShivPluses(num=1) {
                for(let i=0; i<num; i++) {
                    if(hand.length < 10) {
                        hand.push(new Card("Shiv+", 0, "Attack", "Deal [SHIV+] damage. Exhaust.", function(e){dealDamage(e,6,true);}, ["exhausted"]));
                    } else {
                        discardPile.push(new Card("Shiv+", 0, "Attack", "Deal [SHIV+] damage. Exhaust.", function(e){dealDamage(e,6,true);}, ["exhausted"]));

                    }
                }
            }
            function addSmites(num=1) {
                for(let i=0; i<num; i++) {
                    if(hand.length < 10) {
                        hand.push(new Card("Smite", 1, "Attack", "Deal [DAM12] damage. Exhaust.", function(e){dealDamage(e,12);}, ["exhausted", "retain"]));
                    } else {
                        discardPile.push(new Card("Smite", 1, "Attack", "Deal [DAM12] damage. Exhaust.", function(e){dealDamage(e,12);}, ["exhausted", "retain"]));
                    }
                }
            }
            function addInsights(num=1) {
                for(let i=0; i<num; i++) {
                    drawPile.push(new Card("Insight", 0, "Skill", "Draw 2 cards. Exhaust.", function(enemy){drawCard(2);}, ["exhausted"]));
                }
                drawPile = shuffle(drawPile);
            }
            
            function drawCard(num=1) {
                if(hasBuff("No Draw") > 0) {num=0;}
                for(let x=0; x<num; x++) {
                    if(drawPile.length <= 0) {
                        ifRelic("Ball Bearing", function(){
                            discardPile.push(new Card("Flash of Steel", 0, "Attack", "Deal [DAM3] damage. Draw a card", function(e){
                                dealDamage(e, 3); drawCard();
                            }));
                        });
                        drawPile = shuffle(discardPile);
                        discardPile = [];
                        ifRelic("Sundial", function(){energy += 1});
                    }
                    if(drawPile.length > 0 && hand.length < 10) {
                        let toDraw = drawPile.pop(0);
                        if(hasBuff("Confused")) {
                            toDraw.flags.push("nextcost "+toDraw.cost);
                            toDraw.cost = Math.floor(Math.random()*4);
                        }
                        hand.push(toDraw);
                        if(toDraw.type == "Status") {
                            drawCard(hasBuff("Evolve"));
                            for(let e of enemies) {
                                dealDamage(e, hasBuff("Fire Breathing"));
                            }
                        }
                        if(toDraw.name == "Doubt") gainBuff("Frail", 1);
                        if(toDraw.name == "Shame") gainBuff("Weak", 1);
                    }
                }
            }
            
            async function startTurn() {
                /*debugging*/ try {
                if(hasBuff("Blasphemy")) hp = 0;
                if(turn == 0) {
                    ifRelic("Snake Ring", function(){drawCard(2)});
                    ifRelic("Akabeko", function(){gainBuff("Vigor", 8)});
                    ifRelic("Bag of Marbles", function(){for(let e of enemies) {e.gainBuff("Vulnerable", 1)}});
                    ifRelic("Red Mask", function(){for(let e of enemies) {e.gainBuff("Weak", 1)}});
                    ifRelic("Blood Vial", function(){hp = Math.min(maxHp, hp + 2)});
                    ifRelic("Bronze Scales", function(){gainBuff("Thorns", 3)});
                    ifRelic("Oddly Smooth Stone", function(){gainBuff("Dexterity", 1)});
                    ifRelic("Preserved Insect", function(){if(eliteBattle){for(let e of enemies){e.hp = Math.round(0.75 * e.maxHp)}}});
                    ifRelic("Vajra", function(){gainBuff("Strength", 1)});
                    ifRelic("Ninja Scroll", function(){addShivs(3)});
                    ifRelic("Fossilized Helix", function(){gainBuff("Buffer", 1)});
                    ifRelic("Thread and Needle", function(){gainBuff("Plated Armor", 4)});
                    ifRelic("Teardrop Locket", function(){gainBuff("Calm", 1);});
                    ifRelic("Gremlin Visage", function(){gainBuff("Weak", 1);});
                    ifRelic("Mutagenic Strength", function(){gainBuff("Strength", 3); gainBuff("Strength Down", 3);});
                    ifRelic("Cultist Headpiece", function(){alert("CAW!");});
                    ifRelic("Philosopher’s Stone", function(){for(let e of enemies){e.gainBuff("Strength", 1);}});
                    ifRelic("Snecko Eye", function(){gainBuff("Confused", 1);});
                    ifRelic("Holy Water", function(){hand.push(new Card("Miracle+", 0, "Skill", "Retain. Gain 2 energy. Exhaust.", function(enemy){energy += 2;}, ["exhausted", "retain"]))});
                }
                if(turn == 1) {ifRelic("Horn Cleat", function(){gainBuff("Block", 14)})}
                if(turn == 2) {ifRelic("Captain’s Wheel", function(){gainBuff("Block", 18)})}
                turn += 1;
                getId("turnEnder").innerHTML = "<span style='text-decoration:underline'>E</span>nd turn "+turn;
                ifRelic("Mercury Hourglass", function(){for(let e of enemies){dealDamage(e, 3)}});
                ifRelic("Damaru", function(){gainBuff("Mantra", 1);});
                scry(hasBuff("Foresight"));
                if(hasBuff("Simmering Fury")) {gainBuff("Wrath", 1); loseBuff("Simmering Fury");}
                if(hasBuff("Draw Reduction")) {
                    drawCard(4); loseBuff("Draw Reduction", 1);
                } else {
                    drawCard(5 + hasBuff("Next Turn Cards"));
                    loseBuff("Next Turn Cards");
                }
                ifRelic("Snecko Eye", function(){drawCard(2);});
                ifRelic("Serpent Ring", function(){drawCard(1);});
                ifRelic("Warped Tongs", function(){
                    let c = choice(hand.filter( x=>(!x.name.includes("+") && x.type!="Status" && x.type!="Curse" && !["Shiv", "Smite", "Insight", "Expunger", "Safety", "Through Violence", "Madness"].includes(x.name)) ));
                    if(!c) return;
                    let d = upgradedCards[c.name]();
                    hand.splice(hand.indexOf(c), 1);
                    hand.push(d);
                });
                addSmites(hasBuff("Battle Hymn"));
                addShivs(hasBuff("Infinite Blades"));
                if(hasBuff("Collect")) {
                    hand.push(new Card("Miracle+", 0, "Skill", "Retain. Gain 2 energy. Exhaust.", function(enemy){energy += 2;}, ["exhausted", "retain"]));
                    loseBuff("Collect", 1);
                }
                ifRelic("Ice Cream", function(){gainBuff("Next Turn Energy", energy);});
                energy = maxEnergy + hasBuff("Berserk") + hasBuff("Next Turn Energy") - hasBuff("Fasting") + hasBuff("Deva Form");
                if(hasBuff("Deva Form")) {gainBuff("Deva Form", 1);}
                if(stats.rested) {ifRelic("Ancient Tea Set", function(){energy += 2});}
                if(turn % 3 == 0) {ifRelic("Happy Flower", function(){energy += 1});}
                ifRelic("Slaver’s Collar", function(){if(bossBattle || eliteBattle){energy += 1;}});
                loseBuff("Next Turn Energy");
                stats.rested = false;
                if(stats.attacksThisTurn == 0) {ifRelic("Art of War", function(){energy += 1});}
                if(stats.attacksThisTurn <= 2) {ifRelic("Pocketwatch", function(){drawCard(2)})}
                stats.attacksThisTurn = 0;
                stats.skillsThisTurn = 0;
                stats.cardsThisTurn = 0;
                if(hasBuff("Barricade")==0 && hasBuff("Blur")==0){loseBuff("Block", (relics.map(x=>x.name).includes("Calipers") ? 15 : 9999));}
                loseBuff("Blur", 1);
                if(turn == 0) {
                    ifRelic("Anchor", function(){gainBuff("Block", 10)});
                    ifRelic("Lantern", function(){energy += 1});
                }
                if(hasBuff(".")) {loseBuff(".");} else {loseBuff("Vulnerable", 1);}
                gainBuff("Block", hasBuff("Metallicize"));
                gainBuff("Block", hasBuff("Plated Armor"));
                gainBuff("Block", hasBuff("Next Turn Block")); loseBuff("Next Turn Block");
                gainBuff("Mantra", hasBuff("Devotion"));
                if(hasBuff("Brutality")){hp -= 1; drawCard(hasBuff("Brutality"));}
                if(hasBuff("Tools of the Trade")){
                    drawCard(hasBuff("Tools of the Trade"));
                    let chosen = await choose(hand, "Choose a card to discard.");
                    if(chosen) {
                        discardPile.push(chosen);
                        hand.splice(hand.indexOf(chosen), 1);
                        updateHtml();
                    }
                }
                hp -= hasBuff("Poison"); loseBuff("Poison", 1);
                for(let e of enemies){e.gainBuff("Poison", hasBuff("Noxious Fumes"));}
                loseBuff("Divinity");
                loseBuff("Intangible", 1);
                updateHtml();
                /*debugging*/} catch(err) {
                    alert("Oh no!\n"+err);
                }
            }
            
            function endTurn() {
                /*debugging*/ try {
                if(turn == 7) {ifRelic("Stone Calendar", function(){for(let e of enemies){dealDamage(e, 52)}})}
                let hs = hand.length;
                for(let c of [...hand, ...drawPile, ...discardPile]) {
                    if(c.flags.map(x=>x.split(" ")[0]).includes("nextcost")) {
                        c.cost = c.flags.filter(x=>x.split(" ")[0] == "nextcost")[0].split(" ")[1];
                        c.flags = c.flags.filter(x=>x.split(" ")[0] != "nextcost");
                    }
                }
                if(hand.filter(x=>x.name=="Regret").length) hp -= hand.length;
                if(!relics.map(x=>x.name).includes("Runic Pyramid")) {
                    for(let c of hand) {
                        if(c.flags.includes("ethereal") && !c.flags.includes("retain")) {exhaustPile.push(c);}
                        else if(!c.flags.includes("retain")) {discardPile.push(c);}
                        if(c.flags.includes("retain")) {
                            c.cost = Math.max(0, c.cost - hasBuff("Establishment"));
                            if(c.name == "Sands of Time" && c.cost > 0){c.cost -= 1;}
                            if(c.name == "Sands of Time+" && c.cost > 0){c.cost -= 1;}
                            if(c.name == "Windmill Strike"){stats.windmill += 4;}
                            if(c.name == "Windmill Strike+"){stats.windmill += 7;}
                            if(c.name == "Perseverance"){stats.pers += 2;}
                            if(c.name == "Perseverance+"){stats.pers += 4;}
                        }
                        if(c.name == "Burn") {hp -= 1;}
                        if(c.name == "Burn+") {hp -= 2;}
                    }
                }
                hand = hand.filter(x=>x.flags.includes("retain"));
                if(hasBuff("Combust")) {
                    hp -= 1;
                    for(let e of enemies) {dealDamage(e, hasBuff("Combust"));}
                }
                for(let e of enemies) {dealDamage(e, hasBuff("Omega"));}
                
                if(hasBuff("Block") == 0) {ifRelic("Orichalcum", function(){gainBuff("Block", 6)});}
                if(hasBuff("Calm")) gainBuff("Block", hasBuff("Like Water"));
                ifRelic("Cloak Clasp", function(){gainBuff("Block", hs);});
                addInsights(hasBuff("Study"));
                for(let e of enemies) {e.dealDamage(e.hasBuff("Constricting"))}
                
                loseBuff("Weak", 1);
                loseBuff("Frail", 1);
                loseBuff("No Draw");
                loseBuff("Wave of the Hand");
                hp = Math.min(maxHp, hp + hasBuff("Regen"));
                loseBuff("Regen", 1);
                loseBuff("Rage");
                gainBuff("Strength", hasBuff("Ritual"));
                loseBuff("Strength", hasBuff("Strength Down"));
                loseBuff("Strength Down");
                loseBuff("Dexterity", hasBuff("Dexterity Down"));
                loseBuff("Dexterity Down");
                if(!hasBuff("Vault")) {
                    let toAct = enemies.slice(0).filter(x=>!x.hasBuff("Stunned")); // deep copy
                    for(let e of toAct) {
                        if(e.name == "Slime Boss" && e.hp <= 0.5 * e.maxHp) {
                            enemies.unshift(spikeSlimeL());
                            enemies.unshift(acidSlimeL());
                            for(let i of enemies) {i.hp = e.hp; i.maxHp = e.hp;}
                            e.hp = 0;
                            continue;
                        }
                        if(e.name == "Large Acid Slime" && e.hp <= 0.5 * e.maxHp) {
                            enemies.unshift(acidSlimeM());
                            enemies.unshift(acidSlimeM());
                            for(let i of enemies) {i.hp = e.hp; i.maxHp = e.hp;}
                            e.hp = 0;
                            continue;
                        }
                        if(e.name == "Large Acid Slime" && e.hp <= 0.5 * e.maxHp) {
                            enemies.unshift(spikeSlimeM());
                            enemies.unshift(spikeSlimeM());
                            for(let i of enemies) {i.hp = e.hp; i.maxHp = e.hp;}
                            e.hp = 0;
                            continue;
                        }
                        if(e.hasBuff("Healer") && e.hp < 0.5 * e.maxHp) {
                            e.hp = Math.ceil(0.5 * maxHp);
                            e.clearDebuffs();
                            e.loseBuff("Healer");
                            continue;
                        }
                        if(e.hasBuff("Barricade")==0){e.loseBuff("Block");}
                        e.gainBuff("Block", e.hasBuff("Metallicize"));
                        e.gainBuff("Block", e.hasBuff("Plated Armor"));
                        if(e.hasBuff("Poison")) {e.hp -= e.hasBuff("Poison"); e.loseBuff("Poison", 1);}
                        if(e.hp > 0){e.attack();}
                        if(e.hasBuff("Fading")==1) {e.hp = 0;} else {e.loseBuff("Fading", 1);}
                        e.loseBuff("Vulnerable", 1);
                        e.loseBuff("Weak", 1);
                        e.hp = Math.min(e.maxHp, e.hp + e.hasBuff("Regen"));
                        e.loseBuff("Regen", 1);
                        e.gainBuff("Strength", e.hasBuff("Ritual"));
                        e.gainBuff("Strength", e.hasBuff("Strength Up"));
                        e.loseBuff("Strength Up");
                        e.loseBuff("Dexterity", e.hasBuff("Dexterity Down"));
                        e.loseBuff("Dexterity Down");
                        e.loseBuff("Slow");
                        if(e.hasBuff("Flight")) e.gainBuff("Flight", (getId("ascensionLevel").value>=18?4:3) - e.hasBuff("Flight"));
                        if(e.hasBuff("Malleable")) e.loseBuff("Malleable", e.hasBuff("Malleable") - 3);
                    }
                } else {
                    loseBuff("Vault", 1);
                }
                updateHtml();
                startTurn();
                /*debugging*/} catch(err) {
                    alert("Oh no!\n"+err);
                }
            }
            // This has to be at the bottom because it modifies everything else
            getId("ascensionLevel").addEventListener("change", function() {
                let lv = getId("ascensionLevel").value;
                if(lv >= 1) {randomThing = () => choice(["😈","❓","💀","💀","💲","😈","🏕️"]);}
                if(lv >= 6) {hp = 0.9 * maxHp;}
                if(lv >= 10) {deck.push(new Card("Ascenders’ Bane", 0, "Curse", "Unplayable. Ethereal.", function(enemy){}, ["unplayable", "ethereal"]))}
                if(lv >= 14) {maxHp -= 5; hp -= 5;}
                if(lv >= 15) {randomThing = () => choice(["😈","😈","❓","❓","💀","💀","💀","💲","😈","🏕️"]);}
                if(lv >= 17) {
                    deck.push(new Card("Strike", 1, "Attack", "Deal [DAM6] damage.", function(enemy){dealDamage(enemy,6);}))
                }
            });
            
            function beginGame() {
                getId('introScreen').style.display = 'none';
                getId('statusContainer').style.display = 'block';
                mapGen();
                showMap();
                beforeTime = Date.now();
                currentTimer = 0;
            }
            function resetGame() {
                deck = [bash(), strike(), strike(), strike(), neutralize(), defend(), defend(), defend(), eruption(), vigilance()];
                relics = [{name: "Snake Ring", desc: "At the start of each combat, draw 2 more cards."}];
                potions = [];
                drawPile = shuffle(deck.slice(0)); // no shallow copy //
                discardPile = [];
                exhaustPile = [];
                hand = [];
                energy = 0;
                maxEnergy = 3;
                hp = 70;
                maxHp = 70;
                buffs = [];
                stats = {timesLostHp: 0, attacksThisTurn: 999, skillsThisTurn: 999, rested: false, lastType: "None", pers: 0, windmill: 0, mantraGain: 0, cardsThisTurn: 999};
                gold = 0;
                mapX = 2;
                mapY = 0;
                actNum = 1;
                turn = 0;
                crCost = 75;
                hasPaused = false;
                beginGame();
            }
            window.setInterval(updateStatLine, 47);
        </script>
    </body>
</html>
